// Autogenerated by ambiguity: DO NOT EDIT!
package tarski;
import tarski.Tokens.*;
import tarski.AST.*;
import tarski.Mods.*;
import tarski.Arounds.*;
import tarski.Operators.*;
import utility.Locations.*;

// Internal imports
import scala.collection.immutable.*;
import gnu.trove.TIntLongHashMap;
import java.util.ArrayList;
import scala.Tuple2;
import scala.Tuple3;
import scala.Tuple4;
import scala.Option;
import static utility.Locations.*;
import static tarski.ParseEddyActions.*;

class ParseEddy {
  // Parse a token stream
  public static List<List<AStmt>> parse(List<Loc<Token>> input) {
    return new Parser(input).toplevel();
  }
  
  private static final class Parser {
    private final Token[] input;
    private final long[] ranges;
    private final byte[] type;
    private final ArrayList<Object> values = new ArrayList<Object>();
    private final TIntLongHashMap slices = new TIntLongHashMap(); // (non,lo,hi) => (start,size)
    private final static long vMask = (1L<<32)-1;
    
    // Convert input and allocate working memory
    Parser(List<Loc<Token>> _input) {
      final int n = _input.size();
      assert n+1<(1<<12);
      input = new Token[n];
      ranges = new long[n];
      for (int i=0;i<n;i++) {
        final Loc<Token> tr = _input.head();
        input[i] = tr.x();
        ranges[i] = tr.raw();
        _input = (List<Loc<Token>>)_input.tail();
      }
      type = new byte[n];
    }
    
    // The entire parse
    List<List<AStmt>> toplevel() {
      // Parse
      types();
      nulls();
      nonnulls();
      
      // All done!
      final long s = slices.get(iStmts<<24|input.length);
      List<List<AStmt>> xs = (List)Nil$.MODULE$;
      for (int k=0;k<(s&vMask);k++)
        xs = $colon$colon$.MODULE$.<List<AStmt>>apply((List)values.get((int)(s>>32)+k),xs);
      return xs;
    }
    
    // Symbol ids
    private static final int iPlusEqTok = 0;
    private static final int iOrTok = 1;
    private static final int iSynchronizedTok = 2;
    private static final int iUntilTok = 3;
    private static final int iModTok = 4;
    private static final int iCommaTok = 5;
    private static final int iInTok = 6;
    private static final int iSuperTok = 7;
    private static final int iCompTok = 8;
    private static final int iAbstractTok = 9;
    private static final int iProtectedTok = 10;
    private static final int iStringLitTok = 11;
    private static final int iDotTok = 12;
    private static final int iNotTok = 13;
    private static final int iColonTok = 14;
    private static final int iInstanceofTok = 15;
    private static final int iReturnTok = 16;
    private static final int iFinalTok = 17;
    private static final int iFloatLitTok = 18;
    private static final int iLeTok = 19;
    private static final int iIdentTok = 20;
    private static final int iTransientTok = 21;
    private static final int iUnsignedRShiftEqTok = 22;
    private static final int iLtTok = 23;
    private static final int iIntLitTok = 24;
    private static final int iAndAndTok = 25;
    private static final int iRShiftEqTok = 26;
    private static final int iContinueTok = 27;
    private static final int iVolatileTok = 28;
    private static final int iRCurlyTok = 29;
    private static final int iStmtTok = 30;
    private static final int iNewTok = 31;
    private static final int iLCurlyTok = 32;
    private static final int iXorEqTok = 33;
    private static final int iEqTok = 34;
    private static final int iPrivateTok = 35;
    private static final int iBreakTok = 36;
    private static final int iLParenTok = 37;
    private static final int iWhileTok = 38;
    private static final int iMulTok = 39;
    private static final int iDoTok = 40;
    private static final int iDivTok = 41;
    private static final int iDoubleLitTok = 42;
    private static final int iPlusPlusTok = 43;
    private static final int iSemiTok = 44;
    private static final int iStaticTok = 45;
    private static final int iLBrackTok = 46;
    private static final int iXorTok = 47;
    private static final int iMinusMinusTok = 48;
    private static final int iRBrackTok = 49;
    private static final int iNeTok = 50;
    private static final int iRParenTok = 51;
    private static final int iIfTok = 52;
    private static final int iAndEqTok = 53;
    private static final int iCharLitTok = 54;
    private static final int iMinusEqTok = 55;
    private static final int iForTok = 56;
    private static final int iElifTok = 57;
    private static final int iUnsignedRShiftSepTok = 58;
    private static final int iGtTok = 59;
    private static final int iStrictfpTok = 60;
    private static final int iEqEqTok = 61;
    private static final int iExtendsTok = 62;
    private static final int iGeTok = 63;
    private static final int iThrowTok = 64;
    private static final int iElseTok = 65;
    private static final int iThenTok = 66;
    private static final int iQuestionTok = 67;
    private static final int iAssertTok = 68;
    private static final int iAndTok = 69;
    private static final int iOrEqTok = 70;
    private static final int iThisTok = 71;
    private static final int iLShiftEqTok = 72;
    private static final int iLShiftTok = 73;
    private static final int iModEqTok = 74;
    private static final int iPlusTok = 75;
    private static final int iOrOrTok = 76;
    private static final int iLongLitTok = 77;
    private static final int iAtTok = 78;
    private static final int iMulEqTok = 79;
    private static final int iPublicTok = 80;
    private static final int iMinusTok = 81;
    private static final int iRShiftSepTok = 82;
    private static final int iDivEqTok = 83;
    private static final int iCommas2_ExpAssignNC = 0;
    private static final int iMaybeThen__MaybeStmt__ElseTok = 1;
    private static final int iRight__ExpUnary_ExpJuxt = 2;
    private static final int iGtSep = 3;
    private static final int iExpCond_ExpWild__Right = 4;
    private static final int iExpHigh__Left = 5;
    private static final int iIdentDims__ForeachSep__ExpAssign = 6;
    private static final int iJuxts2_ExpWild = 7;
    private static final int iJuxts2_ExpAssignNC = 8;
    private static final int iDotTok__Option_TypeArgs__Ident = 9;
    private static final int iAssignOp = 10;
    private static final int iForInfo__Right = 11;
    private static final int iForeachSep__ExpAssign = 12;
    private static final int iMaybeStmt__ElseTok__Stmt = 13;
    private static final int iForTok__Left__ForInfo = 14;
    private static final int iWildcardBounds = 15;
    private static final int iPreOp = 16;
    private static final int iCommas2_ExpCond_ExpJuxt__Right = 17;
    private static final int iThenTok__MaybeStmt__ElifTok__AfterIf = 18;
    private static final int iThenTok__MaybeStmt__ElseTok__Stmt = 19;
    private static final int iParenExp = 20;
    private static final int iParenExp__MaybeThen = 21;
    private static final int iPostOp = 22;
    private static final int iMaybeStmt__ElifTok__AfterIf = 23;
    private static final int iCommas2_Type = 24;
    private static final int iJuxts2_ExpWildNA = 25;
    private static final int iExpParens = 26;
    private static final int iTypeArgs = 27;
    private static final int iOption_TypeArgs = 28;
    private static final int iJuxts2_VarDecl = 29;
    private static final int iMaybeThen = 30;
    private static final int iLeftNP = 31;
    private static final int iQuestionTok__ExpAssign__ColonTok__ExpCond_ExpJuxt = 32;
    private static final int iForTok__Left = 33;
    private static final int iExpAssign__Right = 34;
    private static final int iLeft = 35;
    private static final int iWhileUntil = 36;
    private static final int iJuxts2_ExpWild__Right = 37;
    private static final int iMod = 38;
    private static final int iJuxts1_Mod = 39;
    private static final int iJuxts0_Mod = 40;
    private static final int iExpAssignNP__DoTok__Stmt = 41;
    private static final int iDoTok__MaybeStmt = 42;
    private static final int iRight__Stmt = 43;
    private static final int iCommas2_ExpCond_ExpJuxt = 44;
    private static final int iJuxts2_Type = 45;
    private static final int iLParenTok__Type = 46;
    private static final int iAssignOp__ExpAssign = 47;
    private static final int iLit = 48;
    private static final int iMaybeDo = 49;
    private static final int iWhileUntil__ParenExp = 50;
    private static final int iBlock = 51;
    private static final int iRight = 52;
    private static final int iList_ExpAssignNC__Right = 53;
    private static final int iIdent = 54;
    private static final int iOption_Ident = 55;
    private static final int iExpPrimary = 56;
    private static final int iExpNew = 57;
    private static final int iExpHighNA = 58;
    private static final int iExpHighNP = 59;
    private static final int iExpHigh = 60;
    private static final int iExpWild = 61;
    private static final int iJuxts1_ExpWild = 62;
    private static final int iExpJuxt = 63;
    private static final int iExpUnary_ExpJuxt = 64;
    private static final int iExpMul_ExpJuxt = 65;
    private static final int iExpAdd_ExpJuxt = 66;
    private static final int iExpShift_ExpJuxt = 67;
    private static final int iExpRel_ExpJuxt = 68;
    private static final int iExpEq_ExpJuxt = 69;
    private static final int iExpAnd_ExpJuxt = 70;
    private static final int iExpXor_ExpJuxt = 71;
    private static final int iExpOr_ExpJuxt = 72;
    private static final int iExpAndAnd_ExpJuxt = 73;
    private static final int iExpOrOr_ExpJuxt = 74;
    private static final int iExpCond_ExpJuxt = 75;
    private static final int iExpAssignNC = 76;
    private static final int iList1_ExpAssignNC = 77;
    private static final int iList_ExpAssignNC = 78;
    private static final int iCommas1_ExpAssignNC = 79;
    private static final int iCommas0_ExpAssignNC = 80;
    private static final int iJuxts1_ExpAssignNC = 81;
    private static final int iExpCommas = 82;
    private static final int iExpAssign = 83;
    private static final int iStmtHelperBS = 84;
    private static final int iCommas1_StmtHelperBS = 85;
    private static final int iCommas0_StmtHelperBS = 86;
    private static final int iStmtHelper = 87;
    private static final int iStmt = 88;
    private static final int iMaybeDo__Stmt = 89;
    private static final int iMaybeThen__Stmt = 90;
    private static final int iMaybeStmt = 91;
    private static final int iStmts = 92;
    private static final int iOption_ExpAssign = 93;
    private static final int iCommas1_ExpCond_ExpJuxt = 94;
    private static final int iOption_ExpJuxt = 95;
    private static final int iExpUnary_ExpWild = 96;
    private static final int iExpMul_ExpWild = 97;
    private static final int iExpAdd_ExpWild = 98;
    private static final int iExpShift_ExpWild = 99;
    private static final int iExpRel_ExpWild = 100;
    private static final int iExpEq_ExpWild = 101;
    private static final int iExpAnd_ExpWild = 102;
    private static final int iExpXor_ExpWild = 103;
    private static final int iExpOr_ExpWild = 104;
    private static final int iExpAndAnd_ExpWild = 105;
    private static final int iExpOrOr_ExpWild = 106;
    private static final int iExpCond_ExpWild = 107;
    private static final int iType = 108;
    private static final int iCommas1_Type = 109;
    private static final int iOption_Type = 110;
    private static final int iJuxts0_Mod__Option_Type = 111;
    private static final int iList1_Type = 112;
    private static final int iList_Type = 113;
    private static final int iJuxts1_Type = 114;
    private static final int iExpWildNP = 115;
    private static final int iExpJuxtNP = 116;
    private static final int iExpUnary_ExpJuxtNP = 117;
    private static final int iExpMul_ExpJuxtNP = 118;
    private static final int iExpAdd_ExpJuxtNP = 119;
    private static final int iExpShift_ExpJuxtNP = 120;
    private static final int iExpRel_ExpJuxtNP = 121;
    private static final int iExpEq_ExpJuxtNP = 122;
    private static final int iExpAnd_ExpJuxtNP = 123;
    private static final int iExpXor_ExpJuxtNP = 124;
    private static final int iExpOr_ExpJuxtNP = 125;
    private static final int iExpAndAnd_ExpJuxtNP = 126;
    private static final int iExpOrOr_ExpJuxtNP = 127;
    private static final int iExpCond_ExpJuxtNP = 128;
    private static final int iExpAssignNP = 129;
    private static final int iAfterIfB = 130;
    private static final int iMaybeParenExp = 131;
    private static final int iMaybeParenExp__MaybeDo = 132;
    private static final int iAfterIfA = 133;
    private static final int iAfterIf = 134;
    private static final int iExpWildNA = 135;
    private static final int iSingleJuxt1_ExpWildNA = 136;
    private static final int iJuxts1_ExpWildNA = 137;
    private static final int iIdentDims = 138;
    private static final int iVarDecl = 139;
    private static final int iJuxts1_VarDecl = 140;
    private static final int iCommas1_VarDecl = 141;
    private static final int iForeachSep = 142;
    private static final int iSemiTok__Option_ExpAssign__SemiTok__Commas0_ExpAssignNC = 143;
    private static final int iForInfo = 144;
    private static final int iCommas2_VarDecl = 145;
    private static final int iList1_VarDecl = 146;
    private static final int iOption_Type__List1_VarDecl = 147;
    private static final int iWhileUntil__MaybeParenExp = 148;
    
    // Determine token types
    private void types() {
      final int n = input.length;
      for (int i=0;i<n;i++) {
        final Token t = input[i];
        type[i] = (byte)(
            t instanceof PlusEqTok$ ? iPlusEqTok
          : t instanceof OrTok$ ? iOrTok
          : t instanceof SynchronizedTok$ ? iSynchronizedTok
          : t instanceof UntilTok$ ? iUntilTok
          : t instanceof ModTok$ ? iModTok
          : t instanceof CommaTok$ ? iCommaTok
          : t instanceof InTok$ ? iInTok
          : t instanceof SuperTok$ ? iSuperTok
          : t instanceof CompTok$ ? iCompTok
          : t instanceof AbstractTok$ ? iAbstractTok
          : t instanceof ProtectedTok$ ? iProtectedTok
          : t instanceof StringLitTok ? iStringLitTok
          : t instanceof DotTok$ ? iDotTok
          : t instanceof NotTok$ ? iNotTok
          : t instanceof ColonTok$ ? iColonTok
          : t instanceof InstanceofTok$ ? iInstanceofTok
          : t instanceof ReturnTok$ ? iReturnTok
          : t instanceof FinalTok$ ? iFinalTok
          : t instanceof FloatLitTok ? iFloatLitTok
          : t instanceof LeTok$ ? iLeTok
          : t instanceof IdentTok ? iIdentTok
          : t instanceof TransientTok$ ? iTransientTok
          : t instanceof UnsignedRShiftEqTok$ ? iUnsignedRShiftEqTok
          : t instanceof LtTok$ ? iLtTok
          : t instanceof IntLitTok ? iIntLitTok
          : t instanceof AndAndTok$ ? iAndAndTok
          : t instanceof RShiftEqTok$ ? iRShiftEqTok
          : t instanceof ContinueTok$ ? iContinueTok
          : t instanceof VolatileTok$ ? iVolatileTok
          : t instanceof RCurlyTok$ ? iRCurlyTok
          : t instanceof StmtTok ? iStmtTok
          : t instanceof NewTok$ ? iNewTok
          : t instanceof LCurlyTok$ ? iLCurlyTok
          : t instanceof XorEqTok$ ? iXorEqTok
          : t instanceof EqTok$ ? iEqTok
          : t instanceof PrivateTok$ ? iPrivateTok
          : t instanceof BreakTok$ ? iBreakTok
          : t instanceof LParenTok$ ? iLParenTok
          : t instanceof WhileTok$ ? iWhileTok
          : t instanceof MulTok$ ? iMulTok
          : t instanceof DoTok$ ? iDoTok
          : t instanceof DivTok$ ? iDivTok
          : t instanceof DoubleLitTok ? iDoubleLitTok
          : t instanceof PlusPlusTok$ ? iPlusPlusTok
          : t instanceof SemiTok$ ? iSemiTok
          : t instanceof StaticTok$ ? iStaticTok
          : t instanceof LBrackTok$ ? iLBrackTok
          : t instanceof XorTok$ ? iXorTok
          : t instanceof MinusMinusTok$ ? iMinusMinusTok
          : t instanceof RBrackTok$ ? iRBrackTok
          : t instanceof NeTok$ ? iNeTok
          : t instanceof RParenTok$ ? iRParenTok
          : t instanceof IfTok$ ? iIfTok
          : t instanceof AndEqTok$ ? iAndEqTok
          : t instanceof CharLitTok ? iCharLitTok
          : t instanceof MinusEqTok$ ? iMinusEqTok
          : t instanceof ForTok$ ? iForTok
          : t instanceof ElifTok ? iElifTok
          : t instanceof UnsignedRShiftSepTok$ ? iUnsignedRShiftSepTok
          : t instanceof GtTok$ ? iGtTok
          : t instanceof StrictfpTok$ ? iStrictfpTok
          : t instanceof EqEqTok$ ? iEqEqTok
          : t instanceof ExtendsTok$ ? iExtendsTok
          : t instanceof GeTok$ ? iGeTok
          : t instanceof ThrowTok$ ? iThrowTok
          : t instanceof ElseTok$ ? iElseTok
          : t instanceof ThenTok$ ? iThenTok
          : t instanceof QuestionTok$ ? iQuestionTok
          : t instanceof AssertTok$ ? iAssertTok
          : t instanceof AndTok$ ? iAndTok
          : t instanceof OrEqTok$ ? iOrEqTok
          : t instanceof ThisTok$ ? iThisTok
          : t instanceof LShiftEqTok$ ? iLShiftEqTok
          : t instanceof LShiftTok$ ? iLShiftTok
          : t instanceof ModEqTok$ ? iModEqTok
          : t instanceof PlusTok$ ? iPlusTok
          : t instanceof OrOrTok$ ? iOrOrTok
          : t instanceof LongLitTok ? iLongLitTok
          : t instanceof AtTok$ ? iAtTok
          : t instanceof MulEqTok$ ? iMulEqTok
          : t instanceof PublicTok$ ? iPublicTok
          : t instanceof MinusTok$ ? iMinusTok
          : t instanceof RShiftSepTok$ ? iRShiftSepTok
          : t instanceof DivEqTok$ ? iDivEqTok
          : 255);
      }
    }
    
    // Parse null productions
    private void nulls() {
      final int n = input.length;
      long slice;
      int next = values.size();
      // GtSep is simple
      for (int i=0;i<=n;i++) slices.put(iGtSep<<24|i<<12|i,1);
      values.add(WildcardBounds3()); // WildcardBounds -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iWildcardBounds<<24|i<<12|i,slice);
      values.add(Option_TypeArgs1()); // Option_TypeArgs -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iOption_TypeArgs<<24|i<<12|i,slice);
      values.add(MaybeThen1()); // MaybeThen -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iMaybeThen<<24|i<<12|i,slice);
      values.add(Juxts0_Mod1()); // Juxts0_Mod -> "" : Nil
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iJuxts0_Mod<<24|i<<12|i,slice);
      values.add(MaybeDo1()); // MaybeDo -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iMaybeDo<<24|i<<12|i,slice);
      values.add(Option_Ident1()); // Option_Ident -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iOption_Ident<<24|i<<12|i,slice);
      values.add(List_ExpAssignNC1()); // List_ExpAssignNC -> "" : EmptyList
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iList_ExpAssignNC<<24|i<<12|i,slice);
      values.add(Commas0_ExpAssignNC1()); // Commas0_ExpAssignNC -> "" : EmptyList
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iCommas0_ExpAssignNC<<24|i<<12|i,slice);
      values.add(Commas0_StmtHelperBS1()); // Commas0_StmtHelperBS -> "" : EmptyList
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iCommas0_StmtHelperBS<<24|i<<12|i,slice);
      values.add(MaybeStmt1()); // MaybeStmt -> "" : HoleAStmt(SRange.empty)
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iMaybeStmt<<24|i<<12|i,slice);
      values.add(Stmts3()); // Stmts -> "" : Nil
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iStmts<<24|i<<12|i,slice);
      values.add(Option_ExpAssign1()); // Option_ExpAssign -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iOption_ExpAssign<<24|i<<12|i,slice);
      values.add(Option_ExpJuxt1()); // Option_ExpJuxt -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iOption_ExpJuxt<<24|i<<12|i,slice);
      values.add(Option_Type1()); // Option_Type -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iOption_Type<<24|i<<12|i,slice);
      values.add(Juxts0_Mod__Option_Type0((List)values.get((int)(slices.get(iJuxts0_Mod<<24)>>32)),(Option)values.get((int)(slices.get(iOption_Type<<24)>>32)))); // Juxts0_Mod__Option_Type -> Juxts0_Mod Option_Type : ($1,$2)
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iJuxts0_Mod__Option_Type<<24|i<<12|i,slice);
      values.add(List_Type1()); // List_Type -> "" : EmptyList
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iList_Type<<24|i<<12|i,slice);
    }
    
    // Parse nonnull productions
    private void nonnulls() {
      final int n = input.length;
      for (int lo=n;lo>=0;lo--) for (int hi=lo+1;hi<=n;hi++) {
        final long range = unionHelper(ranges[lo],ranges[hi-1]);
        Commas2_ExpAssignNC(lo,hi,range);
        MaybeThen__MaybeStmt__ElseTok(lo,hi,range);
        Right__ExpUnary_ExpJuxt(lo,hi,range);
        GtSep(lo,hi,range);
        ExpCond_ExpWild__Right(lo,hi,range);
        ExpHigh__Left(lo,hi,range);
        IdentDims__ForeachSep__ExpAssign(lo,hi,range);
        Juxts2_ExpWild(lo,hi,range);
        Juxts2_ExpAssignNC(lo,hi,range);
        DotTok__Option_TypeArgs__Ident(lo,hi,range);
        AssignOp(lo,hi,range);
        ForInfo__Right(lo,hi,range);
        ForeachSep__ExpAssign(lo,hi,range);
        MaybeStmt__ElseTok__Stmt(lo,hi,range);
        ForTok__Left__ForInfo(lo,hi,range);
        WildcardBounds(lo,hi,range);
        PreOp(lo,hi,range);
        Commas2_ExpCond_ExpJuxt__Right(lo,hi,range);
        ThenTok__MaybeStmt__ElifTok__AfterIf(lo,hi,range);
        ThenTok__MaybeStmt__ElseTok__Stmt(lo,hi,range);
        ParenExp(lo,hi,range);
        ParenExp__MaybeThen(lo,hi,range);
        PostOp(lo,hi,range);
        MaybeStmt__ElifTok__AfterIf(lo,hi,range);
        Commas2_Type(lo,hi,range);
        Juxts2_ExpWildNA(lo,hi,range);
        ExpParens(lo,hi,range);
        TypeArgs(lo,hi,range);
        Option_TypeArgs(lo,hi,range);
        Juxts2_VarDecl(lo,hi,range);
        MaybeThen(lo,hi,range);
        LeftNP(lo,hi,range);
        QuestionTok__ExpAssign__ColonTok__ExpCond_ExpJuxt(lo,hi,range);
        ForTok__Left(lo,hi,range);
        ExpAssign__Right(lo,hi,range);
        Left(lo,hi,range);
        WhileUntil(lo,hi,range);
        Juxts2_ExpWild__Right(lo,hi,range);
        Mod(lo,hi,range);
        Juxts1_Mod(lo,hi,range);
        Juxts0_Mod(lo,hi,range);
        ExpAssignNP__DoTok__Stmt(lo,hi,range);
        DoTok__MaybeStmt(lo,hi,range);
        Right__Stmt(lo,hi,range);
        Commas2_ExpCond_ExpJuxt(lo,hi,range);
        Juxts2_Type(lo,hi,range);
        LParenTok__Type(lo,hi,range);
        AssignOp__ExpAssign(lo,hi,range);
        Lit(lo,hi,range);
        MaybeDo(lo,hi,range);
        WhileUntil__ParenExp(lo,hi,range);
        Block(lo,hi,range);
        Right(lo,hi,range);
        List_ExpAssignNC__Right(lo,hi,range);
        Ident(lo,hi,range);
        Option_Ident(lo,hi,range);
        ExpPrimary(lo,hi,range);
        ExpNew(lo,hi,range);
        ExpHighNA(lo,hi,range);
        ExpHighNP(lo,hi,range);
        ExpHigh(lo,hi,range);
        ExpWild(lo,hi,range);
        Juxts1_ExpWild(lo,hi,range);
        ExpJuxt(lo,hi,range);
        ExpUnary_ExpJuxt(lo,hi,range);
        ExpMul_ExpJuxt(lo,hi,range);
        ExpAdd_ExpJuxt(lo,hi,range);
        ExpShift_ExpJuxt(lo,hi,range);
        ExpRel_ExpJuxt(lo,hi,range);
        ExpEq_ExpJuxt(lo,hi,range);
        ExpAnd_ExpJuxt(lo,hi,range);
        ExpXor_ExpJuxt(lo,hi,range);
        ExpOr_ExpJuxt(lo,hi,range);
        ExpAndAnd_ExpJuxt(lo,hi,range);
        ExpOrOr_ExpJuxt(lo,hi,range);
        ExpCond_ExpJuxt(lo,hi,range);
        ExpAssignNC(lo,hi,range);
        List1_ExpAssignNC(lo,hi,range);
        List_ExpAssignNC(lo,hi,range);
        Commas1_ExpAssignNC(lo,hi,range);
        Commas0_ExpAssignNC(lo,hi,range);
        Juxts1_ExpAssignNC(lo,hi,range);
        ExpCommas(lo,hi,range);
        ExpAssign(lo,hi,range);
        StmtHelperBS(lo,hi,range);
        Commas1_StmtHelperBS(lo,hi,range);
        Commas0_StmtHelperBS(lo,hi,range);
        StmtHelper(lo,hi,range);
        Stmt(lo,hi,range);
        MaybeDo__Stmt(lo,hi,range);
        MaybeThen__Stmt(lo,hi,range);
        MaybeStmt(lo,hi,range);
        Stmts(lo,hi,range);
        Option_ExpAssign(lo,hi,range);
        Commas1_ExpCond_ExpJuxt(lo,hi,range);
        Option_ExpJuxt(lo,hi,range);
        ExpUnary_ExpWild(lo,hi,range);
        ExpMul_ExpWild(lo,hi,range);
        ExpAdd_ExpWild(lo,hi,range);
        ExpShift_ExpWild(lo,hi,range);
        ExpRel_ExpWild(lo,hi,range);
        ExpEq_ExpWild(lo,hi,range);
        ExpAnd_ExpWild(lo,hi,range);
        ExpXor_ExpWild(lo,hi,range);
        ExpOr_ExpWild(lo,hi,range);
        ExpAndAnd_ExpWild(lo,hi,range);
        ExpOrOr_ExpWild(lo,hi,range);
        ExpCond_ExpWild(lo,hi,range);
        Type(lo,hi,range);
        Commas1_Type(lo,hi,range);
        Option_Type(lo,hi,range);
        Juxts0_Mod__Option_Type(lo,hi,range);
        List1_Type(lo,hi,range);
        List_Type(lo,hi,range);
        Juxts1_Type(lo,hi,range);
        ExpWildNP(lo,hi,range);
        ExpJuxtNP(lo,hi,range);
        ExpUnary_ExpJuxtNP(lo,hi,range);
        ExpMul_ExpJuxtNP(lo,hi,range);
        ExpAdd_ExpJuxtNP(lo,hi,range);
        ExpShift_ExpJuxtNP(lo,hi,range);
        ExpRel_ExpJuxtNP(lo,hi,range);
        ExpEq_ExpJuxtNP(lo,hi,range);
        ExpAnd_ExpJuxtNP(lo,hi,range);
        ExpXor_ExpJuxtNP(lo,hi,range);
        ExpOr_ExpJuxtNP(lo,hi,range);
        ExpAndAnd_ExpJuxtNP(lo,hi,range);
        ExpOrOr_ExpJuxtNP(lo,hi,range);
        ExpCond_ExpJuxtNP(lo,hi,range);
        ExpAssignNP(lo,hi,range);
        AfterIfB(lo,hi,range);
        MaybeParenExp(lo,hi,range);
        MaybeParenExp__MaybeDo(lo,hi,range);
        AfterIfA(lo,hi,range);
        AfterIf(lo,hi,range);
        ExpWildNA(lo,hi,range);
        SingleJuxt1_ExpWildNA(lo,hi,range);
        Juxts1_ExpWildNA(lo,hi,range);
        IdentDims(lo,hi,range);
        VarDecl(lo,hi,range);
        Juxts1_VarDecl(lo,hi,range);
        Commas1_VarDecl(lo,hi,range);
        ForeachSep(lo,hi,range);
        SemiTok__Option_ExpAssign__SemiTok__Commas0_ExpAssignNC(lo,hi,range);
        ForInfo(lo,hi,range);
        Commas2_VarDecl(lo,hi,range);
        List1_VarDecl(lo,hi,range);
        Option_Type__List1_VarDecl(lo,hi,range);
        WhileUntil__MaybeParenExp(lo,hi,range);
      }
    }
    
    private void Commas2_ExpAssignNC(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iExpAssignNC<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_ExpAssignNC<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas2_ExpAssignNC0((AExp)values.get((int)(s1>>32)+k1),(CommaList1)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas2_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeThen__MaybeStmt__ElseTok(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1 && type[hi-1]==iElseTok) {
        for (int j=lo;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iMaybeThen<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeStmt<<24|j<<12|hi-1); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(MaybeThen__MaybeStmt__ElseTok0((AStmt)values.get((int)(s3>>32)+k3),ranges[hi-1]));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeThen__MaybeStmt__ElseTok<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Right__ExpUnary_ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iRight<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Right__ExpUnary_ExpJuxt0((Loc)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iRight__ExpUnary_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void GtSep(final int lo, final int hi, final long range) {
      boolean found = false;
      if (hi-lo==1 && type[lo]==iUnsignedRShiftSepTok)
        found = true;
      if (hi-lo==1 && type[lo]==iRShiftSepTok)
        found = true;
      if (found) { slices.put(iGtSep<<24|lo<<12|hi,1); }
    }
    
    private void ExpCond_ExpWild__Right(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpCond_ExpWild<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpCond_ExpWild__Right0((AExp)values.get((int)(s1>>32)+k1),(Loc)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpCond_ExpWild__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpHigh__Left(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpHigh<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iLeft<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHigh__Left0((AExp)values.get((int)(s1>>32)+k1),(Loc)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpHigh__Left<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void IdentDims__ForeachSep__ExpAssign(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iIdentDims<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iForeachSep__ExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(IdentDims__ForeachSep__ExpAssign0((Tuple2)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iIdentDims__ForeachSep__ExpAssign<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_ExpWild(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpWild<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpWild<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_ExpWild0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_ExpWild<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_ExpAssignNC(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpAssignNC<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpAssignNC<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_ExpAssignNC0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void DotTok__Option_TypeArgs__Ident(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2 && type[lo]==iDotTok) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iOption_TypeArgs<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iIdent<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(DotTok__Option_TypeArgs__Ident0((Option)values.get((int)(s1>>32)+k1),(Loc)values.get((int)(s3>>32)+k3),ranges[lo]));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iDotTok__Option_TypeArgs__Ident<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void AssignOp(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iOrEqTok)
        values.add(AssignOp0(range));
      if (hi-lo==1 && type[lo]==iPlusEqTok)
        values.add(AssignOp1(range));
      if (hi-lo==1 && type[lo]==iMinusEqTok)
        values.add(AssignOp2(range));
      if (hi-lo==1 && type[lo]==iModEqTok)
        values.add(AssignOp3(range));
      if (hi-lo==1 && type[lo]==iAndEqTok)
        values.add(AssignOp4(range));
      if (hi-lo==1 && type[lo]==iEqTok)
        values.add(AssignOp5(range));
      if (hi-lo==1 && type[lo]==iUnsignedRShiftEqTok)
        values.add(AssignOp6(range));
      if (hi-lo==1 && type[lo]==iRShiftEqTok)
        values.add(AssignOp7(range));
      if (hi-lo==1 && type[lo]==iMulEqTok)
        values.add(AssignOp8(range));
      if (hi-lo==1 && type[lo]==iDivEqTok)
        values.add(AssignOp9(range));
      if (hi-lo==1 && type[lo]==iLShiftEqTok)
        values.add(AssignOp10(range));
      if (hi-lo==1 && type[lo]==iXorEqTok)
        values.add(AssignOp11(range));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iAssignOp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForInfo__Right(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+2;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iForInfo<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ForInfo__Right0((ForInfo)values.get((int)(s1>>32)+k1),(Loc)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iForInfo__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForeachSep__ExpAssign(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iForeachSep<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ForeachSep__ExpAssign0((Long)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iForeachSep__ExpAssign<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeStmt__ElseTok__Stmt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo;j<=hi-2;j++) {
          if (type[j]==iElseTok) {
            final long s1 = slices.get(iMaybeStmt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(MaybeStmt__ElseTok__Stmt0((AStmt)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeStmt__ElseTok__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForTok__Left__ForInfo(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=4 && type[lo]==iForTok) {
        for (int j=lo+2;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iLeft<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iForInfo<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ForTok__Left__ForInfo0((Loc)values.get((int)(s1>>32)+k1),(ForInfo)values.get((int)(s3>>32)+k3),ranges[lo]));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iForTok__Left__ForInfo<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void WildcardBounds(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2 && type[lo]==iSuperTok) {
        final long s1 = slices.get(iType<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(WildcardBounds0((AExp)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      if (hi-lo>=2 && type[lo]==iColonTok) {
        final long s1 = slices.get(iType<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(WildcardBounds1((AExp)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      if (hi-lo>=2 && type[lo]==iExtendsTok) {
        final long s1 = slices.get(iType<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(WildcardBounds2((AExp)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iWildcardBounds<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void PreOp(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iMinusTok)
        values.add(PreOp0(range));
      if (hi-lo==1 && type[lo]==iNotTok)
        values.add(PreOp1(range));
      if (hi-lo==1 && type[lo]==iMinusMinusTok)
        values.add(PreOp2(range));
      if (hi-lo==1 && type[lo]==iPlusTok)
        values.add(PreOp3(range));
      if (hi-lo==1 && type[lo]==iPlusPlusTok)
        values.add(PreOp4(range));
      if (hi-lo==1 && type[lo]==iCompTok)
        values.add(PreOp5(range));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iPreOp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas2_ExpCond_ExpJuxt__Right(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=4) {
        for (int j=lo+3;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iCommas2_ExpCond_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas2_ExpCond_ExpJuxt__Right0((CommaList2)values.get((int)(s1>>32)+k1),(Loc)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas2_ExpCond_ExpJuxt__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ThenTok__MaybeStmt__ElifTok__AfterIf(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3 && type[lo]==iThenTok) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iElifTok) {
            final long s1 = slices.get(iMaybeStmt<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iAfterIf<<24|j+1<<12|hi); if (s3 == 0) continue;
            ElifTok x0 = (ElifTok)input[j];
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ThenTok__MaybeStmt__ElifTok__AfterIf0((AStmt)values.get((int)(s1>>32)+k1),x0,(PreIf)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iThenTok__MaybeStmt__ElifTok__AfterIf<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ThenTok__MaybeStmt__ElseTok__Stmt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3 && type[lo]==iThenTok) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iElseTok) {
            final long s1 = slices.get(iMaybeStmt<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ThenTok__MaybeStmt__ElseTok__Stmt0((AStmt)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iThenTok__MaybeStmt__ElseTok__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ParenExp(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iLeft<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssign__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ParenExp0((Loc)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iParenExp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ParenExp__MaybeThen(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+3;j<=hi;j++) {
          {
            final long s1 = slices.get(iParenExp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeThen<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ParenExp__MaybeThen0((Tuple2)values.get((int)(s1>>32)+k1)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iParenExp__MaybeThen<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void PostOp(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iMinusMinusTok)
        values.add(PostOp0(range));
      if (hi-lo==1 && type[lo]==iPlusPlusTok)
        values.add(PostOp1(range));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iPostOp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeStmt__ElifTok__AfterIf(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo;j<=hi-2;j++) {
          if (type[j]==iElifTok) {
            final long s1 = slices.get(iMaybeStmt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iAfterIf<<24|j+1<<12|hi); if (s3 == 0) continue;
            ElifTok x0 = (ElifTok)input[j];
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(MaybeStmt__ElifTok__AfterIf0((AStmt)values.get((int)(s1>>32)+k1),x0,(PreIf)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeStmt__ElifTok__AfterIf<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas2_Type(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iType<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_Type<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas2_Type0((AExp)values.get((int)(s1>>32)+k1),(CommaList1)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas2_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_ExpWildNA(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpWildNA<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpWildNA<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_ExpWildNA0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_ExpWildNA<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpParens(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=4 && type[lo]==iLParenTok) {
        for (int j=lo+3;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iJuxts2_ExpWild<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpParens0((List)values.get((int)(s1>>32)+k1),(Loc)values.get((int)(s3>>32)+k3),ranges[lo]));
            }
          }
        }
      }
      if (hi-lo>=5 && type[lo]==iLParenTok) {
        for (int j=lo+4;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iCommas2_ExpCond_ExpJuxt<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpParens1((CommaList2)values.get((int)(s1>>32)+k1),(Loc)values.get((int)(s3>>32)+k3),ranges[lo]));
            }
          }
        }
      }
      if (hi-lo==2 && type[lo]==iLParenTok) {
        final long s1 = slices.get(iRight<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpParens2((Loc)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      if (hi-lo>=3 && type[lo]==iLParenTok) {
        for (int j=lo+2;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpAssignNC<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpParens3((AExp)values.get((int)(s1>>32)+k1),(Loc)values.get((int)(s3>>32)+k3),ranges[lo]));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpParens<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void TypeArgs(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2 && type[lo]==iLtTok && type[hi-1]==iGtTok) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iList_Type<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iGtSep<<24|j<<12|hi-1); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++)
              values.add(TypeArgs0((KList)values.get((int)(s1>>32)+k1),ranges[lo],ranges[hi-1]));
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iTypeArgs<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_TypeArgs(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        final long s1 = slices.get(iTypeArgs<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Option_TypeArgs0((Grouped)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_TypeArgs<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_VarDecl(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iVarDecl<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_VarDecl<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_VarDecl0((AVarDecl)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeThen(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iThenTok)
        values.add(MaybeThen0(ranges[lo]));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeThen<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void LeftNP(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iLCurlyTok)
        values.add(LeftNP0(range));
      if (hi-lo==1 && type[lo]==iLBrackTok)
        values.add(LeftNP1(range));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iLeftNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void QuestionTok__ExpAssign__ColonTok__ExpCond_ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=4 && type[lo]==iQuestionTok) {
        for (int j=lo+2;j<=hi-2;j++) {
          if (type[j]==iColonTok) {
            final long s1 = slices.get(iExpAssign<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpCond_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(QuestionTok__ExpAssign__ColonTok__ExpCond_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[lo],ranges[j]));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iQuestionTok__ExpAssign__ColonTok__ExpCond_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForTok__Left(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo==2 && type[lo]==iForTok) {
        final long s1 = slices.get(iLeft<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ForTok__Left0((Loc)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iForTok__Left<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAssign__Right(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpAssign<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAssign__Right0((AExp)values.get((int)(s1>>32)+k1),(Loc)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAssign__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Left(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iLCurlyTok)
        values.add(Left0(range));
      if (hi-lo==1 && type[lo]==iLBrackTok)
        values.add(Left1(range));
      if (hi-lo==1 && type[lo]==iLParenTok)
        values.add(Left2(range));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iLeft<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void WhileUntil(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iUntilTok)
        values.add(WhileUntil0(ranges[lo]));
      if (hi-lo==1 && type[lo]==iWhileTok)
        values.add(WhileUntil1(ranges[lo]));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iWhileUntil<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_ExpWild__Right(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+2;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iJuxts2_ExpWild<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_ExpWild__Right0((List)values.get((int)(s1>>32)+k1),(Loc)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_ExpWild__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Mod(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iTransientTok)
        values.add(Mod0(ranges[lo]));
      if (hi-lo==1 && type[lo]==iAbstractTok)
        values.add(Mod1(ranges[lo]));
      if (hi-lo==2 && type[lo]==iAtTok) {
        final long s1 = slices.get(iIdent<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Mod2((Loc)values.get((int)(s1>>32)+k),ranges[lo],range));
        }
      }
      if (hi-lo==1 && type[lo]==iStrictfpTok)
        values.add(Mod3(ranges[lo]));
      if (hi-lo==1 && type[lo]==iFinalTok)
        values.add(Mod4(ranges[lo]));
      if (hi-lo==1 && type[lo]==iProtectedTok)
        values.add(Mod5(ranges[lo]));
      if (hi-lo==1 && type[lo]==iStaticTok)
        values.add(Mod6(ranges[lo]));
      if (hi-lo==1 && type[lo]==iPrivateTok)
        values.add(Mod7(ranges[lo]));
      if (hi-lo==1 && type[lo]==iPublicTok)
        values.add(Mod8(ranges[lo]));
      if (hi-lo==1 && type[lo]==iSynchronizedTok)
        values.add(Mod9(ranges[lo]));
      if (hi-lo==1 && type[lo]==iVolatileTok)
        values.add(Mod10(ranges[lo]));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMod<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_Mod(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iMod<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_Mod<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_Mod0((Loc)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (1<=hi-lo && hi-lo<=2) {
        final long s1 = slices.get(iMod<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_Mod1((Loc)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_Mod<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts0_Mod(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iJuxts1_Mod<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts0_Mod0((List)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts0_Mod<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAssignNP__DoTok__Stmt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iDoTok) {
            final long s1 = slices.get(iExpAssignNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAssignNP__DoTok__Stmt0((AExp)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAssignNP__DoTok__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void DoTok__MaybeStmt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iDoTok) {
        final long s1 = slices.get(iMaybeStmt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(DoTok__MaybeStmt0((AStmt)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iDoTok__MaybeStmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Right__Stmt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iRight<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Right__Stmt0((Loc)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iRight__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas2_ExpCond_ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iExpCond_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_ExpCond_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas2_ExpCond_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(CommaList1)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas2_ExpCond_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_Type(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iType<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_Type<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_Type0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void LParenTok__Type(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2 && type[lo]==iLParenTok) {
        final long s1 = slices.get(iType<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(LParenTok__Type0((AExp)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iLParenTok__Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void AssignOp__ExpAssign(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iAssignOp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(AssignOp__ExpAssign0((Loc)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iAssignOp__ExpAssign<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Lit(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iIntLitTok)
        values.add(Lit0((IntLitTok)input[lo],range));
      if (hi-lo==1 && type[lo]==iDoubleLitTok)
        values.add(Lit1((DoubleLitTok)input[lo],range));
      if (hi-lo==1 && type[lo]==iFloatLitTok)
        values.add(Lit2((FloatLitTok)input[lo],range));
      if (hi-lo==1 && type[lo]==iLongLitTok)
        values.add(Lit3((LongLitTok)input[lo],range));
      if (hi-lo==1 && type[lo]==iStringLitTok)
        values.add(Lit4((StringLitTok)input[lo],range));
      if (hi-lo==1 && type[lo]==iCharLitTok)
        values.add(Lit5((CharLitTok)input[lo],range));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iLit<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeDo(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iDoTok)
        values.add(MaybeDo0(ranges[lo]));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeDo<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void WhileUntil__ParenExp(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=4) {
        for (int j=lo+1;j<=hi-3;j++) {
          {
            final long s1 = slices.get(iWhileUntil<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iParenExp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(WhileUntil__ParenExp0((Loc)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iWhileUntil__ParenExp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Block(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2 && type[lo]==iLCurlyTok) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iStmts<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Block0((List)values.get((int)(s1>>32)+k1),(Loc)values.get((int)(s3>>32)+k3),ranges[lo]));
            }
          }
        }
      }
      if (hi-lo==1 && type[lo]==iStmtTok)
        values.add(Block1((StmtTok)input[lo],ranges[lo]));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iBlock<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Right(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iRCurlyTok)
        values.add(Right0(range));
      if (hi-lo==1 && type[lo]==iRBrackTok)
        values.add(Right1(range));
      if (hi-lo==1 && type[lo]==iRParenTok)
        values.add(Right2(range));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iRight<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List_ExpAssignNC__Right(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1) {
        for (int j=lo;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iList_ExpAssignNC<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(List_ExpAssignNC__Right0((KList)values.get((int)(s1>>32)+k1),(Loc)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList_ExpAssignNC__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Ident(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iUntilTok)
        values.add(Ident0(ranges[lo]));
      if (hi-lo==1 && type[lo]==iInTok)
        values.add(Ident1(ranges[lo]));
      if (hi-lo==1 && type[lo]==iThenTok)
        values.add(Ident2(ranges[lo]));
      if (hi-lo==1 && type[lo]==iElifTok)
        values.add(Ident3((ElifTok)input[lo],ranges[lo]));
      if (hi-lo==1 && type[lo]==iIdentTok)
        values.add(Ident4((IdentTok)input[lo],ranges[lo]));
      if (hi-lo==1 && type[lo]==iSuperTok)
        values.add(Ident5(ranges[lo]));
      if (hi-lo==1 && type[lo]==iThisTok)
        values.add(Ident6(ranges[lo]));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iIdent<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_Ident(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo==1) {
        final long s1 = slices.get(iIdent<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Option_Ident0((Loc)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_Ident<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpPrimary(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iExpHigh<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iTypeArgs<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpPrimary0((AExp)values.get((int)(s1>>32)+k1),(Grouped)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iExpHigh<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iDotTok__Option_TypeArgs__Ident<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpPrimary1((AExp)values.get((int)(s1>>32)+k1),(Tuple3)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo==1) {
        final long s1 = slices.get(iIdent<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpPrimary2((Loc)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo==1) {
        final long s1 = slices.get(iLit<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpPrimary3((ALit)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpPrimary<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpNew(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2 && type[lo]==iNewTok) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iOption_TypeArgs<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpPrimary<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpNew0((Option)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[lo]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+2;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iTypeArgs<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpPrimary<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpNew1((Grouped)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpPrimary<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpNew2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpHighNA(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+2;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpHigh__Left<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iList_ExpAssignNC__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNA0((Tuple2)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpHighNA1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpHighNA<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpHighNP(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iLeftNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpCond_ExpWild__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNP0((Loc)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=5) {
        for (int j=lo+1;j<=hi-4;j++) {
          {
            final long s1 = slices.get(iLeftNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas2_ExpCond_ExpJuxt__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNP1((Loc)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=4) {
        for (int j=lo+1;j<=hi-3;j++) {
          {
            final long s1 = slices.get(iLeftNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts2_ExpWild__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNP2((Loc)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo==2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iLeftNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNP3((Loc)values.get((int)(s1>>32)+k1),(Loc)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpHighNA<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpHighNP4((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpHighNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpHigh(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpHighNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpHigh0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=2) {
        final long s1 = slices.get(iExpParens<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpHigh1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpHigh<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpWild(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iQuestionTok) {
        final long s1 = slices.get(iWildcardBounds<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpWild0((Option)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpHigh<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpWild1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpWild<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_ExpWild(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpWild<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpWild<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_ExpWild0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpWild<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_ExpWild1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_ExpWild<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpWild<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iSingleJuxt1_ExpWildNA<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(KList)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpWild<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpUnary_ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=4) {
        for (int j=lo+2;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iLParenTok__Type<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight__ExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxt0((Tuple2)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iPreOp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxt1((Loc)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpUnary_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iPostOp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxt2((AExp)values.get((int)(s1>>32)+k1),(Loc)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpUnary_ExpJuxt3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpUnary_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpMul_ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iModTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iDivTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxt1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iMulTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxt2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpUnary_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpMul_ExpJuxt3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpMul_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAdd_ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iMinusTok) {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpMul_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iPlusTok) {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpMul_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpJuxt1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAdd_ExpJuxt2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAdd_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpShift_ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=7) {
        for (int j=lo+1;j<=hi-6;j++) {
          if (type[j]==iGtTok && type[j+1]==iUnsignedRShiftSepTok && type[j+2]==iGtTok && type[j+3]==iUnsignedRShiftSepTok && type[j+4]==iGtTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+5<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j],ranges[j+4]));
            }
          }
        }
      }
      if (hi-lo>=5) {
        for (int j=lo+1;j<=hi-4;j++) {
          if (type[j]==iGtTok && type[j+1]==iRShiftSepTok && type[j+2]==iGtTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+3<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxt1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j],ranges[j+2]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLShiftTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxt2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpShift_ExpJuxt3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpShift_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpRel_ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iGtTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iInstanceofTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iType<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxt1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLtTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxt2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iGeTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxt3((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLeTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxt4((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpRel_ExpJuxt5((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpRel_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpEq_ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iNeTok) {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpRel_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iEqEqTok) {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpRel_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpJuxt1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpEq_ExpJuxt2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpEq_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAnd_ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iAndTok) {
            final long s1 = slices.get(iExpAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpEq_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAnd_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAnd_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAnd_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpXor_ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iXorTok) {
            final long s1 = slices.get(iExpXor_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAnd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpXor_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAnd_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpXor_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpXor_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOr_ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iOrTok) {
            final long s1 = slices.get(iExpOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpXor_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOr_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpXor_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOr_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOr_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAndAnd_ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iAndAndTok) {
            final long s1 = slices.get(iExpAndAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpOr_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAndAnd_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpOr_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAndAnd_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAndAnd_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOrOr_ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iOrOrTok) {
            final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAndAnd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOrOr_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAndAnd_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOrOr_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOrOr_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpCond_ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=5) {
        for (int j=lo+1;j<=hi-4;j++) {
          {
            final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iQuestionTok__ExpAssign__ColonTok__ExpCond_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpCond_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(Tuple4)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpCond_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpCond_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAssignNC(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iAssignOp__ExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAssignNC0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpCond_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAssignNC1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List1_ExpAssignNC(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        final long s1 = slices.get(iJuxts2_ExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_ExpAssignNC0((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=3) {
        final long s1 = slices.get(iCommas2_ExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_ExpAssignNC1((CommaList2)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_ExpAssignNC2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList1_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List_ExpAssignNC(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iList1_ExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List_ExpAssignNC0((KList)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas1_ExpAssignNC(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iExpAssignNC<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_ExpAssignNC<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas1_ExpAssignNC0((AExp)values.get((int)(s1>>32)+k1),(CommaList1)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas1_ExpAssignNC1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas1_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas0_ExpAssignNC(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iCommas1_ExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas0_ExpAssignNC0((CommaList1)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas0_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_ExpAssignNC(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpAssignNC<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpAssignNC<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_ExpAssignNC0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_ExpAssignNC1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpCommas(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        final long s1 = slices.get(iCommas2_ExpCond_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpCommas0((CommaList2)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpCond_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpCommas1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpCommas<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAssign(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iAssignOp__ExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAssign0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpCommas<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAssign1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAssign<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void StmtHelperBS(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iType<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iList1_VarDecl<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS0((AExp)values.get((int)(s1>>32)+k1),(KList)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=5 && type[lo]==iForTok) {
        for (int j=lo+3;j<=hi-2;j++) {
          if (type[j]==iDoTok) {
            final long s1 = slices.get(iForInfo<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS1((ForInfo)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3),ranges[lo]));
            }
          }
        }
      }
      if (hi-lo>=2 && type[lo]==iThrowTok) {
        final long s1 = slices.get(iExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS2((AExp)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      if (hi-lo>=4) {
        for (int j=lo+1;j<=hi-3;j++) {
          {
            final long s1 = slices.get(iWhileUntil<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssignNP__DoTok__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS3((Loc)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=4 && type[lo]==iAssertTok) {
        for (int j=lo+2;j<=hi-2;j++) {
          if (type[j]==iColonTok) {
            final long s1 = slices.get(iExpJuxt<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS4((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[lo],ranges[j]));
            }
          }
        }
      }
      if (1<=hi-lo && hi-lo<=2 && type[lo]==iBreakTok) {
        final long s1 = slices.get(iOption_Ident<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS5((Option)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iDoTok__MaybeStmt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iWhileUntil__MaybeParenExp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS6((Tuple2)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3 && type[lo]==iSynchronizedTok) {
        for (int j=lo+2;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iMaybeParenExp<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iBlock<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS7((Tuple2)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3),ranges[lo]));
            }
          }
        }
      }
      if (hi-lo>=2 && type[lo]==iAssertTok) {
        final long s1 = slices.get(iExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS8((AExp)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iBlock<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS9((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iJuxts1_Mod<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iOption_Type__List1_VarDecl<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS10((List)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=5) {
        for (int j=lo+4;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iWhileUntil__ParenExp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeDo__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS11((Tuple2)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2 && type[lo]==iIfTok) {
        final long s1 = slices.get(iAfterIfB<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS12((PreIf)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAssign<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS13((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iWhileUntil<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssignNP<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS14((Loc)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1 && type[lo]==iReturnTok) {
        final long s1 = slices.get(iOption_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS15((Option)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      if (1<=hi-lo && hi-lo<=2 && type[lo]==iContinueTok) {
        final long s1 = slices.get(iOption_Ident<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS16((Option)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      if (hi-lo>=6) {
        for (int j=lo+4;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iForTok__Left__ForInfo<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS17((Tuple3)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iStmtHelperBS<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas1_StmtHelperBS(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iStmtHelperBS<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_StmtHelperBS<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas1_StmtHelperBS0((AStmt)values.get((int)(s1>>32)+k1),(CommaList1)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iStmtHelperBS<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas1_StmtHelperBS1((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas1_StmtHelperBS<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas0_StmtHelperBS(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iCommas1_StmtHelperBS<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas0_StmtHelperBS0((CommaList1)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas0_StmtHelperBS<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void StmtHelper(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iStmtHelperBS<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelper0((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=2 && type[lo]==iIfTok) {
        final long s1 = slices.get(iAfterIfA<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelper1((PreIf)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      if (hi-lo>=5) {
        for (int j=lo+2;j<=hi-3;j++) {
          {
            final long s1 = slices.get(iForTok__Left<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iForInfo__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelper2((Tuple2)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2 && type[lo]==iSynchronizedTok) {
        final long s1 = slices.get(iMaybeParenExp<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelper3((Tuple2)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iWhileUntil<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeParenExp__MaybeDo<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelper4((Loc)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3 && type[lo]==iForTok) {
        final long s1 = slices.get(iForInfo<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelper5((ForInfo)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iStmtHelper<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Stmt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2 && type[hi-1]==iSemiTok) {
        final long s1 = slices.get(iStmtHelperBS<<24|lo<<12|hi-1);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Stmt0((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iStmtHelper<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Stmt1((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo==1 && type[lo]==iSemiTok)
        values.add(Stmt2(ranges[lo]));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iStmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeDo__Stmt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1) {
        for (int j=lo;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iMaybeDo<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(MaybeDo__Stmt0((AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeDo__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeThen__Stmt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1) {
        for (int j=lo;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iMaybeThen<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(MaybeThen__Stmt0((AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeThen__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeStmt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iStmt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(MaybeStmt0((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeStmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Stmts(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          if (type[j]==iSemiTok) {
            final long s1 = slices.get(iStmtHelperBS<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmts<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Stmts0((AStmt)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iStmtHelper<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Stmts1((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1 && type[lo]==iSemiTok) {
        final long s1 = slices.get(iStmts<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Stmts2((List)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iStmts<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_ExpAssign(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAssign<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Option_ExpAssign0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_ExpAssign<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas1_ExpCond_ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iExpCond_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_ExpCond_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas1_ExpCond_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(CommaList1)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpCond_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas1_ExpCond_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas1_ExpCond_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_ExpJuxt(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Option_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpUnary_ExpWild(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=4) {
        for (int j=lo+2;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iLParenTok__Type<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight__ExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpWild0((Tuple2)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iPreOp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpWild1((Loc)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpUnary_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iPostOp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpWild2((AExp)values.get((int)(s1>>32)+k1),(Loc)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpWild<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpUnary_ExpWild3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpUnary_ExpWild<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpMul_ExpWild(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iModTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpWild<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpWild0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iDivTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpWild<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpWild1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iMulTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpWild<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpWild2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpUnary_ExpWild<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpMul_ExpWild3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpMul_ExpWild<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAdd_ExpWild(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iMinusTok) {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpMul_ExpWild<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpWild0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iPlusTok) {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpMul_ExpWild<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpWild1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpMul_ExpWild<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAdd_ExpWild2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAdd_ExpWild<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpShift_ExpWild(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=7) {
        for (int j=lo+1;j<=hi-6;j++) {
          if (type[j]==iGtTok && type[j+1]==iUnsignedRShiftSepTok && type[j+2]==iGtTok && type[j+3]==iUnsignedRShiftSepTok && type[j+4]==iGtTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+5<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpWild0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j],ranges[j+4]));
            }
          }
        }
      }
      if (hi-lo>=5) {
        for (int j=lo+1;j<=hi-4;j++) {
          if (type[j]==iGtTok && type[j+1]==iRShiftSepTok && type[j+2]==iGtTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+3<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpWild1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j],ranges[j+2]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLShiftTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpWild2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAdd_ExpWild<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpShift_ExpWild3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpShift_ExpWild<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpRel_ExpWild(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iGtTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpWild0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iInstanceofTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iType<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpWild1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLtTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpWild2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iGeTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpWild3((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLeTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpWild4((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpShift_ExpWild<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpRel_ExpWild5((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpRel_ExpWild<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpEq_ExpWild(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iNeTok) {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpRel_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpWild0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iEqEqTok) {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpRel_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpWild1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpRel_ExpWild<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpEq_ExpWild2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpEq_ExpWild<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAnd_ExpWild(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iAndTok) {
            final long s1 = slices.get(iExpAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpEq_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAnd_ExpWild0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpEq_ExpWild<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAnd_ExpWild1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAnd_ExpWild<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpXor_ExpWild(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iXorTok) {
            final long s1 = slices.get(iExpXor_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAnd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpXor_ExpWild0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAnd_ExpWild<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpXor_ExpWild1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpXor_ExpWild<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOr_ExpWild(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iOrTok) {
            final long s1 = slices.get(iExpOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpXor_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOr_ExpWild0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpXor_ExpWild<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOr_ExpWild1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOr_ExpWild<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAndAnd_ExpWild(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iAndAndTok) {
            final long s1 = slices.get(iExpAndAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpOr_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAndAnd_ExpWild0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpOr_ExpWild<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAndAnd_ExpWild1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAndAnd_ExpWild<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOrOr_ExpWild(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iOrOrTok) {
            final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAndAnd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOrOr_ExpWild0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAndAnd_ExpWild<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOrOr_ExpWild1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOrOr_ExpWild<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpCond_ExpWild(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=5) {
        for (int j=lo+1;j<=hi-4;j++) {
          {
            final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iQuestionTok__ExpAssign__ColonTok__ExpCond_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpCond_ExpWild0((AExp)values.get((int)(s1>>32)+k1),(Tuple4)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpOrOr_ExpWild<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpCond_ExpWild1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpCond_ExpWild<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Type(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iQuestionTok) {
        final long s1 = slices.get(iWildcardBounds<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Type0((Option)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpHigh<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Type1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iType<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas1_Type(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iType<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_Type<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas1_Type0((AExp)values.get((int)(s1>>32)+k1),(CommaList1)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iType<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas1_Type1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas1_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_Type(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iType<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Option_Type0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts0_Mod__Option_Type(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iJuxts0_Mod<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iOption_Type<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts0_Mod__Option_Type0((List)values.get((int)(s1>>32)+k1),(Option)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts0_Mod__Option_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List1_Type(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        final long s1 = slices.get(iJuxts2_Type<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_Type0((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=3) {
        final long s1 = slices.get(iCommas2_Type<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_Type1((CommaList2)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iType<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_Type2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList1_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List_Type(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iList1_Type<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List_Type0((KList)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_Type(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iType<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_Type<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_Type0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iType<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_Type1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpWildNP(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iQuestionTok) {
        final long s1 = slices.get(iWildcardBounds<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpWildNP0((Option)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpHighNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpWildNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpWildNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpJuxtNP(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpWild<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iSingleJuxt1_ExpWildNA<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(KList)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpWildNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpUnary_ExpJuxtNP(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=4) {
        for (int j=lo+2;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iLParenTok__Type<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight__ExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxtNP0((Tuple2)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iPreOp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxtNP1((Loc)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpUnary_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iPostOp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k1),(Loc)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpUnary_ExpJuxtNP3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpUnary_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpMul_ExpJuxtNP(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iModTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxtNP<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iDivTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxtNP<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iMulTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxtNP<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpUnary_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpMul_ExpJuxtNP3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpMul_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAdd_ExpJuxtNP(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iMinusTok) {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpMul_ExpJuxtNP<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iPlusTok) {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpMul_ExpJuxtNP<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpMul_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAdd_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAdd_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpShift_ExpJuxtNP(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=7) {
        for (int j=lo+1;j<=hi-6;j++) {
          if (type[j]==iGtTok && type[j+1]==iUnsignedRShiftSepTok && type[j+2]==iGtTok && type[j+3]==iUnsignedRShiftSepTok && type[j+4]==iGtTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+5<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j],ranges[j+4]));
            }
          }
        }
      }
      if (hi-lo>=5) {
        for (int j=lo+1;j<=hi-4;j++) {
          if (type[j]==iGtTok && type[j+1]==iRShiftSepTok && type[j+2]==iGtTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+3<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j],ranges[j+2]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLShiftTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAdd_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpShift_ExpJuxtNP3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpShift_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpRel_ExpJuxtNP(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iGtTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iInstanceofTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iType<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLtTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iGeTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxtNP3((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLeTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxtNP4((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpShift_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpRel_ExpJuxtNP5((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpRel_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpEq_ExpJuxtNP(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iNeTok) {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpRel_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iEqEqTok) {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpRel_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpRel_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpEq_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpEq_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAnd_ExpJuxtNP(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iAndTok) {
            final long s1 = slices.get(iExpAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpEq_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAnd_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpEq_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAnd_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAnd_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpXor_ExpJuxtNP(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iXorTok) {
            final long s1 = slices.get(iExpXor_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAnd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpXor_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAnd_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpXor_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpXor_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOr_ExpJuxtNP(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iOrTok) {
            final long s1 = slices.get(iExpOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpXor_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOr_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpXor_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOr_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOr_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAndAnd_ExpJuxtNP(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iAndAndTok) {
            final long s1 = slices.get(iExpAndAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpOr_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAndAnd_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpOr_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAndAnd_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAndAnd_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOrOr_ExpJuxtNP(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iOrOrTok) {
            final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAndAnd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOrOr_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAndAnd_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOrOr_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOrOr_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpCond_ExpJuxtNP(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=5) {
        for (int j=lo+1;j<=hi-4;j++) {
          {
            final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iQuestionTok__ExpAssign__ColonTok__ExpCond_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpCond_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(Tuple4)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpOrOr_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpCond_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpCond_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAssignNP(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iAssignOp__ExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAssignNP0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpCond_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAssignNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAssignNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void AfterIfB(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=4) {
        for (int j=lo+1;j<=hi-3;j++) {
          {
            final long s1 = slices.get(iExpAssignNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iThenTok__MaybeStmt__ElseTok__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(AfterIfB0((AExp)values.get((int)(s1>>32)+k1),(Tuple3)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAssignNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(AfterIfB1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=4) {
        for (int j=lo+3;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iParenExp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeThen__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(AfterIfB2((Tuple2)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=5) {
        for (int j=lo+3;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iParenExp__MaybeThen<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeStmt__ElseTok__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(AfterIfB3((Tuple2)values.get((int)(s1>>32)+k1),(Tuple3)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=5) {
        for (int j=lo+3;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iParenExp__MaybeThen<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeStmt__ElifTok__AfterIf<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(AfterIfB4((Tuple2)values.get((int)(s1>>32)+k1),(Tuple3)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpAssignNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iBlock<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(AfterIfB5((AExp)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=4) {
        for (int j=lo+1;j<=hi-3;j++) {
          {
            final long s1 = slices.get(iExpAssignNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iThenTok__MaybeStmt__ElifTok__AfterIf<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(AfterIfB6((AExp)values.get((int)(s1>>32)+k1),(Tuple3)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iThenTok) {
            final long s1 = slices.get(iExpAssignNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(AfterIfB7((AExp)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAssignNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(AfterIfB8((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iAfterIfB<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeParenExp(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        final long s1 = slices.get(iParenExp<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(MaybeParenExp0((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAssignNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(MaybeParenExp1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeParenExp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeParenExp__MaybeDo(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1) {
        for (int j=lo+1;j<=hi;j++) {
          {
            final long s1 = slices.get(iMaybeParenExp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeDo<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(MaybeParenExp__MaybeDo0((Tuple2)values.get((int)(s1>>32)+k1),(Option)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeParenExp__MaybeDo<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void AfterIfA(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3 && type[hi-1]==iElseTok) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iThenTok) {
            final long s1 = slices.get(iExpAssignNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeStmt<<24|j+1<<12|hi-1); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(AfterIfA0((AExp)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3),ranges[hi-1]));
            }
          }
        }
      }
      if (hi-lo>=4) {
        for (int j=lo+3;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iParenExp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeThen__MaybeStmt__ElseTok<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(AfterIfA1((Tuple2)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        for (int j=lo+1;j<=hi;j++) {
          {
            final long s1 = slices.get(iMaybeParenExp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeThen<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(AfterIfA2((Tuple2)values.get((int)(s1>>32)+k1),(Option)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iAfterIfA<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void AfterIf(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iAfterIfB<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(AfterIf0((PreIf)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iAfterIfA<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(AfterIf1((PreIf)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iAfterIf<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpWildNA(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iQuestionTok) {
        final long s1 = slices.get(iWildcardBounds<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpWildNA0((Option)values.get((int)(s1>>32)+k),ranges[lo]));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpHighNA<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpWildNA1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpWildNA<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void SingleJuxt1_ExpWildNA(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        final long s1 = slices.get(iJuxts2_ExpWildNA<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(SingleJuxt1_ExpWildNA0((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpWildNA<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(SingleJuxt1_ExpWildNA1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iSingleJuxt1_ExpWildNA<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_ExpWildNA(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpWildNA<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpWildNA<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_ExpWildNA0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpWildNA<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_ExpWildNA1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_ExpWildNA<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void IdentDims(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLBrackTok) {
            final long s1 = slices.get(iIdentDims<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(IdentDims0((Tuple2)values.get((int)(s1>>32)+k1),(Loc)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo==1) {
        final long s1 = slices.get(iIdent<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(IdentDims1((Loc)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iIdentDims<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void VarDecl(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iEqTok) {
            final long s1 = slices.get(iIdentDims<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpCommas<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(VarDecl0((Tuple2)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iIdentDims<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(VarDecl1((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iVarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_VarDecl(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iVarDecl<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_VarDecl<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_VarDecl0((AVarDecl)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iVarDecl<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_VarDecl1((AVarDecl)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas1_VarDecl(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iVarDecl<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_VarDecl<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas1_VarDecl0((AVarDecl)values.get((int)(s1>>32)+k1),(CommaList1)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iVarDecl<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas1_VarDecl1((AVarDecl)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas1_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForeachSep(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iInTok)
        values.add(ForeachSep0(ranges[lo]));
      if (hi-lo==1 && type[lo]==iColonTok)
        values.add(ForeachSep1(ranges[lo]));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iForeachSep<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void SemiTok__Option_ExpAssign__SemiTok__Commas0_ExpAssignNC(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2 && type[lo]==iSemiTok) {
        for (int j=lo+1;j<=hi-1;j++) {
          if (type[j]==iSemiTok) {
            final long s1 = slices.get(iOption_ExpAssign<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas0_ExpAssignNC<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(SemiTok__Option_ExpAssign__SemiTok__Commas0_ExpAssignNC0((Option)values.get((int)(s1>>32)+k1),(CommaList)values.get((int)(s3>>32)+k3),ranges[lo],ranges[j]));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iSemiTok__Option_ExpAssign__SemiTok__Commas0_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForInfo(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo;j<=hi-3;j++) {
          {
            final long s1 = slices.get(iJuxts0_Mod__Option_Type<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iIdentDims__ForeachSep__ExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ForInfo0((Tuple2)values.get((int)(s1>>32)+k1),(Tuple3)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iCommas0_StmtHelperBS<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iSemiTok__Option_ExpAssign__SemiTok__Commas0_ExpAssignNC<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ForInfo1((CommaList)values.get((int)(s1>>32)+k1),(Tuple4)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iForInfo<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas2_VarDecl(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iVarDecl<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_VarDecl<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas2_VarDecl0((AVarDecl)values.get((int)(s1>>32)+k1),(CommaList1)values.get((int)(s3>>32)+k3),ranges[j]));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas2_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List1_VarDecl(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        final long s1 = slices.get(iJuxts2_VarDecl<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_VarDecl0((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=3) {
        final long s1 = slices.get(iCommas2_VarDecl<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_VarDecl1((CommaList2)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iVarDecl<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_VarDecl2((AVarDecl)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList1_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_Type__List1_VarDecl(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=1) {
        for (int j=lo;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iOption_Type<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iList1_VarDecl<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Option_Type__List1_VarDecl0((Option)values.get((int)(s1>>32)+k1),(KList)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_Type__List1_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void WhileUntil__MaybeParenExp(final int lo, final int hi, final long range) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iWhileUntil<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeParenExp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(WhileUntil__MaybeParenExp0((Loc)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iWhileUntil__MaybeParenExp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
  }
}
