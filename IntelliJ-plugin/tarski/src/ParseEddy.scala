// Autogenerated by ambiguity.  DO NOT EDIT!
package tarski
import tarski.Tokens._
import tarski.AST._

object ParseEddy {
  def parse(input: List[Token]): List[List[AStmt]] = {
    type R = (Int,Int)
    import scala.collection.mutable
    val debug = false
    
    // Functions for matching tokens
    val array = input.toArray
    def tok(i: Int) = array(i)
    def P_PlusEqTok(i: Int) = array(i) match { case t: PlusEqTok => List(t); case _ => Nil }
    def P_OrTok(i: Int) = array(i) match { case t: OrTok => List(t); case _ => Nil }
    def P_SynchronizedTok(i: Int) = array(i) match { case t: SynchronizedTok => List(t); case _ => Nil }
    def P_ModTok(i: Int) = array(i) match { case t: ModTok => List(t); case _ => Nil }
    def P_CommaTok(i: Int) = array(i) match { case t: CommaTok => List(t); case _ => Nil }
    def P_SuperTok(i: Int) = array(i) match { case t: SuperTok => List(t); case _ => Nil }
    def P_CompTok(i: Int) = array(i) match { case t: CompTok => List(t); case _ => Nil }
    def P_AbstractTok(i: Int) = array(i) match { case t: AbstractTok => List(t); case _ => Nil }
    def P_ProtectedTok(i: Int) = array(i) match { case t: ProtectedTok => List(t); case _ => Nil }
    def P_StringLitTok(i: Int) = array(i) match { case t: StringLitTok => List(t); case _ => Nil }
    def P_DotTok(i: Int) = array(i) match { case t: DotTok => List(t); case _ => Nil }
    def P_NotTok(i: Int) = array(i) match { case t: NotTok => List(t); case _ => Nil }
    def P_ColonTok(i: Int) = array(i) match { case t: ColonTok => List(t); case _ => Nil }
    def P_InstanceofTok(i: Int) = array(i) match { case t: InstanceofTok => List(t); case _ => Nil }
    def P_ReturnTok(i: Int) = array(i) match { case t: ReturnTok => List(t); case _ => Nil }
    def P_FinalTok(i: Int) = array(i) match { case t: FinalTok => List(t); case _ => Nil }
    def P_FloatLitTok(i: Int) = array(i) match { case t: FloatLitTok => List(t); case _ => Nil }
    def P_UnsignedRShiftTok(i: Int) = array(i) match { case t: UnsignedRShiftTok => List(t); case _ => Nil }
    def P_LeTok(i: Int) = array(i) match { case t: LeTok => List(t); case _ => Nil }
    def P_IdentTok(i: Int) = array(i) match { case t: IdentTok => List(t); case _ => Nil }
    def P_TransientTok(i: Int) = array(i) match { case t: TransientTok => List(t); case _ => Nil }
    def P_UnsignedRShiftEqTok(i: Int) = array(i) match { case t: UnsignedRShiftEqTok => List(t); case _ => Nil }
    def P_LtTok(i: Int) = array(i) match { case t: LtTok => List(t); case _ => Nil }
    def P_IntLitTok(i: Int) = array(i) match { case t: IntLitTok => List(t); case _ => Nil }
    def P_ColonColonTok(i: Int) = array(i) match { case t: ColonColonTok => List(t); case _ => Nil }
    def P_AndAndTok(i: Int) = array(i) match { case t: AndAndTok => List(t); case _ => Nil }
    def P_RShiftEqTok(i: Int) = array(i) match { case t: RShiftEqTok => List(t); case _ => Nil }
    def P_ContinueTok(i: Int) = array(i) match { case t: ContinueTok => List(t); case _ => Nil }
    def P_VolatileTok(i: Int) = array(i) match { case t: VolatileTok => List(t); case _ => Nil }
    def P_RCurlyTok(i: Int) = array(i) match { case t: RCurlyTok => List(t); case _ => Nil }
    def P_NewTok(i: Int) = array(i) match { case t: NewTok => List(t); case _ => Nil }
    def P_LCurlyTok(i: Int) = array(i) match { case t: LCurlyTok => List(t); case _ => Nil }
    def P_XorEqTok(i: Int) = array(i) match { case t: XorEqTok => List(t); case _ => Nil }
    def P_EqTok(i: Int) = array(i) match { case t: EqTok => List(t); case _ => Nil }
    def P_PrivateTok(i: Int) = array(i) match { case t: PrivateTok => List(t); case _ => Nil }
    def P_BreakTok(i: Int) = array(i) match { case t: BreakTok => List(t); case _ => Nil }
    def P_LParenTok(i: Int) = array(i) match { case t: LParenTok => List(t); case _ => Nil }
    def P_MulTok(i: Int) = array(i) match { case t: MulTok => List(t); case _ => Nil }
    def P_DivTok(i: Int) = array(i) match { case t: DivTok => List(t); case _ => Nil }
    def P_DoubleLitTok(i: Int) = array(i) match { case t: DoubleLitTok => List(t); case _ => Nil }
    def P_PlusPlusTok(i: Int) = array(i) match { case t: PlusPlusTok => List(t); case _ => Nil }
    def P_SemiTok(i: Int) = array(i) match { case t: SemiTok => List(t); case _ => Nil }
    def P_StaticTok(i: Int) = array(i) match { case t: StaticTok => List(t); case _ => Nil }
    def P_LBrackTok(i: Int) = array(i) match { case t: LBrackTok => List(t); case _ => Nil }
    def P_XorTok(i: Int) = array(i) match { case t: XorTok => List(t); case _ => Nil }
    def P_MinusMinusTok(i: Int) = array(i) match { case t: MinusMinusTok => List(t); case _ => Nil }
    def P_RBrackTok(i: Int) = array(i) match { case t: RBrackTok => List(t); case _ => Nil }
    def P_NeTok(i: Int) = array(i) match { case t: NeTok => List(t); case _ => Nil }
    def P_RParenTok(i: Int) = array(i) match { case t: RParenTok => List(t); case _ => Nil }
    def P_AndEqTok(i: Int) = array(i) match { case t: AndEqTok => List(t); case _ => Nil }
    def P_CharLitTok(i: Int) = array(i) match { case t: CharLitTok => List(t); case _ => Nil }
    def P_MinusEqTok(i: Int) = array(i) match { case t: MinusEqTok => List(t); case _ => Nil }
    def P_GtTok(i: Int) = array(i) match { case t: GtTok => List(t); case _ => Nil }
    def P_BoolLitTok(i: Int) = array(i) match { case t: BoolLitTok => List(t); case _ => Nil }
    def P_StrictfpTok(i: Int) = array(i) match { case t: StrictfpTok => List(t); case _ => Nil }
    def P_EqEqTok(i: Int) = array(i) match { case t: EqEqTok => List(t); case _ => Nil }
    def P_ExtendsTok(i: Int) = array(i) match { case t: ExtendsTok => List(t); case _ => Nil }
    def P_GeTok(i: Int) = array(i) match { case t: GeTok => List(t); case _ => Nil }
    def P_ThrowTok(i: Int) = array(i) match { case t: ThrowTok => List(t); case _ => Nil }
    def P_NullLitTok(i: Int) = array(i) match { case t: NullLitTok => List(t); case _ => Nil }
    def P_QuestionTok(i: Int) = array(i) match { case t: QuestionTok => List(t); case _ => Nil }
    def P_AssertTok(i: Int) = array(i) match { case t: AssertTok => List(t); case _ => Nil }
    def P_AndTok(i: Int) = array(i) match { case t: AndTok => List(t); case _ => Nil }
    def P_RShiftTok(i: Int) = array(i) match { case t: RShiftTok => List(t); case _ => Nil }
    def P_OrEqTok(i: Int) = array(i) match { case t: OrEqTok => List(t); case _ => Nil }
    def P_LShiftEqTok(i: Int) = array(i) match { case t: LShiftEqTok => List(t); case _ => Nil }
    def P_LShiftTok(i: Int) = array(i) match { case t: LShiftTok => List(t); case _ => Nil }
    def P_ModEqTok(i: Int) = array(i) match { case t: ModEqTok => List(t); case _ => Nil }
    def P_PlusTok(i: Int) = array(i) match { case t: PlusTok => List(t); case _ => Nil }
    def P_OrOrTok(i: Int) = array(i) match { case t: OrOrTok => List(t); case _ => Nil }
    def P_LongLitTok(i: Int) = array(i) match { case t: LongLitTok => List(t); case _ => Nil }
    def P_AtTok(i: Int) = array(i) match { case t: AtTok => List(t); case _ => Nil }
    def P_MulEqTok(i: Int) = array(i) match { case t: MulEqTok => List(t); case _ => Nil }
    def P_PublicTok(i: Int) = array(i) match { case t: PublicTok => List(t); case _ => Nil }
    def P_MinusTok(i: Int) = array(i) match { case t: MinusTok => List(t); case _ => Nil }
    def P_DivEqTok(i: Int) = array(i) match { case t: DivEqTok => List(t); case _ => Nil }
    
    // Allocate one sparse array per nonterminal
    val P_Commas2_ExpAssignNC = mutable.Map[R,List[List[AExp]]]()
    val P_ExpAssign__ColonTok__ExpBinary = mutable.Map[R,List[(AExp,ColonTok,AExp)]]()
    val P_ExpHigh__LCurlyTok = mutable.Map[R,List[(AExp,LCurlyTok)]]()
    val P_Stmts__RCurlyTok = mutable.Map[R,List[(List[AStmt],RCurlyTok)]]()
    val P_Juxts2_ExpNew__RBrackTok = mutable.Map[R,List[(List[AExp],RBrackTok)]]()
    val P_SemiTok__Stmts = mutable.Map[R,List[(SemiTok,List[AStmt])]]()
    val P_Type__List1_VarDecl = mutable.Map[R,List[(AType,KList[(NameDims,Option[AExp])])]]()
    val P_ColonTok__ExpBinary = mutable.Map[R,List[(ColonTok,AExp)]]()
    val P_List_Type__GtTok = mutable.Map[R,List[(KList[AType],GtTok)]]()
    val P_Juxts2_ExpAssignNC = mutable.Map[R,List[List[AExp]]]()
    val P_ExpBinary__QuestionTok = mutable.Map[R,List[(AExp,QuestionTok)]]()
    val P_AssertTok__ExpJuxt = mutable.Map[R,List[(AssertTok,AExp)]]()
    val P_AssignOp = mutable.Map[R,List[Option[AssignOp]]]()
    val P_ExpJuxt__Block = mutable.Map[R,List[(AExp,List[AStmt])]]()
    val P_WildcardBounds = mutable.Map[R,List[Option[(Bound,AType)]]]()
    val P_PreOp = mutable.Map[R,List[UnaryOp]]()
    val P_Option_IdentTok = mutable.Map[R,List[Option[IdentTok]]]()
    val P_Commas2_ExpBinary__RParenTok = mutable.Map[R,List[(List[AExp],RParenTok)]]()
    val P_Option_TypeArgs__IdentTok = mutable.Map[R,List[(Option[KList[AType]],IdentTok)]]()
    val P_Juxts2_ExpNew = mutable.Map[R,List[List[AExp]]]()
    val P_Juxts2_ExpNew__RCurlyTok = mutable.Map[R,List[(List[AExp],RCurlyTok)]]()
    val P_PostOp = mutable.Map[R,List[UnaryOp]]()
    val P_CommaTok__Commas1_VarDecl = mutable.Map[R,List[(CommaTok,List[(NameDims,Option[AExp])])]]()
    val P_BinaryOp = mutable.Map[R,List[BinaryOp]]()
    val P_ExpHigh__DotTok = mutable.Map[R,List[(AExp,DotTok)]]()
    val P_Commas2_Type = mutable.Map[R,List[List[AType]]]()
    val P_CommaTok__Commas1_Type = mutable.Map[R,List[(CommaTok,List[AType])]]()
    val P_TypeArgs = mutable.Map[R,List[KList[AType]]]()
    val P_Option_TypeArgs = mutable.Map[R,List[Option[KList[AType]]]]()
    val P_Juxts2_VarDecl = mutable.Map[R,List[List[(NameDims,Option[AExp])]]]()
    val P_ExpBinary__RBrackTok = mutable.Map[R,List[(AExp,RBrackTok)]]()
    val P_ColonTok__ExpJuxt = mutable.Map[R,List[(ColonTok,AExp)]]()
    val P_ExpBinary__RCurlyTok = mutable.Map[R,List[(AExp,RCurlyTok)]]()
    val P_ExpHigh__LParenTok = mutable.Map[R,List[(AExp,LParenTok)]]()
    val P_Mod = mutable.Map[R,List[Mod]]()
    val P_Juxts1_Mod = mutable.Map[R,List[List[Mod]]]()
    val P_Juxts0_Mod = mutable.Map[R,List[List[Mod]]]()
    val P_List_ExpAssignNC__RCurlyTok = mutable.Map[R,List[(KList[AExp],RCurlyTok)]]()
    val P_RParenTok__ExpUnary = mutable.Map[R,List[(RParenTok,AExp)]]()
    val P_LBrackTok__RBrackTok = mutable.Map[R,List[(LBrackTok,RBrackTok)]]()
    val P_IdentDims = mutable.Map[R,List[NameDims]]()
    val P_VarDecl = mutable.Map[R,List[(NameDims,Option[AExp])]]()
    val P_Commas1_VarDecl = mutable.Map[R,List[List[(NameDims,Option[AExp])]]]()
    val P_Juxts1_VarDecl = mutable.Map[R,List[List[(NameDims,Option[AExp])]]]()
    val P_EqTok__ExpCommas = mutable.Map[R,List[(EqTok,AExp)]]()
    val P_CommaTok__Commas1_ExpBinary = mutable.Map[R,List[(CommaTok,List[AExp])]]()
    val P_Juxts2_Type = mutable.Map[R,List[List[AType]]]()
    val P_LParenTok__Type = mutable.Map[R,List[(LParenTok,AType)]]()
    val P_CommaTok__Commas1_ExpAssignNC = mutable.Map[R,List[(CommaTok,List[AExp])]]()
    val P_Juxts2_ExpNew__RParenTok = mutable.Map[R,List[(List[AExp],RParenTok)]]()
    val P_List_ExpAssignNC__RParenTok = mutable.Map[R,List[(KList[AExp],RParenTok)]]()
    val P_AssignOp__ExpAssign = mutable.Map[R,List[(Option[AssignOp],AExp)]]()
    val P_Commas2_ExpBinary = mutable.Map[R,List[List[AExp]]]()
    val P_ExpHigh__LBrackTok = mutable.Map[R,List[(AExp,LBrackTok)]]()
    val P_Lit = mutable.Map[R,List[ALit]]()
    val P_ExpHighNA = mutable.Map[R,List[AExp]]()
    val P_ExpNewNA = mutable.Map[R,List[AExp]]()
    val P_Juxts1_ExpNewNA = mutable.Map[R,List[List[AExp]]]()
    val P_ExpHigh = mutable.Map[R,List[AExp]]()
    val P_ExpNew = mutable.Map[R,List[AExp]]()
    val P_ExpJuxt = mutable.Map[R,List[AExp]]()
    val P_Option_ExpJuxt = mutable.Map[R,List[Option[AExp]]]()
    val P_ExpUnary = mutable.Map[R,List[AExp]]()
    val P_ExpBinary = mutable.Map[R,List[AExp]]()
    val P_Commas1_ExpBinary = mutable.Map[R,List[List[AExp]]]()
    val P_ExpCommas = mutable.Map[R,List[AExp]]()
    val P_ExpAssign = mutable.Map[R,List[AExp]]()
    val P_ExpAssignNC = mutable.Map[R,List[AExp]]()
    val P_Juxts1_ExpAssignNC = mutable.Map[R,List[List[AExp]]]()
    val P_Commas1_ExpAssignNC = mutable.Map[R,List[List[AExp]]]()
    val P_List1_ExpAssignNC = mutable.Map[R,List[KList[AExp]]]()
    val P_List_ExpAssignNC = mutable.Map[R,List[KList[AExp]]]()
    val P_Option_TypeArgs__ExpJuxt = mutable.Map[R,List[(Option[KList[AType]],AExp)]]()
    val P_Juxts1_ExpNew = mutable.Map[R,List[List[AExp]]]()
    val P_ExpAssignNC__RParenTok = mutable.Map[R,List[(AExp,RParenTok)]]()
    val P_Block = mutable.Map[R,List[List[AStmt]]]()
    val P_StmtHelper = mutable.Map[R,List[AStmt]]()
    val P_Stmts = mutable.Map[R,List[List[AStmt]]]()
    val P_Commas2_ExpBinary__RBrackTok = mutable.Map[R,List[(List[AExp],RBrackTok)]]()
    val P_DotTok__IdentTok = mutable.Map[R,List[(DotTok,IdentTok)]]()
    val P_BinaryOp__ExpBinary = mutable.Map[R,List[(BinaryOp,AExp)]]()
    val P_ExpHigh__ColonColonTok = mutable.Map[R,List[(AExp,ColonColonTok)]]()
    val P_Commas2_VarDecl = mutable.Map[R,List[List[(NameDims,Option[AExp])]]]()
    val P_List1_VarDecl = mutable.Map[R,List[KList[(NameDims,Option[AExp])]]]()
    val P_Commas2_ExpBinary__RCurlyTok = mutable.Map[R,List[(List[AExp],RCurlyTok)]]()
    val P_List_ExpAssignNC__RBrackTok = mutable.Map[R,List[(KList[AExp],RBrackTok)]]()
    val P_Type = mutable.Map[R,List[AType]]()
    val P_Juxts1_Type = mutable.Map[R,List[List[AType]]]()
    val P_List1_Type = mutable.Map[R,List[KList[AType]]]()
    val P_List_Type = mutable.Map[R,List[KList[AType]]]()
    val P_Commas1_Type = mutable.Map[R,List[List[AType]]]()
    val P_Option_TypeArgs__NewTok = mutable.Map[R,List[(Option[KList[AType]],NewTok)]]()
    
    // Parse bottom up for each nonterminal
    val n = input.length
    // Parse null productions
    for (lo <- 0 to n) {
      P_Commas2_ExpAssignNC((lo,lo)) = List()
      P_ExpAssign__ColonTok__ExpBinary((lo,lo)) = List()
      P_ExpHigh__LCurlyTok((lo,lo)) = List()
      P_Stmts__RCurlyTok((lo,lo)) = List()
      P_Juxts2_ExpNew__RBrackTok((lo,lo)) = List()
      P_SemiTok__Stmts((lo,lo)) = List()
      P_Type__List1_VarDecl((lo,lo)) = List()
      P_ColonTok__ExpBinary((lo,lo)) = List()
      P_List_Type__GtTok((lo,lo)) = List()
      P_Juxts2_ExpAssignNC((lo,lo)) = List()
      P_ExpBinary__QuestionTok((lo,lo)) = List()
      P_AssertTok__ExpJuxt((lo,lo)) = List()
      P_AssignOp((lo,lo)) = List()
      P_ExpJuxt__Block((lo,lo)) = List()
      P_WildcardBounds((lo,lo)) = List(None)
      P_PreOp((lo,lo)) = List()
      P_Option_IdentTok((lo,lo)) = List(None)
      P_Commas2_ExpBinary__RParenTok((lo,lo)) = List()
      P_Option_TypeArgs__IdentTok((lo,lo)) = List()
      P_Juxts2_ExpNew((lo,lo)) = List()
      P_Juxts2_ExpNew__RCurlyTok((lo,lo)) = List()
      P_PostOp((lo,lo)) = List()
      P_CommaTok__Commas1_VarDecl((lo,lo)) = List()
      P_BinaryOp((lo,lo)) = List()
      P_ExpHigh__DotTok((lo,lo)) = List()
      P_Commas2_Type((lo,lo)) = List()
      P_CommaTok__Commas1_Type((lo,lo)) = List()
      P_TypeArgs((lo,lo)) = List()
      P_Option_TypeArgs((lo,lo)) = List(None)
      P_Juxts2_VarDecl((lo,lo)) = List()
      P_ExpBinary__RBrackTok((lo,lo)) = List()
      P_ColonTok__ExpJuxt((lo,lo)) = List()
      P_ExpBinary__RCurlyTok((lo,lo)) = List()
      P_ExpHigh__LParenTok((lo,lo)) = List()
      P_Mod((lo,lo)) = List()
      P_Juxts1_Mod((lo,lo)) = List()
      P_Juxts0_Mod((lo,lo)) = List(Nil)
      P_List_ExpAssignNC__RCurlyTok((lo,lo)) = List()
      P_RParenTok__ExpUnary((lo,lo)) = List()
      P_LBrackTok__RBrackTok((lo,lo)) = List()
      P_IdentDims((lo,lo)) = List()
      P_VarDecl((lo,lo)) = List()
      P_Commas1_VarDecl((lo,lo)) = List()
      P_Juxts1_VarDecl((lo,lo)) = List()
      P_EqTok__ExpCommas((lo,lo)) = List()
      P_CommaTok__Commas1_ExpBinary((lo,lo)) = List()
      P_Juxts2_Type((lo,lo)) = List()
      P_LParenTok__Type((lo,lo)) = List()
      P_CommaTok__Commas1_ExpAssignNC((lo,lo)) = List()
      P_Juxts2_ExpNew__RParenTok((lo,lo)) = List()
      P_List_ExpAssignNC__RParenTok((lo,lo)) = List()
      P_AssignOp__ExpAssign((lo,lo)) = List()
      P_Commas2_ExpBinary((lo,lo)) = List()
      P_ExpHigh__LBrackTok((lo,lo)) = List()
      P_Lit((lo,lo)) = List()
      P_ExpHighNA((lo,lo)) = List()
      P_ExpNewNA((lo,lo)) = List()
      P_Juxts1_ExpNewNA((lo,lo)) = List()
      P_ExpHigh((lo,lo)) = List()
      P_ExpNew((lo,lo)) = List()
      P_ExpJuxt((lo,lo)) = List()
      P_Option_ExpJuxt((lo,lo)) = List(None)
      P_ExpUnary((lo,lo)) = List()
      P_ExpBinary((lo,lo)) = List()
      P_Commas1_ExpBinary((lo,lo)) = List()
      P_ExpCommas((lo,lo)) = List()
      P_ExpAssign((lo,lo)) = List()
      P_ExpAssignNC((lo,lo)) = List()
      P_Juxts1_ExpAssignNC((lo,lo)) = List()
      P_Commas1_ExpAssignNC((lo,lo)) = List()
      P_List1_ExpAssignNC((lo,lo)) = List()
      P_List_ExpAssignNC((lo,lo)) = List(EmptyList)
      P_Option_TypeArgs__ExpJuxt((lo,lo)) = List()
      P_Juxts1_ExpNew((lo,lo)) = List()
      P_ExpAssignNC__RParenTok((lo,lo)) = List()
      P_Block((lo,lo)) = List()
      P_StmtHelper((lo,lo)) = List()
      P_Stmts((lo,lo)) = List(Nil)
      P_Commas2_ExpBinary__RBrackTok((lo,lo)) = List()
      P_DotTok__IdentTok((lo,lo)) = List()
      P_BinaryOp__ExpBinary((lo,lo)) = List()
      P_ExpHigh__ColonColonTok((lo,lo)) = List()
      P_Commas2_VarDecl((lo,lo)) = List()
      P_List1_VarDecl((lo,lo)) = List()
      P_Commas2_ExpBinary__RCurlyTok((lo,lo)) = List()
      P_List_ExpAssignNC__RBrackTok((lo,lo)) = List()
      P_Type((lo,lo)) = List()
      P_Juxts1_Type((lo,lo)) = List()
      P_List1_Type((lo,lo)) = List()
      P_List_Type((lo,lo)) = List(EmptyList)
      P_Commas1_Type((lo,lo)) = List()
      P_Option_TypeArgs__NewTok((lo,lo)) = List()
    }
    // Parse nonnull productions
    for (lo <- n to 0 by -1; hi <- lo+1 to n) {
      if (debug) println("\nparsing: "+array.slice(lo,hi).mkString(" "))
      def d[A](non: String, p: mutable.Map[R,List[A]]) = if (debug) {
        val c = p((lo,hi)); val n = c.size
        if (n>0) println(s"  $non $n = "+c.mkString(" "))
      }
      def t[A,C](p: Int => List[A])(f: A => C) = if (lo+1==hi) p(lo).map(f) else Nil
      def n[A,C](p: R   => List[A])(f: A => C) = p(lo,hi).map(f)
      def s[A,C](p: R   => List[A])(f: A => C) = if (lo<hi) p(lo,hi).map(f) else Nil
      def tt[A,B,C](pa: Int => List[A], pb: Int => List[B])(f: (A,B) => C) = if (lo+2==hi) for (a <- pa(lo); b <- pb(lo+1)) yield f(a,b) else Nil
      def tn[A,B,C](pa: Int => List[A], pb: R   => List[B])(f: (A,B) => C) = if (lo<hi) for (a <- pa(lo); b <- pb((lo+1,hi))) yield f(a,b) else Nil
      def ts[A,B,C](pa: Int => List[A], pb: R   => List[B])(f: (A,B) => C) = if (lo+1<hi) for (a <- pa(lo); b <- pb((lo+1,hi))) yield f(a,b) else Nil
      def nt[A,B,C](pa: R   => List[A], pb: Int => List[B])(f: (A,B) => C) = if (lo<hi) for (b <- pb(hi-1); a <- pa((lo,hi-1))) yield f(a,b) else Nil
      def st[A,B,C](pa: R   => List[A], pb: Int => List[B])(f: (A,B) => C) = if (lo+1<hi) for (b <- pb(hi-1); a <- pa((lo,hi-1))) yield f(a,b) else Nil
      def nn[A,B,C](pa: R   => List[A], pb: R   => List[B])(f: (A,B) => C) = (for (m <- lo to hi; a <- pa((lo,m)); b <- pb((m,hi))) yield f(a,b)).toList
      def sn[A,B,C](pa: R   => List[A], pb: R   => List[B])(f: (A,B) => C) = (for (m <- lo+1 to hi; a <- pa((lo,m)); b <- pb((m,hi))) yield f(a,b)).toList
      def ns[A,B,C](pa: R   => List[A], pb: R   => List[B])(f: (A,B) => C) = (for (m <- lo to hi-1; a <- pa((lo,m)); b <- pb((m,hi))) yield f(a,b)).toList
      def ss[A,B,C](pa: R   => List[A], pb: R   => List[B])(f: (A,B) => C) = (for (m <- lo+1 to hi-1; a <- pa((lo,m)); b <- pb((m,hi))) yield f(a,b)).toList
      P_Commas2_ExpAssignNC((lo,hi)) = ss(P_ExpAssignNC,P_CommaTok__Commas1_ExpAssignNC)((x,y) => x :: y._2); d("Commas2_ExpAssignNC",P_Commas2_ExpAssignNC)
      P_ExpAssign__ColonTok__ExpBinary((lo,hi)) = ss(P_ExpAssign,P_ColonTok__ExpBinary)((x,y) => (x,y._1,y._2)); d("ExpAssign__ColonTok__ExpBinary",P_ExpAssign__ColonTok__ExpBinary)
      P_ExpHigh__LCurlyTok((lo,hi)) = st(P_ExpHigh,P_LCurlyTok)((x,y) => (x,y)); d("ExpHigh__LCurlyTok",P_ExpHigh__LCurlyTok)
      P_Stmts__RCurlyTok((lo,hi)) = nt(P_Stmts,P_RCurlyTok)((x,y) => (x,y)); d("Stmts__RCurlyTok",P_Stmts__RCurlyTok)
      P_Juxts2_ExpNew__RBrackTok((lo,hi)) = st(P_Juxts2_ExpNew,P_RBrackTok)((x,y) => (x,y)); d("Juxts2_ExpNew__RBrackTok",P_Juxts2_ExpNew__RBrackTok)
      P_SemiTok__Stmts((lo,hi)) = tn(P_SemiTok,P_Stmts)((x,y) => (x,y)); d("SemiTok__Stmts",P_SemiTok__Stmts)
      P_Type__List1_VarDecl((lo,hi)) = ss(P_Type,P_List1_VarDecl)((x,y) => (x,y)); d("Type__List1_VarDecl",P_Type__List1_VarDecl)
      P_ColonTok__ExpBinary((lo,hi)) = ts(P_ColonTok,P_ExpBinary)((x,y) => (x,y)); d("ColonTok__ExpBinary",P_ColonTok__ExpBinary)
      P_List_Type__GtTok((lo,hi)) = nt(P_List_Type,P_GtTok)((x,y) => (x,y)); d("List_Type__GtTok",P_List_Type__GtTok)
      P_Juxts2_ExpAssignNC((lo,hi)) = ss(P_ExpAssignNC,P_Juxts1_ExpAssignNC)((x,y) => x :: y); d("Juxts2_ExpAssignNC",P_Juxts2_ExpAssignNC)
      P_ExpBinary__QuestionTok((lo,hi)) = st(P_ExpBinary,P_QuestionTok)((x,y) => (x,y)); d("ExpBinary__QuestionTok",P_ExpBinary__QuestionTok)
      P_AssertTok__ExpJuxt((lo,hi)) = ts(P_AssertTok,P_ExpJuxt)((x,y) => (x,y)); d("AssertTok__ExpJuxt",P_AssertTok__ExpJuxt)
      P_AssignOp((lo,hi)) = t(P_PlusEqTok)(x => Some(AddOp())) ::: t(P_RShiftEqTok)(x => Some(RShiftOp())) ::: t(P_EqTok)(x => None) ::: t(P_AndEqTok)(x => Some(AndOp())) ::: t(P_XorEqTok)(x => Some(XorOp())) ::: t(P_ModEqTok)(x => Some(ModOp())) ::: t(P_LShiftEqTok)(x => Some(LShiftOp())) ::: t(P_UnsignedRShiftEqTok)(x => Some(UnsignedRShiftOp())) ::: t(P_MulEqTok)(x => Some(MulOp())) ::: t(P_DivEqTok)(x => Some(DivOp())) ::: t(P_OrEqTok)(x => Some(OrOp())) ::: t(P_MinusEqTok)(x => Some(SubOp())); d("AssignOp",P_AssignOp)
      P_ExpJuxt__Block((lo,hi)) = ss(P_ExpJuxt,P_Block)((x,y) => (x,y)); d("ExpJuxt__Block",P_ExpJuxt__Block)
      P_WildcardBounds((lo,hi)) = ts(P_ExtendsTok,P_Type)((x,y) => Some((Extends(),y))) ::: ts(P_ColonTok,P_Type)((x,y) => Some((Extends(),y))) ::: ts(P_SuperTok,P_Type)((x,y) => Some((Super(),y))); d("WildcardBounds",P_WildcardBounds)
      P_PreOp((lo,hi)) = t(P_NotTok)(x => NotOp()) ::: t(P_MinusMinusTok)(x => PreDecOp()) ::: t(P_CompTok)(x => CompOp()) ::: t(P_MinusTok)(x => NegOp()) ::: t(P_PlusTok)(x => PosOp()) ::: t(P_PlusPlusTok)(x => PreIncOp()); d("PreOp",P_PreOp)
      P_Option_IdentTok((lo,hi)) = t(P_IdentTok)(x => Some(x)); d("Option_IdentTok",P_Option_IdentTok)
      P_Commas2_ExpBinary__RParenTok((lo,hi)) = st(P_Commas2_ExpBinary,P_RParenTok)((x,y) => (x,y)); d("Commas2_ExpBinary__RParenTok",P_Commas2_ExpBinary__RParenTok)
      P_Option_TypeArgs__IdentTok((lo,hi)) = nt(P_Option_TypeArgs,P_IdentTok)((x,y) => (x,y)); d("Option_TypeArgs__IdentTok",P_Option_TypeArgs__IdentTok)
      P_Juxts2_ExpNew((lo,hi)) = ss(P_ExpNew,P_Juxts1_ExpNew)((x,y) => x :: y); d("Juxts2_ExpNew",P_Juxts2_ExpNew)
      P_Juxts2_ExpNew__RCurlyTok((lo,hi)) = st(P_Juxts2_ExpNew,P_RCurlyTok)((x,y) => (x,y)); d("Juxts2_ExpNew__RCurlyTok",P_Juxts2_ExpNew__RCurlyTok)
      P_PostOp((lo,hi)) = t(P_PlusPlusTok)(x => PostIncOp()) ::: t(P_MinusMinusTok)(x => PostDecOp()); d("PostOp",P_PostOp)
      P_CommaTok__Commas1_VarDecl((lo,hi)) = ts(P_CommaTok,P_Commas1_VarDecl)((x,y) => (x,y)); d("CommaTok__Commas1_VarDecl",P_CommaTok__Commas1_VarDecl)
      P_BinaryOp((lo,hi)) = t(P_EqEqTok)(x => EqOp()) ::: t(P_AndTok)(x => AndOp()) ::: t(P_XorTok)(x => XorOp()) ::: t(P_ModTok)(x => ModOp()) ::: t(P_AndAndTok)(x => AndAndOp()) ::: t(P_UnsignedRShiftTok)(x => UnsignedRShiftOp()) ::: t(P_LeTok)(x => LeOp()) ::: t(P_InstanceofTok)(x => InstanceofOp()) ::: t(P_OrTok)(x => OrOp()) ::: t(P_GtTok)(x => GtOp()) ::: t(P_LShiftTok)(x => LShiftOp()) ::: t(P_PlusTok)(x => AddOp()) ::: t(P_LtTok)(x => LtOp()) ::: t(P_DivTok)(x => DivOp()) ::: t(P_RShiftTok)(x => RShiftOp()) ::: t(P_MinusTok)(x => SubOp()) ::: t(P_OrOrTok)(x => OrOrOp()) ::: t(P_GeTok)(x => GeOp()) ::: t(P_MulTok)(x => MulOp()) ::: t(P_NeTok)(x => NeOp()); d("BinaryOp",P_BinaryOp)
      P_ExpHigh__DotTok((lo,hi)) = st(P_ExpHigh,P_DotTok)((x,y) => (x,y)); d("ExpHigh__DotTok",P_ExpHigh__DotTok)
      P_Commas2_Type((lo,hi)) = ss(P_Type,P_CommaTok__Commas1_Type)((x,y) => x :: y._2); d("Commas2_Type",P_Commas2_Type)
      P_CommaTok__Commas1_Type((lo,hi)) = ts(P_CommaTok,P_Commas1_Type)((x,y) => (x,y)); d("CommaTok__Commas1_Type",P_CommaTok__Commas1_Type)
      P_TypeArgs((lo,hi)) = ts(P_LtTok,P_List_Type__GtTok)((x,y) => y._1); d("TypeArgs",P_TypeArgs)
      P_Option_TypeArgs((lo,hi)) = s(P_TypeArgs)(x => Some(x)); d("Option_TypeArgs",P_Option_TypeArgs)
      P_Juxts2_VarDecl((lo,hi)) = ss(P_VarDecl,P_Juxts1_VarDecl)((x,y) => x :: y); d("Juxts2_VarDecl",P_Juxts2_VarDecl)
      P_ExpBinary__RBrackTok((lo,hi)) = st(P_ExpBinary,P_RBrackTok)((x,y) => (x,y)); d("ExpBinary__RBrackTok",P_ExpBinary__RBrackTok)
      P_ColonTok__ExpJuxt((lo,hi)) = ts(P_ColonTok,P_ExpJuxt)((x,y) => (x,y)); d("ColonTok__ExpJuxt",P_ColonTok__ExpJuxt)
      P_ExpBinary__RCurlyTok((lo,hi)) = st(P_ExpBinary,P_RCurlyTok)((x,y) => (x,y)); d("ExpBinary__RCurlyTok",P_ExpBinary__RCurlyTok)
      P_ExpHigh__LParenTok((lo,hi)) = st(P_ExpHigh,P_LParenTok)((x,y) => (x,y)); d("ExpHigh__LParenTok",P_ExpHigh__LParenTok)
      P_Mod((lo,hi)) = t(P_AbstractTok)(x => Abstract()) ::: t(P_ProtectedTok)(x => Protected()) ::: t(P_StrictfpTok)(x => Strictfp()) ::: t(P_PublicTok)(x => Public()) ::: tt(P_AtTok,P_IdentTok)((x,y) => Annotation(y.name)) ::: t(P_SynchronizedTok)(x => Synchronized()) ::: t(P_VolatileTok)(x => Volatile()) ::: t(P_TransientTok)(x => Transient()) ::: t(P_FinalTok)(x => Final()) ::: t(P_PrivateTok)(x => Private()) ::: t(P_StaticTok)(x => Static()); d("Mod",P_Mod)
      P_Juxts1_Mod((lo,hi)) = s(P_Mod)(x => List(x)) ::: ss(P_Mod,P_Juxts1_Mod)((x,y) => x :: y); d("Juxts1_Mod",P_Juxts1_Mod)
      P_Juxts0_Mod((lo,hi)) = s(P_Juxts1_Mod)(x => x); d("Juxts0_Mod",P_Juxts0_Mod)
      P_List_ExpAssignNC__RCurlyTok((lo,hi)) = nt(P_List_ExpAssignNC,P_RCurlyTok)((x,y) => (x,y)); d("List_ExpAssignNC__RCurlyTok",P_List_ExpAssignNC__RCurlyTok)
      P_RParenTok__ExpUnary((lo,hi)) = ts(P_RParenTok,P_ExpUnary)((x,y) => (x,y)); d("RParenTok__ExpUnary",P_RParenTok__ExpUnary)
      P_LBrackTok__RBrackTok((lo,hi)) = tt(P_LBrackTok,P_RBrackTok)((x,y) => (x,y)); d("LBrackTok__RBrackTok",P_LBrackTok__RBrackTok)
      P_IdentDims((lo,hi)) = t(P_IdentTok)(x => (x.name,0)) ::: ss(P_IdentDims,P_LBrackTok__RBrackTok)((x,y) => (x._1,x._2+1)); d("IdentDims",P_IdentDims)
      P_VarDecl((lo,hi)) = s(P_IdentDims)(x => (x,None)) ::: ss(P_IdentDims,P_EqTok__ExpCommas)((x,y) => (x,Some(y._2))); d("VarDecl",P_VarDecl)
      P_Commas1_VarDecl((lo,hi)) = s(P_VarDecl)(x => List(x)) ::: ss(P_VarDecl,P_CommaTok__Commas1_VarDecl)((x,y) => x :: y._2); d("Commas1_VarDecl",P_Commas1_VarDecl)
      P_Juxts1_VarDecl((lo,hi)) = s(P_VarDecl)(x => List(x)) ::: ss(P_VarDecl,P_Juxts1_VarDecl)((x,y) => x :: y); d("Juxts1_VarDecl",P_Juxts1_VarDecl)
      P_EqTok__ExpCommas((lo,hi)) = ts(P_EqTok,P_ExpCommas)((x,y) => (x,y)); d("EqTok__ExpCommas",P_EqTok__ExpCommas)
      P_CommaTok__Commas1_ExpBinary((lo,hi)) = ts(P_CommaTok,P_Commas1_ExpBinary)((x,y) => (x,y)); d("CommaTok__Commas1_ExpBinary",P_CommaTok__Commas1_ExpBinary)
      P_Juxts2_Type((lo,hi)) = ss(P_Type,P_Juxts1_Type)((x,y) => x :: y); d("Juxts2_Type",P_Juxts2_Type)
      P_LParenTok__Type((lo,hi)) = ts(P_LParenTok,P_Type)((x,y) => (x,y)); d("LParenTok__Type",P_LParenTok__Type)
      P_CommaTok__Commas1_ExpAssignNC((lo,hi)) = ts(P_CommaTok,P_Commas1_ExpAssignNC)((x,y) => (x,y)); d("CommaTok__Commas1_ExpAssignNC",P_CommaTok__Commas1_ExpAssignNC)
      P_Juxts2_ExpNew__RParenTok((lo,hi)) = st(P_Juxts2_ExpNew,P_RParenTok)((x,y) => (x,y)); d("Juxts2_ExpNew__RParenTok",P_Juxts2_ExpNew__RParenTok)
      P_List_ExpAssignNC__RParenTok((lo,hi)) = nt(P_List_ExpAssignNC,P_RParenTok)((x,y) => (x,y)); d("List_ExpAssignNC__RParenTok",P_List_ExpAssignNC__RParenTok)
      P_AssignOp__ExpAssign((lo,hi)) = ss(P_AssignOp,P_ExpAssign)((x,y) => (x,y)); d("AssignOp__ExpAssign",P_AssignOp__ExpAssign)
      P_Commas2_ExpBinary((lo,hi)) = ss(P_ExpBinary,P_CommaTok__Commas1_ExpBinary)((x,y) => x :: y._2); d("Commas2_ExpBinary",P_Commas2_ExpBinary)
      P_ExpHigh__LBrackTok((lo,hi)) = st(P_ExpHigh,P_LBrackTok)((x,y) => (x,y)); d("ExpHigh__LBrackTok",P_ExpHigh__LBrackTok)
      P_Lit((lo,hi)) = t(P_StringLitTok)(x => StringALit(x.v)) ::: t(P_DoubleLitTok)(x => DoubleALit(x.v)) ::: t(P_CharLitTok)(x => CharALit(x.v)) ::: t(P_NullLitTok)(x => NullALit()) ::: t(P_LongLitTok)(x => LongALit(x.v)) ::: t(P_FloatLitTok)(x => FloatALit(x.v)) ::: t(P_BoolLitTok)(x => BoolALit(x.v)) ::: t(P_IntLitTok)(x => IntALit(x.v)); d("Lit",P_Lit)
      P_ExpHighNA((lo,hi)) = ss(P_ExpHigh__LBrackTok,P_List_ExpAssignNC__RBrackTok)((x,y) => ApplyAExp(x._1,y._1,BrackAround)) ::: ss(P_ExpHigh,P_TypeArgs)((x,y) => TypeApplyAExp(x,y)) ::: ss(P_ExpHigh__ColonColonTok,P_Option_TypeArgs__NewTok)((x,y) => NewRefAExp(x._1,y._1)) ::: s(P_Lit)(x => x) ::: t(P_IdentTok)(x => NameAExp(x.name)) ::: ss(P_ExpHigh__DotTok,P_Option_TypeArgs__IdentTok)((x,y) => FieldAExp(x._1,y._1,y._2.name)) ::: ss(P_ExpHigh__LParenTok,P_List_ExpAssignNC__RParenTok)((x,y) => ApplyAExp(x._1,y._1,ParenAround)) ::: ss(P_ExpHigh__LCurlyTok,P_List_ExpAssignNC__RCurlyTok)((x,y) => ApplyAExp(x._1,y._1,CurlyAround)) ::: ss(P_ExpHigh__ColonColonTok,P_Option_TypeArgs__IdentTok)((x,y) => MethodRefAExp(x._1,y._1,y._2.name)); d("ExpHighNA",P_ExpHighNA)
      P_ExpNewNA((lo,hi)) = s(P_ExpHighNA)(x => x) ::: ts(P_NewTok,P_Option_TypeArgs__ExpJuxt)((x,y) => NewAExp(y._1,y._2)) ::: tn(P_QuestionTok,P_WildcardBounds)((x,y) => WildAExp(y)); d("ExpNewNA",P_ExpNewNA)
      P_Juxts1_ExpNewNA((lo,hi)) = s(P_ExpNewNA)(x => List(x)) ::: ss(P_ExpNewNA,P_Juxts1_ExpNewNA)((x,y) => x :: y); d("Juxts1_ExpNewNA",P_Juxts1_ExpNewNA)
      P_ExpHigh((lo,hi)) = ts(P_LBrackTok,P_ExpBinary__RBrackTok)((x,y) => ArrayAExp(SingleList(y._1),BrackAround)) ::: tt(P_LBrackTok,P_RBrackTok)((x,y) => ArrayAExp(EmptyList, BrackAround)) ::: ts(P_LCurlyTok,P_Juxts2_ExpNew__RCurlyTok)((x,y) => ArrayAExp(JuxtList(y._1), CurlyAround)) ::: ts(P_LParenTok,P_Commas2_ExpBinary__RParenTok)((x,y) => ArrayAExp(CommaList(y._1), ParenAround)) ::: tt(P_LParenTok,P_RParenTok)((x,y) => ArrayAExp(EmptyList, ParenAround)) ::: ts(P_LCurlyTok,P_Commas2_ExpBinary__RCurlyTok)((x,y) => ArrayAExp(CommaList(y._1), CurlyAround)) ::: ts(P_LParenTok,P_Juxts2_ExpNew__RParenTok)((x,y) => ArrayAExp(JuxtList(y._1), ParenAround)) ::: ts(P_LParenTok,P_ExpAssignNC__RParenTok)((x,y) => ParenAExp(y._1)) ::: ts(P_LBrackTok,P_Juxts2_ExpNew__RBrackTok)((x,y) => ArrayAExp(JuxtList(y._1), BrackAround)) ::: ts(P_LCurlyTok,P_ExpBinary__RCurlyTok)((x,y) => ArrayAExp(SingleList(y._1),CurlyAround)) ::: tt(P_LCurlyTok,P_RCurlyTok)((x,y) => ArrayAExp(EmptyList, CurlyAround)) ::: ts(P_LBrackTok,P_Commas2_ExpBinary__RBrackTok)((x,y) => ArrayAExp(CommaList(y._1), BrackAround)) ::: s(P_ExpHighNA)(x => x); d("ExpHigh",P_ExpHigh)
      P_ExpNew((lo,hi)) = s(P_ExpHigh)(x => x) ::: ts(P_NewTok,P_Option_TypeArgs__ExpJuxt)((x,y) => NewAExp(y._1,y._2)) ::: tn(P_QuestionTok,P_WildcardBounds)((x,y) => WildAExp(y)); d("ExpNew",P_ExpNew)
      P_ExpJuxt((lo,hi)) = s(P_ExpNew)(x => x) ::: ss(P_ExpNew,P_Juxts1_ExpNewNA)((x,y) => ApplyAExp(x,JuxtList(y),NoAround)); d("ExpJuxt",P_ExpJuxt)
      P_Option_ExpJuxt((lo,hi)) = s(P_ExpJuxt)(x => Some(x)); d("Option_ExpJuxt",P_Option_ExpJuxt)
      P_ExpUnary((lo,hi)) = s(P_ExpJuxt)(x => x) ::: ss(P_ExpUnary,P_PostOp)((x,y) => UnaryAExp(y,x)) ::: ss(P_PreOp,P_ExpUnary)((x,y) => UnaryAExp(x,y)) ::: ss(P_LParenTok__Type,P_RParenTok__ExpUnary)((x,y) => CastAExp(x._2,y._2)); d("ExpUnary",P_ExpUnary)
      P_ExpBinary((lo,hi)) = s(P_ExpUnary)(x => x) ::: ss(P_ExpBinary,P_BinaryOp__ExpBinary)((x,y) => BinaryAExp(y._1,x,y._2)) ::: ss(P_ExpBinary__QuestionTok,P_ExpAssign__ColonTok__ExpBinary)((x,y) => CondAExp(x._1,y._1,y._3)); d("ExpBinary",P_ExpBinary)
      P_Commas1_ExpBinary((lo,hi)) = s(P_ExpBinary)(x => List(x)) ::: ss(P_ExpBinary,P_CommaTok__Commas1_ExpBinary)((x,y) => x :: y._2); d("Commas1_ExpBinary",P_Commas1_ExpBinary)
      P_ExpCommas((lo,hi)) = s(P_ExpBinary)(x => x) ::: s(P_Commas2_ExpBinary)(x => ArrayAExp(CommaList(x),NoAround)); d("ExpCommas",P_ExpCommas)
      P_ExpAssign((lo,hi)) = s(P_ExpCommas)(x => x) ::: ss(P_ExpJuxt,P_AssignOp__ExpAssign)((x,y) => AssignAExp(y._1,x,y._2)); d("ExpAssign",P_ExpAssign)
      P_ExpAssignNC((lo,hi)) = s(P_ExpBinary)(x => x) ::: ss(P_ExpJuxt,P_AssignOp__ExpAssign)((x,y) => AssignAExp(y._1,x,y._2)); d("ExpAssignNC",P_ExpAssignNC)
      P_Juxts1_ExpAssignNC((lo,hi)) = s(P_ExpAssignNC)(x => List(x)) ::: ss(P_ExpAssignNC,P_Juxts1_ExpAssignNC)((x,y) => x :: y); d("Juxts1_ExpAssignNC",P_Juxts1_ExpAssignNC)
      P_Commas1_ExpAssignNC((lo,hi)) = s(P_ExpAssignNC)(x => List(x)) ::: ss(P_ExpAssignNC,P_CommaTok__Commas1_ExpAssignNC)((x,y) => x :: y._2); d("Commas1_ExpAssignNC",P_Commas1_ExpAssignNC)
      P_List1_ExpAssignNC((lo,hi)) = s(P_ExpAssignNC)(x => SingleList(x)) ::: s(P_Commas2_ExpAssignNC)(x => CommaList(x)) ::: s(P_Juxts2_ExpAssignNC)(x => JuxtList(x)); d("List1_ExpAssignNC",P_List1_ExpAssignNC)
      P_List_ExpAssignNC((lo,hi)) = s(P_List1_ExpAssignNC)(x => x); d("List_ExpAssignNC",P_List_ExpAssignNC)
      P_Option_TypeArgs__ExpJuxt((lo,hi)) = ns(P_Option_TypeArgs,P_ExpJuxt)((x,y) => (x,y)); d("Option_TypeArgs__ExpJuxt",P_Option_TypeArgs__ExpJuxt)
      P_Juxts1_ExpNew((lo,hi)) = s(P_ExpNew)(x => List(x)) ::: ss(P_ExpNew,P_Juxts1_ExpNew)((x,y) => x :: y); d("Juxts1_ExpNew",P_Juxts1_ExpNew)
      P_ExpAssignNC__RParenTok((lo,hi)) = st(P_ExpAssignNC,P_RParenTok)((x,y) => (x,y)); d("ExpAssignNC__RParenTok",P_ExpAssignNC__RParenTok)
      P_Block((lo,hi)) = ts(P_LCurlyTok,P_Stmts__RCurlyTok)((x,y) => y._1); d("Block",P_Block)
      P_StmtHelper((lo,hi)) = ts(P_SynchronizedTok,P_ExpJuxt__Block)((x,y) => SyncAStmt(y._1,y._2)) ::: ts(P_ThrowTok,P_ExpJuxt)((x,y) => ThrowAStmt(y)) ::: ns(P_Juxts0_Mod,P_Type__List1_VarDecl)((x,y) => VarAStmt(x,y._1,y._2)) ::: ts(P_AssertTok,P_ExpJuxt)((x,y) => AssertAStmt(y,None)) ::: s(P_ExpAssign)(x => ExpAStmt(x)) ::: tn(P_ReturnTok,P_Option_ExpJuxt)((x,y) => ReturnAStmt(y)) ::: tn(P_ContinueTok,P_Option_IdentTok)((x,y) => ContinueAStmt(y.map(_.name))) ::: ss(P_AssertTok__ExpJuxt,P_ColonTok__ExpJuxt)((x,y) => AssertAStmt(x._2,Some(y._2))) ::: tn(P_BreakTok,P_Option_IdentTok)((x,y) => BreakAStmt(y.map(_.name))) ::: s(P_Block)(x => BlockAStmt(x)); d("StmtHelper",P_StmtHelper)
      P_Stmts((lo,hi)) = s(P_StmtHelper)(x => List(x)) ::: ss(P_StmtHelper,P_SemiTok__Stmts)((x,y) => x :: y._2); d("Stmts",P_Stmts)
      P_Commas2_ExpBinary__RBrackTok((lo,hi)) = st(P_Commas2_ExpBinary,P_RBrackTok)((x,y) => (x,y)); d("Commas2_ExpBinary__RBrackTok",P_Commas2_ExpBinary__RBrackTok)
      P_DotTok__IdentTok((lo,hi)) = tt(P_DotTok,P_IdentTok)((x,y) => (x,y)); d("DotTok__IdentTok",P_DotTok__IdentTok)
      P_BinaryOp__ExpBinary((lo,hi)) = ss(P_BinaryOp,P_ExpBinary)((x,y) => (x,y)); d("BinaryOp__ExpBinary",P_BinaryOp__ExpBinary)
      P_ExpHigh__ColonColonTok((lo,hi)) = st(P_ExpHigh,P_ColonColonTok)((x,y) => (x,y)); d("ExpHigh__ColonColonTok",P_ExpHigh__ColonColonTok)
      P_Commas2_VarDecl((lo,hi)) = ss(P_VarDecl,P_CommaTok__Commas1_VarDecl)((x,y) => x :: y._2); d("Commas2_VarDecl",P_Commas2_VarDecl)
      P_List1_VarDecl((lo,hi)) = s(P_VarDecl)(x => SingleList(x)) ::: s(P_Commas2_VarDecl)(x => CommaList(x)) ::: s(P_Juxts2_VarDecl)(x => JuxtList(x)); d("List1_VarDecl",P_List1_VarDecl)
      P_Commas2_ExpBinary__RCurlyTok((lo,hi)) = st(P_Commas2_ExpBinary,P_RCurlyTok)((x,y) => (x,y)); d("Commas2_ExpBinary__RCurlyTok",P_Commas2_ExpBinary__RCurlyTok)
      P_List_ExpAssignNC__RBrackTok((lo,hi)) = nt(P_List_ExpAssignNC,P_RBrackTok)((x,y) => (x,y)); d("List_ExpAssignNC__RBrackTok",P_List_ExpAssignNC__RBrackTok)
      P_Type((lo,hi)) = tn(P_QuestionTok,P_WildcardBounds)((x,y) => WildAType(y)) ::: ss(P_Type,P_DotTok__IdentTok)((x,y) => FieldAType(x,y._2.name)) ::: t(P_IdentTok)(x => NameAType(x.name)) ::: ss(P_Type,P_TypeArgs)((x,y) => ApplyAType(x,y)) ::: ss(P_Type,P_LBrackTok__RBrackTok)((x,y) => ArrayAType(x)) ::: ss(P_Mod,P_Type)((x,y) => ModAType(x,y)); d("Type",P_Type)
      P_Juxts1_Type((lo,hi)) = s(P_Type)(x => List(x)) ::: ss(P_Type,P_Juxts1_Type)((x,y) => x :: y); d("Juxts1_Type",P_Juxts1_Type)
      P_List1_Type((lo,hi)) = s(P_Type)(x => SingleList(x)) ::: s(P_Commas2_Type)(x => CommaList(x)) ::: s(P_Juxts2_Type)(x => JuxtList(x)); d("List1_Type",P_List1_Type)
      P_List_Type((lo,hi)) = s(P_List1_Type)(x => x); d("List_Type",P_List_Type)
      P_Commas1_Type((lo,hi)) = s(P_Type)(x => List(x)) ::: ss(P_Type,P_CommaTok__Commas1_Type)((x,y) => x :: y._2); d("Commas1_Type",P_Commas1_Type)
      P_Option_TypeArgs__NewTok((lo,hi)) = nt(P_Option_TypeArgs,P_NewTok)((x,y) => (x,y)); d("Option_TypeArgs__NewTok",P_Option_TypeArgs__NewTok)
    }
    
    // All done!
    P_Stmts((0,n))
  }
}
