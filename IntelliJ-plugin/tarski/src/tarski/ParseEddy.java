// Autogenerated by ambiguity: DO NOT EDIT!
package tarski;
import tarski.Tokens.*;
import tarski.AST.*;
import tarski.Types.*;
import tarski.Operators.*;
import scala.collection.immutable.*;
import gnu.trove.TIntLongHashMap;
import java.util.ArrayList;
import scala.*;
import static tarski.ParseEddyActions.*;

class ParseEddy {
  // Parse a token stream
  public static List<List<AStmt>> parse(List<Token> input) {
    return new Parser(input).toplevel();
  }
  
  private static final class Parser {
    private final int n;
    private final Token[] input;
    private final byte[] type;
    private final ArrayList<Object> values = new ArrayList<Object>();
    private final TIntLongHashMap slices = new TIntLongHashMap(); // (non,lo,hi) => (start,size)
    private final static long vMask = (1L<<32)-1;
    
    // Convert input and allocate working memory
    Parser(List<Token> _input) {
      n = _input.size();
      assert n+1<(1<<12);
      input = new Token[n];
      for (int i=0;i<n;i++) {
        input[i] = _input.head();
        _input = (List<Token>)_input.tail();
      }
      type = new byte[n];
    }
    
    // The entire parse
    List<List<AStmt>> toplevel() {
      // Parse
      types();
      nulls();
      nonnulls();
      
      // All done!
      final long s = slices.get(iStmts<<24|n);
      List<List<AStmt>> xs = (List)Nil$.MODULE$;
      for (int k=0;k<(s&vMask);k++)
        xs = $colon$colon$.MODULE$.<List<AStmt>>apply((List)values.get((int)(s>>32)+k),xs);
      return xs;
    }
    
    // Symbol ids
    private static final int iPlusEqTok = 0;
    private static final int iOrTok = 1;
    private static final int iSynchronizedTok = 2;
    private static final int iUntilTok = 3;
    private static final int iModTok = 4;
    private static final int iCommaTok = 5;
    private static final int iInTok = 6;
    private static final int iSuperTok = 7;
    private static final int iCompTok = 8;
    private static final int iAbstractTok = 9;
    private static final int iProtectedTok = 10;
    private static final int iStringLitTok = 11;
    private static final int iDotTok = 12;
    private static final int iNotTok = 13;
    private static final int iColonTok = 14;
    private static final int iInstanceofTok = 15;
    private static final int iReturnTok = 16;
    private static final int iFinalTok = 17;
    private static final int iFloatLitTok = 18;
    private static final int iUnsignedRShiftTok = 19;
    private static final int iLeTok = 20;
    private static final int iIdentTok = 21;
    private static final int iTransientTok = 22;
    private static final int iUnsignedRShiftEqTok = 23;
    private static final int iLtTok = 24;
    private static final int iIntLitTok = 25;
    private static final int iColonColonTok = 26;
    private static final int iAndAndTok = 27;
    private static final int iRShiftEqTok = 28;
    private static final int iContinueTok = 29;
    private static final int iVolatileTok = 30;
    private static final int iRCurlyTok = 31;
    private static final int iNewTok = 32;
    private static final int iLCurlyTok = 33;
    private static final int iXorEqTok = 34;
    private static final int iEqTok = 35;
    private static final int iPrivateTok = 36;
    private static final int iBreakTok = 37;
    private static final int iLParenTok = 38;
    private static final int iWhileTok = 39;
    private static final int iMulTok = 40;
    private static final int iDoTok = 41;
    private static final int iDivTok = 42;
    private static final int iDoubleLitTok = 43;
    private static final int iPlusPlusTok = 44;
    private static final int iSemiTok = 45;
    private static final int iStaticTok = 46;
    private static final int iLBrackTok = 47;
    private static final int iXorTok = 48;
    private static final int iMinusMinusTok = 49;
    private static final int iRBrackTok = 50;
    private static final int iNeTok = 51;
    private static final int iRParenTok = 52;
    private static final int iIfTok = 53;
    private static final int iAndEqTok = 54;
    private static final int iCharLitTok = 55;
    private static final int iMinusEqTok = 56;
    private static final int iForTok = 57;
    private static final int iGtTok = 58;
    private static final int iStrictfpTok = 59;
    private static final int iEqEqTok = 60;
    private static final int iExtendsTok = 61;
    private static final int iGeTok = 62;
    private static final int iThrowTok = 63;
    private static final int iElseTok = 64;
    private static final int iThenTok = 65;
    private static final int iQuestionTok = 66;
    private static final int iAssertTok = 67;
    private static final int iAndTok = 68;
    private static final int iRShiftTok = 69;
    private static final int iOrEqTok = 70;
    private static final int iLShiftEqTok = 71;
    private static final int iLShiftTok = 72;
    private static final int iModEqTok = 73;
    private static final int iPlusTok = 74;
    private static final int iOrOrTok = 75;
    private static final int iLongLitTok = 76;
    private static final int iAtTok = 77;
    private static final int iMulEqTok = 78;
    private static final int iPublicTok = 79;
    private static final int iMinusTok = 80;
    private static final int iDivEqTok = 81;
    private static final int iCommas2_ExpAssignNC = 0;
    private static final int iModTok__ExpUnary_ExpJuxt = 1;
    private static final int iIfTok__ExpAssignNP = 2;
    private static final int iRight__ExpUnary_ExpJuxt = 3;
    private static final int iExpCond_ExpNew__Right = 4;
    private static final int iRShiftTok__ExpAdd_ExpJuxt = 5;
    private static final int iForInfo__Right__Stmt = 6;
    private static final int iSemiTok__Stmts = 7;
    private static final int iOrOrTok__ExpAndAnd_ExpJuxt = 8;
    private static final int iExpHigh__Left = 9;
    private static final int iType__List1_VarDecl = 10;
    private static final int iIdentDims__ForeachSep__ExpAssign = 11;
    private static final int iForInfo = 12;
    private static final int iDivTok__ExpUnary_ExpJuxtNP = 13;
    private static final int iList_Type__GtTok = 14;
    private static final int iJuxts2_ExpAssignNC = 15;
    private static final int iLShiftTok__ExpAdd_ExpJuxt = 16;
    private static final int iPlusTok__ExpMul_ExpNew = 17;
    private static final int iDivTok__ExpUnary_ExpNew = 18;
    private static final int iAssertTok__ExpJuxt = 19;
    private static final int iEqEqTok__ExpRel_ExpJuxt = 20;
    private static final int iAssignOp = 21;
    private static final int iForInfo__Right = 22;
    private static final int iForeachSep__ExpAssign = 23;
    private static final int iWildcardBounds = 24;
    private static final int iColonTok__ExpCond_ExpJuxt = 25;
    private static final int iPreOp = 26;
    private static final int iCommas2_ExpCond_ExpJuxt__Right = 27;
    private static final int iThenTok__MaybeStmt__ElseTok = 28;
    private static final int iElseTok__Stmt = 29;
    private static final int iMaybeStmt__ElseTok__Stmt = 30;
    private static final int iLtTok__ExpShift_ExpJuxt = 31;
    private static final int iXorTok__ExpAnd_ExpJuxt = 32;
    private static final int iAndAndTok__ExpOr_ExpJuxt = 33;
    private static final int iLeTok__ExpShift_ExpJuxt = 34;
    private static final int iParenExp = 35;
    private static final int iParenExp__MaybeThen = 36;
    private static final int iNeTok__ExpRel_ExpJuxt = 37;
    private static final int iOrTok__ExpXor_ExpJuxt = 38;
    private static final int iJuxts2_ExpNew = 39;
    private static final int iIfTok__ParenExp = 40;
    private static final int iPostOp = 41;
    private static final int iCommaTok__Commas1_VarDecl = 42;
    private static final int iAndTok__ExpEq_ExpJuxt = 43;
    private static final int iMinusTok__ExpMul_ExpJuxt = 44;
    private static final int iCommaTok__Commas1_ExpCond_ExpJuxt = 45;
    private static final int iCommas0_StmtHelperBS__SemiTok = 46;
    private static final int iExpHigh__DotTok = 47;
    private static final int iCommas2_Type = 48;
    private static final int iCommaTok__Commas1_Type = 49;
    private static final int iModTok__ExpUnary_ExpJuxtNP = 50;
    private static final int iMinusTok__ExpMul_ExpNew = 51;
    private static final int iJuxts2_ExpNewNA = 52;
    private static final int iExpParens = 53;
    private static final int iTypeArgs = 54;
    private static final int iOption_TypeArgs = 55;
    private static final int iUnsignedRShiftTok__ExpAdd_ExpJuxt = 56;
    private static final int iJuxts2_VarDecl = 57;
    private static final int iMaybeThen = 58;
    private static final int iLBrackTok__Right = 59;
    private static final int iPlusTok__ExpMul_ExpJuxtNP = 60;
    private static final int iMaybeParenExp__Block = 61;
    private static final int iMulTok__ExpUnary_ExpNew = 62;
    private static final int iColonTok__ExpJuxt = 63;
    private static final int iLeftNP = 64;
    private static final int iExpAssignNP__ThenTok = 65;
    private static final int iForTok__Left = 66;
    private static final int iExpAssign__Right = 67;
    private static final int iMaybeStmt__ElseTok = 68;
    private static final int iMaybeThen__MaybeStmt__ElseTok = 69;
    private static final int iLeft = 70;
    private static final int iWhileUntil = 71;
    private static final int iMod = 72;
    private static final int iJuxts1_Mod = 73;
    private static final int iJuxts0_Mod = 74;
    private static final int iSemiTok__Commas0_ExpAssignNC = 75;
    private static final int iOption_ExpAssign__SemiTok__Commas0_ExpAssignNC = 76;
    private static final int iIfTok__ExpAssignNP__ThenTok = 77;
    private static final int iDoTok__MaybeStmt = 78;
    private static final int iEqTok__ExpCommas = 79;
    private static final int iExpAssignNC__Right = 80;
    private static final int iRight__Stmt = 81;
    private static final int iCommas2_ExpCond_ExpJuxt = 82;
    private static final int iJuxts2_Type = 83;
    private static final int iDivTok__ExpUnary_ExpJuxt = 84;
    private static final int iLParenTok__Type = 85;
    private static final int iCommaTok__Commas1_ExpAssignNC = 86;
    private static final int iPlusTok__ExpMul_ExpJuxt = 87;
    private static final int iCommaTok__Commas1_StmtHelperBS = 88;
    private static final int iAssignOp__ExpAssign = 89;
    private static final int iMinusTok__ExpMul_ExpJuxtNP = 90;
    private static final int iMulTok__ExpUnary_ExpJuxtNP = 91;
    private static final int iIfTok__ParenExp__MaybeThen = 92;
    private static final int iLit = 93;
    private static final int iDoTok__Stmt = 94;
    private static final int iGeTok__ExpShift_ExpJuxt = 95;
    private static final int iInstanceofTok__Type = 96;
    private static final int iMaybeDo = 97;
    private static final int iModTok__ExpUnary_ExpNew = 98;
    private static final int iExpAssign__ColonTok__ExpCond_ExpJuxt = 99;
    private static final int iWhileUntil__ParenExp = 100;
    private static final int iMulTok__ExpUnary_ExpJuxt = 101;
    private static final int iExpOrOr_ExpJuxt__QuestionTok = 102;
    private static final int iBlock = 103;
    private static final int iThenTok__Stmt = 104;
    private static final int iRight = 105;
    private static final int iList_ExpAssignNC__Right = 106;
    private static final int iStmts__Right = 107;
    private static final int iIdent = 108;
    private static final int iExpHighNA = 109;
    private static final int iExpHighNP = 110;
    private static final int iExpHigh = 111;
    private static final int iExpNew = 112;
    private static final int iJuxts1_ExpNew = 113;
    private static final int iExpUnary_ExpNew = 114;
    private static final int iExpMul_ExpNew = 115;
    private static final int iExpAdd_ExpNew = 116;
    private static final int iExpShift_ExpNew = 117;
    private static final int iExpRel_ExpNew = 118;
    private static final int iExpEq_ExpNew = 119;
    private static final int iExpAnd_ExpNew = 120;
    private static final int iExpXor_ExpNew = 121;
    private static final int iExpOr_ExpNew = 122;
    private static final int iExpAndAnd_ExpNew = 123;
    private static final int iExpOrOr_ExpNew = 124;
    private static final int iExpCond_ExpNew = 125;
    private static final int iExpJuxt = 126;
    private static final int iExpUnary_ExpJuxt = 127;
    private static final int iExpMul_ExpJuxt = 128;
    private static final int iExpAdd_ExpJuxt = 129;
    private static final int iExpShift_ExpJuxt = 130;
    private static final int iExpRel_ExpJuxt = 131;
    private static final int iExpEq_ExpJuxt = 132;
    private static final int iExpAnd_ExpJuxt = 133;
    private static final int iExpXor_ExpJuxt = 134;
    private static final int iExpOr_ExpJuxt = 135;
    private static final int iExpAndAnd_ExpJuxt = 136;
    private static final int iExpOrOr_ExpJuxt = 137;
    private static final int iExpCond_ExpJuxt = 138;
    private static final int iExpAssignNC = 139;
    private static final int iList1_ExpAssignNC = 140;
    private static final int iList_ExpAssignNC = 141;
    private static final int iCommas1_ExpAssignNC = 142;
    private static final int iCommas0_ExpAssignNC = 143;
    private static final int iJuxts1_ExpAssignNC = 144;
    private static final int iExpCommas = 145;
    private static final int iExpAssign = 146;
    private static final int iStmtHelperBS = 147;
    private static final int iCommas1_StmtHelperBS = 148;
    private static final int iCommas0_StmtHelperBS = 149;
    private static final int iStmtHelper = 150;
    private static final int iStmt = 151;
    private static final int iMaybeDo__Stmt = 152;
    private static final int iMaybeThen__Stmt = 153;
    private static final int iMaybeStmt = 154;
    private static final int iStmts = 155;
    private static final int iOption_ExpAssign = 156;
    private static final int iCommas1_ExpCond_ExpJuxt = 157;
    private static final int iOption_TypeArgs__ExpJuxt = 158;
    private static final int iOption_ExpJuxt = 159;
    private static final int iType = 160;
    private static final int iCommas1_Type = 161;
    private static final int iOption_Type = 162;
    private static final int iJuxts0_Mod__Option_Type = 163;
    private static final int iList1_Type = 164;
    private static final int iList_Type = 165;
    private static final int iJuxts1_Type = 166;
    private static final int iExpNewNP = 167;
    private static final int iExpJuxtNP = 168;
    private static final int iExpUnary_ExpJuxtNP = 169;
    private static final int iExpMul_ExpJuxtNP = 170;
    private static final int iExpAdd_ExpJuxtNP = 171;
    private static final int iExpShift_ExpJuxtNP = 172;
    private static final int iExpRel_ExpJuxtNP = 173;
    private static final int iExpEq_ExpJuxtNP = 174;
    private static final int iExpAnd_ExpJuxtNP = 175;
    private static final int iExpXor_ExpJuxtNP = 176;
    private static final int iExpOr_ExpJuxtNP = 177;
    private static final int iExpAndAnd_ExpJuxtNP = 178;
    private static final int iExpOrOr_ExpJuxtNP = 179;
    private static final int iExpCond_ExpJuxtNP = 180;
    private static final int iExpAssignNP = 181;
    private static final int iMaybeParenExp = 182;
    private static final int iMaybeParenExp__MaybeThen = 183;
    private static final int iMaybeParenExp__MaybeDo = 184;
    private static final int iExpNewNA = 185;
    private static final int iJuxts1_ExpNewNA = 186;
    private static final int iSingleJuxt1_ExpNewNA = 187;
    private static final int iOption_Ident = 188;
    private static final int iOption_TypeArgs__Ident = 189;
    private static final int iIdentDims = 190;
    private static final int iVarDecl = 191;
    private static final int iJuxts1_VarDecl = 192;
    private static final int iCommas1_VarDecl = 193;
    private static final int iForeachSep = 194;
    private static final int iExpHigh__ColonColonTok = 195;
    private static final int iCommas2_VarDecl = 196;
    private static final int iList1_VarDecl = 197;
    private static final int iWhileUntil__MaybeParenExp = 198;
    private static final int iForTok__ForInfo = 199;
    private static final int iGtTok__ExpShift_ExpJuxt = 200;
    private static final int iWhileUntil__ExpAssignNP = 201;
    private static final int iJuxts2_ExpNew__Right = 202;
    private static final int iOption_TypeArgs__NewTok = 203;
    
    // Determine token types
    private void types() {
      for (int i=0;i<n;i++) {
        final Token t = input[i];
        type[i] = (byte)(
            t instanceof PlusEqTok$ ? iPlusEqTok
          : t instanceof OrTok$ ? iOrTok
          : t instanceof SynchronizedTok$ ? iSynchronizedTok
          : t instanceof UntilTok$ ? iUntilTok
          : t instanceof ModTok$ ? iModTok
          : t instanceof CommaTok$ ? iCommaTok
          : t instanceof InTok$ ? iInTok
          : t instanceof SuperTok$ ? iSuperTok
          : t instanceof CompTok$ ? iCompTok
          : t instanceof AbstractTok$ ? iAbstractTok
          : t instanceof ProtectedTok$ ? iProtectedTok
          : t instanceof StringLitTok ? iStringLitTok
          : t instanceof DotTok$ ? iDotTok
          : t instanceof NotTok$ ? iNotTok
          : t instanceof ColonTok$ ? iColonTok
          : t instanceof InstanceofTok$ ? iInstanceofTok
          : t instanceof ReturnTok$ ? iReturnTok
          : t instanceof FinalTok$ ? iFinalTok
          : t instanceof FloatLitTok ? iFloatLitTok
          : t instanceof UnsignedRShiftTok$ ? iUnsignedRShiftTok
          : t instanceof LeTok$ ? iLeTok
          : t instanceof IdentTok ? iIdentTok
          : t instanceof TransientTok$ ? iTransientTok
          : t instanceof UnsignedRShiftEqTok$ ? iUnsignedRShiftEqTok
          : t instanceof LtTok$ ? iLtTok
          : t instanceof IntLitTok ? iIntLitTok
          : t instanceof ColonColonTok$ ? iColonColonTok
          : t instanceof AndAndTok$ ? iAndAndTok
          : t instanceof RShiftEqTok$ ? iRShiftEqTok
          : t instanceof ContinueTok$ ? iContinueTok
          : t instanceof VolatileTok$ ? iVolatileTok
          : t instanceof RCurlyTok$ ? iRCurlyTok
          : t instanceof NewTok$ ? iNewTok
          : t instanceof LCurlyTok$ ? iLCurlyTok
          : t instanceof XorEqTok$ ? iXorEqTok
          : t instanceof EqTok$ ? iEqTok
          : t instanceof PrivateTok$ ? iPrivateTok
          : t instanceof BreakTok$ ? iBreakTok
          : t instanceof LParenTok$ ? iLParenTok
          : t instanceof WhileTok$ ? iWhileTok
          : t instanceof MulTok$ ? iMulTok
          : t instanceof DoTok$ ? iDoTok
          : t instanceof DivTok$ ? iDivTok
          : t instanceof DoubleLitTok ? iDoubleLitTok
          : t instanceof PlusPlusTok$ ? iPlusPlusTok
          : t instanceof SemiTok$ ? iSemiTok
          : t instanceof StaticTok$ ? iStaticTok
          : t instanceof LBrackTok$ ? iLBrackTok
          : t instanceof XorTok$ ? iXorTok
          : t instanceof MinusMinusTok$ ? iMinusMinusTok
          : t instanceof RBrackTok$ ? iRBrackTok
          : t instanceof NeTok$ ? iNeTok
          : t instanceof RParenTok$ ? iRParenTok
          : t instanceof IfTok$ ? iIfTok
          : t instanceof AndEqTok$ ? iAndEqTok
          : t instanceof CharLitTok ? iCharLitTok
          : t instanceof MinusEqTok$ ? iMinusEqTok
          : t instanceof ForTok$ ? iForTok
          : t instanceof GtTok$ ? iGtTok
          : t instanceof StrictfpTok$ ? iStrictfpTok
          : t instanceof EqEqTok$ ? iEqEqTok
          : t instanceof ExtendsTok$ ? iExtendsTok
          : t instanceof GeTok$ ? iGeTok
          : t instanceof ThrowTok$ ? iThrowTok
          : t instanceof ElseTok$ ? iElseTok
          : t instanceof ThenTok$ ? iThenTok
          : t instanceof QuestionTok$ ? iQuestionTok
          : t instanceof AssertTok$ ? iAssertTok
          : t instanceof AndTok$ ? iAndTok
          : t instanceof RShiftTok$ ? iRShiftTok
          : t instanceof OrEqTok$ ? iOrEqTok
          : t instanceof LShiftEqTok$ ? iLShiftEqTok
          : t instanceof LShiftTok$ ? iLShiftTok
          : t instanceof ModEqTok$ ? iModEqTok
          : t instanceof PlusTok$ ? iPlusTok
          : t instanceof OrOrTok$ ? iOrOrTok
          : t instanceof LongLitTok ? iLongLitTok
          : t instanceof AtTok$ ? iAtTok
          : t instanceof MulEqTok$ ? iMulEqTok
          : t instanceof PublicTok$ ? iPublicTok
          : t instanceof MinusTok$ ? iMinusTok
          : t instanceof DivEqTok$ ? iDivEqTok
          : 255);
      }
    }
    
    // Parse null productions
    private void nulls() {
      long slice;
      int next = values.size();
      values.add(WildcardBounds3()); // WildcardBounds -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iWildcardBounds<<24|i<<12|i,slice);
      values.add(Option_TypeArgs1()); // Option_TypeArgs -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iOption_TypeArgs<<24|i<<12|i,slice);
      // MaybeThen is simple
      for (int i=0;i<=n;i++) slices.put(iMaybeThen<<24|i<<12|i,1);
      values.add(Juxts0_Mod1()); // Juxts0_Mod -> "" : Nil
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iJuxts0_Mod<<24|i<<12|i,slice);
      // MaybeDo is simple
      for (int i=0;i<=n;i++) slices.put(iMaybeDo<<24|i<<12|i,1);
      values.add(List_ExpAssignNC1()); // List_ExpAssignNC -> "" : EmptyList
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iList_ExpAssignNC<<24|i<<12|i,slice);
      values.add(Commas0_ExpAssignNC1()); // Commas0_ExpAssignNC -> "" : Nil
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iCommas0_ExpAssignNC<<24|i<<12|i,slice);
      values.add(Commas0_StmtHelperBS1()); // Commas0_StmtHelperBS -> "" : Nil
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iCommas0_StmtHelperBS<<24|i<<12|i,slice);
      values.add(MaybeStmt1()); // MaybeStmt -> "" : HoleAStmt
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iMaybeStmt<<24|i<<12|i,slice);
      values.add(Stmts3()); // Stmts -> "" : Nil
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iStmts<<24|i<<12|i,slice);
      values.add(Option_ExpAssign1()); // Option_ExpAssign -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iOption_ExpAssign<<24|i<<12|i,slice);
      values.add(Option_ExpJuxt1()); // Option_ExpJuxt -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iOption_ExpJuxt<<24|i<<12|i,slice);
      values.add(Option_Type1()); // Option_Type -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iOption_Type<<24|i<<12|i,slice);
      values.add(Juxts0_Mod__Option_Type0((List)values.get((int)(slices.get(iJuxts0_Mod<<24)>>32)),(Option)values.get((int)(slices.get(iOption_Type<<24)>>32)))); // Juxts0_Mod__Option_Type -> Juxts0_Mod Option_Type : ($1,$2)
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iJuxts0_Mod__Option_Type<<24|i<<12|i,slice);
      values.add(List_Type1()); // List_Type -> "" : EmptyList
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iList_Type<<24|i<<12|i,slice);
      values.add(Option_Ident1()); // Option_Ident -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iOption_Ident<<24|i<<12|i,slice);
    }
    
    // Parse nonnull productions
    private void nonnulls() {
      for (int lo=n;lo>=0;lo--) for (int hi=lo+1;hi<=n;hi++) {
        Commas2_ExpAssignNC(lo,hi);
        ModTok__ExpUnary_ExpJuxt(lo,hi);
        IfTok__ExpAssignNP(lo,hi);
        Right__ExpUnary_ExpJuxt(lo,hi);
        ExpCond_ExpNew__Right(lo,hi);
        RShiftTok__ExpAdd_ExpJuxt(lo,hi);
        ForInfo__Right__Stmt(lo,hi);
        SemiTok__Stmts(lo,hi);
        OrOrTok__ExpAndAnd_ExpJuxt(lo,hi);
        ExpHigh__Left(lo,hi);
        Type__List1_VarDecl(lo,hi);
        IdentDims__ForeachSep__ExpAssign(lo,hi);
        ForInfo(lo,hi);
        DivTok__ExpUnary_ExpJuxtNP(lo,hi);
        List_Type__GtTok(lo,hi);
        Juxts2_ExpAssignNC(lo,hi);
        LShiftTok__ExpAdd_ExpJuxt(lo,hi);
        PlusTok__ExpMul_ExpNew(lo,hi);
        DivTok__ExpUnary_ExpNew(lo,hi);
        AssertTok__ExpJuxt(lo,hi);
        EqEqTok__ExpRel_ExpJuxt(lo,hi);
        AssignOp(lo,hi);
        ForInfo__Right(lo,hi);
        ForeachSep__ExpAssign(lo,hi);
        WildcardBounds(lo,hi);
        ColonTok__ExpCond_ExpJuxt(lo,hi);
        PreOp(lo,hi);
        Commas2_ExpCond_ExpJuxt__Right(lo,hi);
        ThenTok__MaybeStmt__ElseTok(lo,hi);
        ElseTok__Stmt(lo,hi);
        MaybeStmt__ElseTok__Stmt(lo,hi);
        LtTok__ExpShift_ExpJuxt(lo,hi);
        XorTok__ExpAnd_ExpJuxt(lo,hi);
        AndAndTok__ExpOr_ExpJuxt(lo,hi);
        LeTok__ExpShift_ExpJuxt(lo,hi);
        ParenExp(lo,hi);
        ParenExp__MaybeThen(lo,hi);
        NeTok__ExpRel_ExpJuxt(lo,hi);
        OrTok__ExpXor_ExpJuxt(lo,hi);
        Juxts2_ExpNew(lo,hi);
        IfTok__ParenExp(lo,hi);
        PostOp(lo,hi);
        CommaTok__Commas1_VarDecl(lo,hi);
        AndTok__ExpEq_ExpJuxt(lo,hi);
        MinusTok__ExpMul_ExpJuxt(lo,hi);
        CommaTok__Commas1_ExpCond_ExpJuxt(lo,hi);
        Commas0_StmtHelperBS__SemiTok(lo,hi);
        ExpHigh__DotTok(lo,hi);
        Commas2_Type(lo,hi);
        CommaTok__Commas1_Type(lo,hi);
        ModTok__ExpUnary_ExpJuxtNP(lo,hi);
        MinusTok__ExpMul_ExpNew(lo,hi);
        Juxts2_ExpNewNA(lo,hi);
        ExpParens(lo,hi);
        TypeArgs(lo,hi);
        Option_TypeArgs(lo,hi);
        UnsignedRShiftTok__ExpAdd_ExpJuxt(lo,hi);
        Juxts2_VarDecl(lo,hi);
        MaybeThen(lo,hi);
        LBrackTok__Right(lo,hi);
        PlusTok__ExpMul_ExpJuxtNP(lo,hi);
        MaybeParenExp__Block(lo,hi);
        MulTok__ExpUnary_ExpNew(lo,hi);
        ColonTok__ExpJuxt(lo,hi);
        LeftNP(lo,hi);
        ExpAssignNP__ThenTok(lo,hi);
        ForTok__Left(lo,hi);
        ExpAssign__Right(lo,hi);
        MaybeStmt__ElseTok(lo,hi);
        MaybeThen__MaybeStmt__ElseTok(lo,hi);
        Left(lo,hi);
        WhileUntil(lo,hi);
        Mod(lo,hi);
        Juxts1_Mod(lo,hi);
        Juxts0_Mod(lo,hi);
        SemiTok__Commas0_ExpAssignNC(lo,hi);
        Option_ExpAssign__SemiTok__Commas0_ExpAssignNC(lo,hi);
        IfTok__ExpAssignNP__ThenTok(lo,hi);
        DoTok__MaybeStmt(lo,hi);
        EqTok__ExpCommas(lo,hi);
        ExpAssignNC__Right(lo,hi);
        Right__Stmt(lo,hi);
        Commas2_ExpCond_ExpJuxt(lo,hi);
        Juxts2_Type(lo,hi);
        DivTok__ExpUnary_ExpJuxt(lo,hi);
        LParenTok__Type(lo,hi);
        CommaTok__Commas1_ExpAssignNC(lo,hi);
        PlusTok__ExpMul_ExpJuxt(lo,hi);
        CommaTok__Commas1_StmtHelperBS(lo,hi);
        AssignOp__ExpAssign(lo,hi);
        MinusTok__ExpMul_ExpJuxtNP(lo,hi);
        MulTok__ExpUnary_ExpJuxtNP(lo,hi);
        IfTok__ParenExp__MaybeThen(lo,hi);
        Lit(lo,hi);
        DoTok__Stmt(lo,hi);
        GeTok__ExpShift_ExpJuxt(lo,hi);
        InstanceofTok__Type(lo,hi);
        MaybeDo(lo,hi);
        ModTok__ExpUnary_ExpNew(lo,hi);
        ExpAssign__ColonTok__ExpCond_ExpJuxt(lo,hi);
        WhileUntil__ParenExp(lo,hi);
        MulTok__ExpUnary_ExpJuxt(lo,hi);
        ExpOrOr_ExpJuxt__QuestionTok(lo,hi);
        Block(lo,hi);
        ThenTok__Stmt(lo,hi);
        Right(lo,hi);
        List_ExpAssignNC__Right(lo,hi);
        Stmts__Right(lo,hi);
        Ident(lo,hi);
        ExpHighNA(lo,hi);
        ExpHighNP(lo,hi);
        ExpHigh(lo,hi);
        ExpNew(lo,hi);
        Juxts1_ExpNew(lo,hi);
        ExpUnary_ExpNew(lo,hi);
        ExpMul_ExpNew(lo,hi);
        ExpAdd_ExpNew(lo,hi);
        ExpShift_ExpNew(lo,hi);
        ExpRel_ExpNew(lo,hi);
        ExpEq_ExpNew(lo,hi);
        ExpAnd_ExpNew(lo,hi);
        ExpXor_ExpNew(lo,hi);
        ExpOr_ExpNew(lo,hi);
        ExpAndAnd_ExpNew(lo,hi);
        ExpOrOr_ExpNew(lo,hi);
        ExpCond_ExpNew(lo,hi);
        ExpJuxt(lo,hi);
        ExpUnary_ExpJuxt(lo,hi);
        ExpMul_ExpJuxt(lo,hi);
        ExpAdd_ExpJuxt(lo,hi);
        ExpShift_ExpJuxt(lo,hi);
        ExpRel_ExpJuxt(lo,hi);
        ExpEq_ExpJuxt(lo,hi);
        ExpAnd_ExpJuxt(lo,hi);
        ExpXor_ExpJuxt(lo,hi);
        ExpOr_ExpJuxt(lo,hi);
        ExpAndAnd_ExpJuxt(lo,hi);
        ExpOrOr_ExpJuxt(lo,hi);
        ExpCond_ExpJuxt(lo,hi);
        ExpAssignNC(lo,hi);
        List1_ExpAssignNC(lo,hi);
        List_ExpAssignNC(lo,hi);
        Commas1_ExpAssignNC(lo,hi);
        Commas0_ExpAssignNC(lo,hi);
        Juxts1_ExpAssignNC(lo,hi);
        ExpCommas(lo,hi);
        ExpAssign(lo,hi);
        StmtHelperBS(lo,hi);
        Commas1_StmtHelperBS(lo,hi);
        Commas0_StmtHelperBS(lo,hi);
        StmtHelper(lo,hi);
        Stmt(lo,hi);
        MaybeDo__Stmt(lo,hi);
        MaybeThen__Stmt(lo,hi);
        MaybeStmt(lo,hi);
        Stmts(lo,hi);
        Option_ExpAssign(lo,hi);
        Commas1_ExpCond_ExpJuxt(lo,hi);
        Option_TypeArgs__ExpJuxt(lo,hi);
        Option_ExpJuxt(lo,hi);
        Type(lo,hi);
        Commas1_Type(lo,hi);
        Option_Type(lo,hi);
        Juxts0_Mod__Option_Type(lo,hi);
        List1_Type(lo,hi);
        List_Type(lo,hi);
        Juxts1_Type(lo,hi);
        ExpNewNP(lo,hi);
        ExpJuxtNP(lo,hi);
        ExpUnary_ExpJuxtNP(lo,hi);
        ExpMul_ExpJuxtNP(lo,hi);
        ExpAdd_ExpJuxtNP(lo,hi);
        ExpShift_ExpJuxtNP(lo,hi);
        ExpRel_ExpJuxtNP(lo,hi);
        ExpEq_ExpJuxtNP(lo,hi);
        ExpAnd_ExpJuxtNP(lo,hi);
        ExpXor_ExpJuxtNP(lo,hi);
        ExpOr_ExpJuxtNP(lo,hi);
        ExpAndAnd_ExpJuxtNP(lo,hi);
        ExpOrOr_ExpJuxtNP(lo,hi);
        ExpCond_ExpJuxtNP(lo,hi);
        ExpAssignNP(lo,hi);
        MaybeParenExp(lo,hi);
        MaybeParenExp__MaybeThen(lo,hi);
        MaybeParenExp__MaybeDo(lo,hi);
        ExpNewNA(lo,hi);
        Juxts1_ExpNewNA(lo,hi);
        SingleJuxt1_ExpNewNA(lo,hi);
        Option_Ident(lo,hi);
        Option_TypeArgs__Ident(lo,hi);
        IdentDims(lo,hi);
        VarDecl(lo,hi);
        Juxts1_VarDecl(lo,hi);
        Commas1_VarDecl(lo,hi);
        ForeachSep(lo,hi);
        ExpHigh__ColonColonTok(lo,hi);
        Commas2_VarDecl(lo,hi);
        List1_VarDecl(lo,hi);
        WhileUntil__MaybeParenExp(lo,hi);
        ForTok__ForInfo(lo,hi);
        GtTok__ExpShift_ExpJuxt(lo,hi);
        WhileUntil__ExpAssignNP(lo,hi);
        Juxts2_ExpNew__Right(lo,hi);
        Option_TypeArgs__NewTok(lo,hi);
      }
    }
    
    private void Commas2_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAssignNC<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommaTok__Commas1_ExpAssignNC<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas2_ExpAssignNC0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas2_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ModTok__ExpUnary_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iModTok) {
        final long s1 = slices.get(iExpUnary_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ModTok__ExpUnary_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iModTok__ExpUnary_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void IfTok__ExpAssignNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iIfTok) {
        final long s1 = slices.get(iExpAssignNP<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(IfTok__ExpAssignNP0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iIfTok__ExpAssignNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Right__ExpUnary_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iRight<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Right__ExpUnary_ExpJuxt0((Group)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iRight__ExpUnary_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpCond_ExpNew__Right(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpCond_ExpNew<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpCond_ExpNew__Right0((AExp)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpCond_ExpNew__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void RShiftTok__ExpAdd_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iRShiftTok) {
        final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(RShiftTok__ExpAdd_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iRShiftTok__ExpAdd_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForInfo__Right__Stmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iForInfo<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ForInfo__Right__Stmt0((ForInfo)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iForInfo__Right__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void SemiTok__Stmts(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iSemiTok) {
        final long s1 = slices.get(iStmts<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(SemiTok__Stmts0((List)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iSemiTok__Stmts<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void OrOrTok__ExpAndAnd_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iOrOrTok) {
        final long s1 = slices.get(iExpAndAnd_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(OrOrTok__ExpAndAnd_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOrOrTok__ExpAndAnd_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpHigh__Left(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpHigh<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iLeft<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHigh__Left0((AExp)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpHigh__Left<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Type__List1_VarDecl(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iType<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iList1_VarDecl<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Type__List1_VarDecl0((AExp)values.get((int)(s1>>32)+k1),(KList)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iType__List1_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void IdentDims__ForeachSep__ExpAssign(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iIdentDims<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iForeachSep__ExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(IdentDims__ForeachSep__ExpAssign0((Tuple2)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iIdentDims__ForeachSep__ExpAssign<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForInfo(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iJuxts0_Mod__Option_Type<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iIdentDims__ForeachSep__ExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ForInfo0((Tuple2)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iCommas0_StmtHelperBS__SemiTok<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iOption_ExpAssign__SemiTok__Commas0_ExpAssignNC<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ForInfo1((List)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iForInfo<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void DivTok__ExpUnary_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iDivTok) {
        final long s1 = slices.get(iExpUnary_ExpJuxtNP<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(DivTok__ExpUnary_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iDivTok__ExpUnary_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List_Type__GtTok(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[hi-1]==iGtTok) {
        final long s1 = slices.get(iList_Type<<24|lo<<12|hi-1);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List_Type__GtTok0((KList)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList_Type__GtTok<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAssignNC<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpAssignNC<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_ExpAssignNC0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void LShiftTok__ExpAdd_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iLShiftTok) {
        final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(LShiftTok__ExpAdd_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iLShiftTok__ExpAdd_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void PlusTok__ExpMul_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iPlusTok) {
        final long s1 = slices.get(iExpMul_ExpNew<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(PlusTok__ExpMul_ExpNew0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iPlusTok__ExpMul_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void DivTok__ExpUnary_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iDivTok) {
        final long s1 = slices.get(iExpUnary_ExpNew<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(DivTok__ExpUnary_ExpNew0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iDivTok__ExpUnary_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void AssertTok__ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iAssertTok) {
        final long s1 = slices.get(iExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(AssertTok__ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iAssertTok__ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void EqEqTok__ExpRel_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iEqEqTok) {
        final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(EqEqTok__ExpRel_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iEqEqTok__ExpRel_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void AssignOp(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iDivEqTok)
        values.add(AssignOp0());
      if (hi-lo==1 && type[lo]==iPlusEqTok)
        values.add(AssignOp1());
      if (hi-lo==1 && type[lo]==iUnsignedRShiftEqTok)
        values.add(AssignOp2());
      if (hi-lo==1 && type[lo]==iLShiftEqTok)
        values.add(AssignOp3());
      if (hi-lo==1 && type[lo]==iOrEqTok)
        values.add(AssignOp4());
      if (hi-lo==1 && type[lo]==iAndEqTok)
        values.add(AssignOp5());
      if (hi-lo==1 && type[lo]==iMulEqTok)
        values.add(AssignOp6());
      if (hi-lo==1 && type[lo]==iXorEqTok)
        values.add(AssignOp7());
      if (hi-lo==1 && type[lo]==iEqTok)
        values.add(AssignOp8());
      if (hi-lo==1 && type[lo]==iMinusEqTok)
        values.add(AssignOp9());
      if (hi-lo==1 && type[lo]==iRShiftEqTok)
        values.add(AssignOp10());
      if (hi-lo==1 && type[lo]==iModEqTok)
        values.add(AssignOp11());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iAssignOp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForInfo__Right(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iForInfo<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ForInfo__Right0((ForInfo)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iForInfo__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForeachSep__ExpAssign(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iForeachSep<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k3=0;k3<(s3&vMask);k3++)
              values.add(ForeachSep__ExpAssign0((AExp)values.get((int)(s3>>32)+k3)));
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iForeachSep__ExpAssign<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void WildcardBounds(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iSuperTok) {
        final long s1 = slices.get(iType<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(WildcardBounds0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1 && type[lo]==iColonTok) {
        final long s1 = slices.get(iType<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(WildcardBounds1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1 && type[lo]==iExtendsTok) {
        final long s1 = slices.get(iType<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(WildcardBounds2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iWildcardBounds<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ColonTok__ExpCond_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iColonTok) {
        final long s1 = slices.get(iExpCond_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ColonTok__ExpCond_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iColonTok__ExpCond_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void PreOp(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iPlusPlusTok)
        values.add(PreOp0());
      if (hi-lo==1 && type[lo]==iCompTok)
        values.add(PreOp1());
      if (hi-lo==1 && type[lo]==iPlusTok)
        values.add(PreOp2());
      if (hi-lo==1 && type[lo]==iNotTok)
        values.add(PreOp3());
      if (hi-lo==1 && type[lo]==iMinusMinusTok)
        values.add(PreOp4());
      if (hi-lo==1 && type[lo]==iMinusTok)
        values.add(PreOp5());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iPreOp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas2_ExpCond_ExpJuxt__Right(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iCommas2_ExpCond_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas2_ExpCond_ExpJuxt__Right0((List)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas2_ExpCond_ExpJuxt__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ThenTok__MaybeStmt__ElseTok(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iThenTok) {
        final long s1 = slices.get(iMaybeStmt__ElseTok<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ThenTok__MaybeStmt__ElseTok0((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iThenTok__MaybeStmt__ElseTok<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ElseTok__Stmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iElseTok) {
        final long s1 = slices.get(iStmt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ElseTok__Stmt0((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iElseTok__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeStmt__ElseTok__Stmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iMaybeStmt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iElseTok__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(MaybeStmt__ElseTok__Stmt0((AStmt)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeStmt__ElseTok__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void LtTok__ExpShift_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iLtTok) {
        final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(LtTok__ExpShift_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iLtTok__ExpShift_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void XorTok__ExpAnd_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iXorTok) {
        final long s1 = slices.get(iExpAnd_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(XorTok__ExpAnd_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iXorTok__ExpAnd_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void AndAndTok__ExpOr_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iAndAndTok) {
        final long s1 = slices.get(iExpOr_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(AndAndTok__ExpOr_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iAndAndTok__ExpOr_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void LeTok__ExpShift_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iLeTok) {
        final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(LeTok__ExpShift_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iLeTok__ExpShift_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ParenExp(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iLeft<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssign__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ParenExp0((Group)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iParenExp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ParenExp__MaybeThen(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iParenExp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeThen<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++)
              values.add(ParenExp__MaybeThen0((Tuple2)values.get((int)(s1>>32)+k1)));
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iParenExp__MaybeThen<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void NeTok__ExpRel_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iNeTok) {
        final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(NeTok__ExpRel_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iNeTok__ExpRel_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void OrTok__ExpXor_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iOrTok) {
        final long s1 = slices.get(iExpXor_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(OrTok__ExpXor_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOrTok__ExpXor_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpNew<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpNew<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void IfTok__ParenExp(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iIfTok) {
        final long s1 = slices.get(iParenExp<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(IfTok__ParenExp0((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iIfTok__ParenExp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void PostOp(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iMinusMinusTok)
        values.add(PostOp0());
      if (hi-lo==1 && type[lo]==iPlusPlusTok)
        values.add(PostOp1());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iPostOp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void CommaTok__Commas1_VarDecl(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iCommaTok) {
        final long s1 = slices.get(iCommas1_VarDecl<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(CommaTok__Commas1_VarDecl0((List)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommaTok__Commas1_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void AndTok__ExpEq_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iAndTok) {
        final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(AndTok__ExpEq_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iAndTok__ExpEq_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MinusTok__ExpMul_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iMinusTok) {
        final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(MinusTok__ExpMul_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMinusTok__ExpMul_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void CommaTok__Commas1_ExpCond_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iCommaTok) {
        final long s1 = slices.get(iCommas1_ExpCond_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(CommaTok__Commas1_ExpCond_ExpJuxt0((List)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommaTok__Commas1_ExpCond_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas0_StmtHelperBS__SemiTok(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[hi-1]==iSemiTok) {
        final long s1 = slices.get(iCommas0_StmtHelperBS<<24|lo<<12|hi-1);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas0_StmtHelperBS__SemiTok0((List)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas0_StmtHelperBS__SemiTok<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpHigh__DotTok(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[hi-1]==iDotTok) {
        final long s1 = slices.get(iExpHigh<<24|lo<<12|hi-1);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpHigh__DotTok0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpHigh__DotTok<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas2_Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iType<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommaTok__Commas1_Type<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas2_Type0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas2_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void CommaTok__Commas1_Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iCommaTok) {
        final long s1 = slices.get(iCommas1_Type<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(CommaTok__Commas1_Type0((List)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommaTok__Commas1_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ModTok__ExpUnary_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iModTok) {
        final long s1 = slices.get(iExpUnary_ExpJuxtNP<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ModTok__ExpUnary_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iModTok__ExpUnary_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MinusTok__ExpMul_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iMinusTok) {
        final long s1 = slices.get(iExpMul_ExpNew<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(MinusTok__ExpMul_ExpNew0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMinusTok__ExpMul_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_ExpNewNA(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpNewNA<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpNewNA<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_ExpNewNA0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_ExpNewNA<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpParens(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iLParenTok) {
        final long s1 = slices.get(iJuxts2_ExpNew__Right<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpParens0((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1 && type[lo]==iLParenTok) {
        final long s1 = slices.get(iCommas2_ExpCond_ExpJuxt__Right<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpParens1((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1 && type[lo]==iLParenTok) {
        final long s1 = slices.get(iRight<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpParens2((Group)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1 && type[lo]==iLParenTok) {
        final long s1 = slices.get(iExpAssignNC__Right<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpParens3((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpParens<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void TypeArgs(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iLtTok) {
        final long s1 = slices.get(iList_Type__GtTok<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(TypeArgs0((KList)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iTypeArgs<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_TypeArgs(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iTypeArgs<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Option_TypeArgs0((KList)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_TypeArgs<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void UnsignedRShiftTok__ExpAdd_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iUnsignedRShiftTok) {
        final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(UnsignedRShiftTok__ExpAdd_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iUnsignedRShiftTok__ExpAdd_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_VarDecl(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iVarDecl<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_VarDecl<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_VarDecl0((Tuple3)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeThen(final int lo, final int hi) {
      boolean found = false;
      if (hi-lo==1 && type[lo]==iThenTok)
        found = true;
      if (found) { slices.put(iMaybeThen<<24|lo<<12|hi,1); }
    }
    
    private void LBrackTok__Right(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iLBrackTok) {
        final long s1 = slices.get(iRight<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(LBrackTok__Right0((Group)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iLBrackTok__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void PlusTok__ExpMul_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iPlusTok) {
        final long s1 = slices.get(iExpMul_ExpJuxtNP<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(PlusTok__ExpMul_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iPlusTok__ExpMul_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeParenExp__Block(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iMaybeParenExp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iBlock<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(MaybeParenExp__Block0((Tuple2)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeParenExp__Block<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MulTok__ExpUnary_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iMulTok) {
        final long s1 = slices.get(iExpUnary_ExpNew<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(MulTok__ExpUnary_ExpNew0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMulTok__ExpUnary_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ColonTok__ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iColonTok) {
        final long s1 = slices.get(iExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ColonTok__ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iColonTok__ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void LeftNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iLCurlyTok)
        values.add(LeftNP0());
      if (hi-lo==1 && type[lo]==iLBrackTok)
        values.add(LeftNP1());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iLeftNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAssignNP__ThenTok(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[hi-1]==iThenTok) {
        final long s1 = slices.get(iExpAssignNP<<24|lo<<12|hi-1);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAssignNP__ThenTok0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAssignNP__ThenTok<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForTok__Left(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iForTok) {
        final long s1 = slices.get(iLeft<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ForTok__Left0((Group)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iForTok__Left<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAssign__Right(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAssign<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAssign__Right0((AExp)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAssign__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeStmt__ElseTok(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[hi-1]==iElseTok) {
        final long s1 = slices.get(iMaybeStmt<<24|lo<<12|hi-1);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(MaybeStmt__ElseTok0((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeStmt__ElseTok<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeThen__MaybeStmt__ElseTok(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iMaybeThen<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeStmt__ElseTok<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k3=0;k3<(s3&vMask);k3++)
              values.add(MaybeThen__MaybeStmt__ElseTok0((AStmt)values.get((int)(s3>>32)+k3)));
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeThen__MaybeStmt__ElseTok<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Left(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iLCurlyTok)
        values.add(Left0());
      if (hi-lo==1 && type[lo]==iLBrackTok)
        values.add(Left1());
      if (hi-lo==1 && type[lo]==iLParenTok)
        values.add(Left2());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iLeft<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void WhileUntil(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iUntilTok)
        values.add(WhileUntil0());
      if (hi-lo==1 && type[lo]==iWhileTok)
        values.add(WhileUntil1());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iWhileUntil<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Mod(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iAtTok) {
        final long s1 = slices.get(iIdent<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Mod0((String)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo==1 && type[lo]==iAbstractTok)
        values.add(Mod1());
      if (hi-lo==1 && type[lo]==iStrictfpTok)
        values.add(Mod2());
      if (hi-lo==1 && type[lo]==iPrivateTok)
        values.add(Mod3());
      if (hi-lo==1 && type[lo]==iTransientTok)
        values.add(Mod4());
      if (hi-lo==1 && type[lo]==iPublicTok)
        values.add(Mod5());
      if (hi-lo==1 && type[lo]==iStaticTok)
        values.add(Mod6());
      if (hi-lo==1 && type[lo]==iVolatileTok)
        values.add(Mod7());
      if (hi-lo==1 && type[lo]==iSynchronizedTok)
        values.add(Mod8());
      if (hi-lo==1 && type[lo]==iProtectedTok)
        values.add(Mod9());
      if (hi-lo==1 && type[lo]==iFinalTok)
        values.add(Mod10());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMod<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_Mod(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iMod<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_Mod<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_Mod0((Mod)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iMod<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_Mod1((Mod)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_Mod<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts0_Mod(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iJuxts1_Mod<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts0_Mod0((List)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts0_Mod<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void SemiTok__Commas0_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iSemiTok) {
        final long s1 = slices.get(iCommas0_ExpAssignNC<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(SemiTok__Commas0_ExpAssignNC0((List)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iSemiTok__Commas0_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_ExpAssign__SemiTok__Commas0_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iOption_ExpAssign<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iSemiTok__Commas0_ExpAssignNC<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Option_ExpAssign__SemiTok__Commas0_ExpAssignNC0((Option)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_ExpAssign__SemiTok__Commas0_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void IfTok__ExpAssignNP__ThenTok(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iIfTok) {
        final long s1 = slices.get(iExpAssignNP__ThenTok<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(IfTok__ExpAssignNP__ThenTok0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iIfTok__ExpAssignNP__ThenTok<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void DoTok__MaybeStmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iDoTok) {
        final long s1 = slices.get(iMaybeStmt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(DoTok__MaybeStmt0((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iDoTok__MaybeStmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void EqTok__ExpCommas(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iEqTok) {
        final long s1 = slices.get(iExpCommas<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(EqTok__ExpCommas0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iEqTok__ExpCommas<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAssignNC__Right(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAssignNC<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAssignNC__Right0((AExp)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAssignNC__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Right__Stmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iRight<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Right__Stmt0((Group)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iRight__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas2_ExpCond_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpCond_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommaTok__Commas1_ExpCond_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas2_ExpCond_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas2_ExpCond_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iType<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_Type<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_Type0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void DivTok__ExpUnary_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iDivTok) {
        final long s1 = slices.get(iExpUnary_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(DivTok__ExpUnary_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iDivTok__ExpUnary_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void LParenTok__Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iLParenTok) {
        final long s1 = slices.get(iType<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(LParenTok__Type0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iLParenTok__Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void CommaTok__Commas1_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iCommaTok) {
        final long s1 = slices.get(iCommas1_ExpAssignNC<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(CommaTok__Commas1_ExpAssignNC0((List)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommaTok__Commas1_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void PlusTok__ExpMul_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iPlusTok) {
        final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(PlusTok__ExpMul_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iPlusTok__ExpMul_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void CommaTok__Commas1_StmtHelperBS(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iCommaTok) {
        final long s1 = slices.get(iCommas1_StmtHelperBS<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(CommaTok__Commas1_StmtHelperBS0((List)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommaTok__Commas1_StmtHelperBS<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void AssignOp__ExpAssign(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iAssignOp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(AssignOp__ExpAssign0((Option)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iAssignOp__ExpAssign<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MinusTok__ExpMul_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iMinusTok) {
        final long s1 = slices.get(iExpMul_ExpJuxtNP<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(MinusTok__ExpMul_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMinusTok__ExpMul_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MulTok__ExpUnary_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iMulTok) {
        final long s1 = slices.get(iExpUnary_ExpJuxtNP<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(MulTok__ExpUnary_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMulTok__ExpUnary_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void IfTok__ParenExp__MaybeThen(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iIfTok) {
        final long s1 = slices.get(iParenExp__MaybeThen<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(IfTok__ParenExp__MaybeThen0((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iIfTok__ParenExp__MaybeThen<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Lit(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iFloatLitTok)
        values.add(Lit0((FloatLitTok)input[lo]));
      if (hi-lo==1 && type[lo]==iDoubleLitTok)
        values.add(Lit1((DoubleLitTok)input[lo]));
      if (hi-lo==1 && type[lo]==iStringLitTok)
        values.add(Lit2((StringLitTok)input[lo]));
      if (hi-lo==1 && type[lo]==iIntLitTok)
        values.add(Lit3((IntLitTok)input[lo]));
      if (hi-lo==1 && type[lo]==iLongLitTok)
        values.add(Lit4((LongLitTok)input[lo]));
      if (hi-lo==1 && type[lo]==iCharLitTok)
        values.add(Lit5((CharLitTok)input[lo]));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iLit<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void DoTok__Stmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iDoTok) {
        final long s1 = slices.get(iStmt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(DoTok__Stmt0((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iDoTok__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void GeTok__ExpShift_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iGeTok) {
        final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(GeTok__ExpShift_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iGeTok__ExpShift_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void InstanceofTok__Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iInstanceofTok) {
        final long s1 = slices.get(iType<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(InstanceofTok__Type0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iInstanceofTok__Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeDo(final int lo, final int hi) {
      boolean found = false;
      if (hi-lo==1 && type[lo]==iDoTok)
        found = true;
      if (found) { slices.put(iMaybeDo<<24|lo<<12|hi,1); }
    }
    
    private void ModTok__ExpUnary_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iModTok) {
        final long s1 = slices.get(iExpUnary_ExpNew<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ModTok__ExpUnary_ExpNew0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iModTok__ExpUnary_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAssign__ColonTok__ExpCond_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAssign<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iColonTok__ExpCond_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAssign__ColonTok__ExpCond_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAssign__ColonTok__ExpCond_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void WhileUntil__ParenExp(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iWhileUntil<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iParenExp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(WhileUntil__ParenExp0((java.lang.Boolean)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iWhileUntil__ParenExp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MulTok__ExpUnary_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iMulTok) {
        final long s1 = slices.get(iExpUnary_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(MulTok__ExpUnary_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMulTok__ExpUnary_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOrOr_ExpJuxt__QuestionTok(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[hi-1]==iQuestionTok) {
        final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|hi-1);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOrOr_ExpJuxt__QuestionTok0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOrOr_ExpJuxt__QuestionTok<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Block(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iLCurlyTok) {
        final long s1 = slices.get(iStmts__Right<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Block0((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iBlock<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ThenTok__Stmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iThenTok) {
        final long s1 = slices.get(iStmt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ThenTok__Stmt0((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iThenTok__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Right(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iRCurlyTok)
        values.add(Right0());
      if (hi-lo==1 && type[lo]==iRBrackTok)
        values.add(Right1());
      if (hi-lo==1 && type[lo]==iRParenTok)
        values.add(Right2());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iRight<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List_ExpAssignNC__Right(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iList_ExpAssignNC<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(List_ExpAssignNC__Right0((KList)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList_ExpAssignNC__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Stmts__Right(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iStmts<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Stmts__Right0((List)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iStmts__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Ident(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iInTok)
        values.add(Ident0());
      if (hi-lo==1 && type[lo]==iUntilTok)
        values.add(Ident1());
      if (hi-lo==1 && type[lo]==iThenTok)
        values.add(Ident2());
      if (hi-lo==1 && type[lo]==iIdentTok)
        values.add(Ident3((IdentTok)input[lo]));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iIdent<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpHighNA(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iIdent<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpHighNA0((String)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpHigh__DotTok<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iOption_TypeArgs__Ident<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNA1((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpHigh__ColonColonTok<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iOption_TypeArgs__Ident<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNA2((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpHigh__Left<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iList_ExpAssignNC__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNA3((Tuple2)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iLit<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpHighNA4((ALit)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpHigh__ColonColonTok<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iOption_TypeArgs__NewTok<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNA5((AExp)values.get((int)(s1>>32)+k1),(Option)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpHigh<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iTypeArgs<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNA6((AExp)values.get((int)(s1>>32)+k1),(KList)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpHighNA<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpHighNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iLeftNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts2_ExpNew__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNP0((Group)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iLeftNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpCond_ExpNew__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNP1((Group)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iLeftNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNP2((Group)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iLeftNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas2_ExpCond_ExpJuxt__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNP3((Group)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpHighNA<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpHighNP4((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpHighNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpHigh(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpHighNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpHigh0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpParens<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpHigh1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpHigh<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iQuestionTok) {
        final long s1 = slices.get(iWildcardBounds<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpNew0((Option)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1 && type[lo]==iNewTok) {
        final long s1 = slices.get(iOption_TypeArgs__ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpNew1((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpHigh<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpNew2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpNew<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpNew<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_ExpNew1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpUnary_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iLParenTok__Type<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight__ExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iPreOp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpNew1((UnaryOp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpUnary_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iPostOp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpNew2((AExp)values.get((int)(s1>>32)+k1),(UnaryOp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpUnary_ExpNew3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpUnary_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpMul_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iModTok__ExpUnary_ExpNew<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iDivTok__ExpUnary_ExpNew<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpNew1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMulTok__ExpUnary_ExpNew<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpNew2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpUnary_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpMul_ExpNew3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpMul_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAdd_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMinusTok__ExpMul_ExpNew<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iPlusTok__ExpMul_ExpNew<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpNew1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpMul_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAdd_ExpNew2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAdd_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpShift_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iUnsignedRShiftTok__ExpAdd_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRShiftTok__ExpAdd_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpNew1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iLShiftTok__ExpAdd_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpNew2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpAdd_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpShift_ExpNew3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpShift_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpRel_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iLtTok__ExpShift_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iInstanceofTok__Type<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpNew1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iGtTok__ExpShift_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpNew2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iGeTok__ExpShift_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpNew3((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpShift_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpRel_ExpNew4((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iLeTok__ExpShift_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpNew5((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpRel_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpEq_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iNeTok__ExpRel_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iEqEqTok__ExpRel_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpNew1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpRel_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpEq_ExpNew2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpEq_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAnd_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iAndTok__ExpEq_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAnd_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpEq_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAnd_ExpNew1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAnd_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpXor_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpXor_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iXorTok__ExpAnd_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpXor_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpAnd_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpXor_ExpNew1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpXor_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOr_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iOrTok__ExpXor_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOr_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpXor_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOr_ExpNew1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOr_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAndAnd_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAndAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iAndAndTok__ExpOr_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAndAnd_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpOr_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAndAnd_ExpNew1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAndAnd_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOrOr_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iOrOrTok__ExpAndAnd_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOrOr_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpAndAnd_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOrOr_ExpNew1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOrOr_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpCond_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpOrOr_ExpJuxt__QuestionTok<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssign__ColonTok__ExpCond_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpCond_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpOrOr_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpCond_ExpNew1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpCond_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpNew<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iSingleJuxt1_ExpNewNA<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(KList)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpUnary_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iLParenTok__Type<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight__ExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iPreOp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxt1((UnaryOp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpUnary_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iPostOp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxt2((AExp)values.get((int)(s1>>32)+k1),(UnaryOp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpUnary_ExpJuxt3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpUnary_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpMul_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iModTok__ExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iDivTok__ExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxt1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMulTok__ExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxt2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpUnary_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpMul_ExpJuxt3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpMul_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAdd_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMinusTok__ExpMul_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iPlusTok__ExpMul_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpJuxt1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAdd_ExpJuxt2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAdd_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpShift_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iUnsignedRShiftTok__ExpAdd_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRShiftTok__ExpAdd_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxt1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iLShiftTok__ExpAdd_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxt2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpShift_ExpJuxt3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpShift_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpRel_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iLtTok__ExpShift_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iInstanceofTok__Type<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxt1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iGtTok__ExpShift_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxt2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iGeTok__ExpShift_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxt3((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpRel_ExpJuxt4((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iLeTok__ExpShift_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxt5((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpRel_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpEq_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iNeTok__ExpRel_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iEqEqTok__ExpRel_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpJuxt1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpEq_ExpJuxt2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpEq_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAnd_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iAndTok__ExpEq_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAnd_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAnd_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAnd_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpXor_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpXor_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iXorTok__ExpAnd_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpXor_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpAnd_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpXor_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpXor_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOr_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iOrTok__ExpXor_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOr_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpXor_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOr_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOr_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAndAnd_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAndAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iAndAndTok__ExpOr_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAndAnd_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpOr_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAndAnd_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAndAnd_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOrOr_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iOrOrTok__ExpAndAnd_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOrOr_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpAndAnd_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOrOr_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOrOr_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpCond_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpOrOr_ExpJuxt__QuestionTok<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssign__ColonTok__ExpCond_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpCond_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpCond_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpCond_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iAssignOp__ExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAssignNC0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpCond_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAssignNC1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List1_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iJuxts2_ExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_ExpAssignNC0((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iCommas2_ExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_ExpAssignNC1((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_ExpAssignNC2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList1_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iList1_ExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List_ExpAssignNC0((KList)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas1_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAssignNC<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommaTok__Commas1_ExpAssignNC<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas1_ExpAssignNC0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas1_ExpAssignNC1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas1_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas0_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iCommas1_ExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas0_ExpAssignNC0((List)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas0_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAssignNC<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpAssignNC<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_ExpAssignNC0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_ExpAssignNC1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpCommas(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iCommas2_ExpCond_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpCommas0((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpCond_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpCommas1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpCommas<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAssign(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iAssignOp__ExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAssign0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpCommas<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAssign1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAssign<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void StmtHelperBS(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iReturnTok) {
        final long s1 = slices.get(iOption_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS0((Option)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iJuxts0_Mod<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iType__List1_VarDecl<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS1((List)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iWhileUntil<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssignNP<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS2((java.lang.Boolean)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iWhileUntil__ExpAssignNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iDoTok__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS3((Tuple2)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1 && type[lo]==iIfTok) {
        final long s1 = slices.get(iExpAssignNP<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS4((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iIfTok__ParenExp__MaybeThen<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeStmt__ElseTok__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS5((Tuple2)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iDoTok__MaybeStmt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iWhileUntil__MaybeParenExp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS6((AStmt)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iIfTok__ExpAssignNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iThenTok__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS7((AExp)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1 && type[lo]==iAssertTok) {
        final long s1 = slices.get(iExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS8((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iForTok__Left<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iForInfo__Right__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS9((Group)values.get((int)(s1>>32)+k1),(Tuple3)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iWhileUntil__ParenExp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeDo__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS10((Tuple2)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iForTok__ForInfo<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iDoTok__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS11((ForInfo)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1 && type[lo]==iSynchronizedTok) {
        final long s1 = slices.get(iMaybeParenExp__Block<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS12((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpAssign<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS13((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iAssertTok__ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iColonTok__ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS14((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iBlock<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS15((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iIfTok__ParenExp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeThen__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS16((Tuple2)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1 && type[lo]==iIfTok) {
        final long s1 = slices.get(iExpAssignNP<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS17((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1 && type[lo]==iThrowTok) {
        final long s1 = slices.get(iExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS18((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iIfTok__ExpAssignNP__ThenTok<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeStmt__ElseTok__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS19((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1 && type[lo]==iBreakTok) {
        final long s1 = slices.get(iOption_Ident<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS20((Option)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1 && type[lo]==iContinueTok) {
        final long s1 = slices.get(iOption_Ident<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS21((Option)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iStmtHelperBS<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas1_StmtHelperBS(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iStmtHelperBS<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommaTok__Commas1_StmtHelperBS<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas1_StmtHelperBS0((AStmt)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iStmtHelperBS<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas1_StmtHelperBS1((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas1_StmtHelperBS<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas0_StmtHelperBS(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iCommas1_StmtHelperBS<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas0_StmtHelperBS0((List)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas0_StmtHelperBS<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void StmtHelper(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iStmtHelperBS<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelper0((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iWhileUntil<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeParenExp__MaybeDo<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelper1((java.lang.Boolean)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1 && type[lo]==iIfTok) {
        final long s1 = slices.get(iMaybeParenExp__MaybeThen<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelper2((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1 && type[lo]==iSynchronizedTok) {
        final long s1 = slices.get(iMaybeParenExp<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelper3((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iIfTok__ExpAssignNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iThenTok__MaybeStmt__ElseTok<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelper4((AExp)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iIfTok__ParenExp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeThen__MaybeStmt__ElseTok<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelper5((Tuple2)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iForTok__Left<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iForInfo__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelper6((Group)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1 && type[lo]==iForTok) {
        final long s1 = slices.get(iForInfo<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelper7((ForInfo)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iStmtHelper<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Stmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[hi-1]==iSemiTok) {
        final long s1 = slices.get(iStmtHelperBS<<24|lo<<12|hi-1);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Stmt0((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iStmtHelper<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Stmt1((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo==1 && type[lo]==iSemiTok)
        values.add(Stmt2());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iStmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeDo__Stmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iMaybeDo<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k3=0;k3<(s3&vMask);k3++)
              values.add(MaybeDo__Stmt0((AStmt)values.get((int)(s3>>32)+k3)));
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeDo__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeThen__Stmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iMaybeThen<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k3=0;k3<(s3&vMask);k3++)
              values.add(MaybeThen__Stmt0((AStmt)values.get((int)(s3>>32)+k3)));
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeThen__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeStmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iStmt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(MaybeStmt0((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeStmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Stmts(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iStmtHelperBS<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iSemiTok__Stmts<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Stmts0((AStmt)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iStmtHelper<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Stmts1((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1 && type[lo]==iSemiTok) {
        final long s1 = slices.get(iStmts<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Stmts2((List)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iStmts<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_ExpAssign(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpAssign<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Option_ExpAssign0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_ExpAssign<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas1_ExpCond_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpCond_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommaTok__Commas1_ExpCond_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas1_ExpCond_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpCond_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas1_ExpCond_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas1_ExpCond_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_TypeArgs__ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iOption_TypeArgs<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Option_TypeArgs__ExpJuxt0((Option)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_TypeArgs__ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Option_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iQuestionTok) {
        final long s1 = slices.get(iWildcardBounds<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Type0((Option)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpHigh<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Type1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iType<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas1_Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iType<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommaTok__Commas1_Type<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas1_Type0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iType<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas1_Type1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas1_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iType<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Option_Type0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts0_Mod__Option_Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iJuxts0_Mod<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iOption_Type<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts0_Mod__Option_Type0((List)values.get((int)(s1>>32)+k1),(Option)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts0_Mod__Option_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List1_Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iJuxts2_Type<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_Type0((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iCommas2_Type<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_Type1((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iType<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_Type2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList1_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List_Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iList1_Type<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List_Type0((KList)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iType<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_Type<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_Type0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iType<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_Type1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpNewNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iQuestionTok) {
        final long s1 = slices.get(iWildcardBounds<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpNewNP0((Option)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1 && type[lo]==iNewTok) {
        final long s1 = slices.get(iOption_TypeArgs__ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpNewNP1((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpHighNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpNewNP2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpNewNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpNew<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iSingleJuxt1_ExpNewNA<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(KList)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpNewNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpUnary_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iLParenTok__Type<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight__ExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iPreOp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxtNP1((UnaryOp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpUnary_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iPostOp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k1),(UnaryOp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpUnary_ExpJuxtNP3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpUnary_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpMul_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iModTok__ExpUnary_ExpJuxtNP<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iDivTok__ExpUnary_ExpJuxtNP<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMulTok__ExpUnary_ExpJuxtNP<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpUnary_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpMul_ExpJuxtNP3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpMul_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAdd_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMinusTok__ExpMul_ExpJuxtNP<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iPlusTok__ExpMul_ExpJuxtNP<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpMul_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAdd_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAdd_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpShift_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iUnsignedRShiftTok__ExpAdd_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRShiftTok__ExpAdd_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iLShiftTok__ExpAdd_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpAdd_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpShift_ExpJuxtNP3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpShift_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpRel_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iLtTok__ExpShift_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iInstanceofTok__Type<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iGtTok__ExpShift_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iGeTok__ExpShift_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxtNP3((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpShift_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpRel_ExpJuxtNP4((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iLeTok__ExpShift_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxtNP5((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpRel_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpEq_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iNeTok__ExpRel_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iEqEqTok__ExpRel_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpRel_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpEq_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpEq_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAnd_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iAndTok__ExpEq_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAnd_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpEq_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAnd_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAnd_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpXor_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpXor_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iXorTok__ExpAnd_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpXor_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpAnd_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpXor_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpXor_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOr_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iOrTok__ExpXor_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOr_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpXor_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOr_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOr_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAndAnd_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpAndAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iAndAndTok__ExpOr_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAndAnd_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpOr_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAndAnd_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAndAnd_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOrOr_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iOrOrTok__ExpAndAnd_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOrOr_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpAndAnd_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOrOr_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOrOr_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpCond_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpOrOr_ExpJuxt__QuestionTok<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssign__ColonTok__ExpCond_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpCond_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpOrOr_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpCond_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpCond_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAssignNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iAssignOp__ExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAssignNP0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpCond_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAssignNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAssignNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeParenExp(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iParenExp<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(MaybeParenExp0((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpAssignNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(MaybeParenExp1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeParenExp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeParenExp__MaybeThen(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iMaybeParenExp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeThen<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++)
              values.add(MaybeParenExp__MaybeThen0((Tuple2)values.get((int)(s1>>32)+k1)));
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeParenExp__MaybeThen<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeParenExp__MaybeDo(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iMaybeParenExp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeDo<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++)
              values.add(MaybeParenExp__MaybeDo0((Tuple2)values.get((int)(s1>>32)+k1)));
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeParenExp__MaybeDo<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpNewNA(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iQuestionTok) {
        final long s1 = slices.get(iWildcardBounds<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpNewNA0((Option)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1 && type[lo]==iNewTok) {
        final long s1 = slices.get(iOption_TypeArgs__ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpNewNA1((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpHighNA<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpNewNA2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpNewNA<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_ExpNewNA(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iExpNewNA<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpNewNA<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_ExpNewNA0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpNewNA<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_ExpNewNA1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_ExpNewNA<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void SingleJuxt1_ExpNewNA(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iJuxts2_ExpNewNA<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(SingleJuxt1_ExpNewNA0((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iExpNewNA<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(SingleJuxt1_ExpNewNA1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iSingleJuxt1_ExpNewNA<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_Ident(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iIdent<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Option_Ident0((String)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_Ident<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_TypeArgs__Ident(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iOption_TypeArgs<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iIdent<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Option_TypeArgs__Ident0((Option)values.get((int)(s1>>32)+k1),(String)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_TypeArgs__Ident<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void IdentDims(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iIdentDims<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iLBrackTok__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(IdentDims0((Tuple2)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iIdent<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(IdentDims1((String)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iIdentDims<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void VarDecl(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iIdentDims<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iEqTok__ExpCommas<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(VarDecl0((Tuple2)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iIdentDims<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(VarDecl1((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iVarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_VarDecl(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iVarDecl<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_VarDecl<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_VarDecl0((Tuple3)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iVarDecl<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_VarDecl1((Tuple3)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas1_VarDecl(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iVarDecl<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommaTok__Commas1_VarDecl<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas1_VarDecl0((Tuple3)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iVarDecl<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas1_VarDecl1((Tuple3)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas1_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForeachSep(final int lo, final int hi) {
      boolean found = false;
      if (hi-lo==1 && type[lo]==iInTok)
        found = true;
      if (hi-lo==1 && type[lo]==iColonTok)
        found = true;
      if (found) { slices.put(iForeachSep<<24|lo<<12|hi,1); }
    }
    
    private void ExpHigh__ColonColonTok(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[hi-1]==iColonColonTok) {
        final long s1 = slices.get(iExpHigh<<24|lo<<12|hi-1);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpHigh__ColonColonTok0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpHigh__ColonColonTok<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas2_VarDecl(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iVarDecl<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommaTok__Commas1_VarDecl<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas2_VarDecl0((Tuple3)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas2_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List1_VarDecl(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        final long s1 = slices.get(iJuxts2_VarDecl<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_VarDecl0((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iCommas2_VarDecl<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_VarDecl1((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=0) {
        final long s1 = slices.get(iVarDecl<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_VarDecl2((Tuple3)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList1_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void WhileUntil__MaybeParenExp(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iWhileUntil<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeParenExp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(WhileUntil__MaybeParenExp0((java.lang.Boolean)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iWhileUntil__MaybeParenExp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForTok__ForInfo(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iForTok) {
        final long s1 = slices.get(iForInfo<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ForTok__ForInfo0((ForInfo)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iForTok__ForInfo<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void GtTok__ExpShift_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iGtTok) {
        final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(GtTok__ExpShift_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iGtTok__ExpShift_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void WhileUntil__ExpAssignNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iWhileUntil<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssignNP<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(WhileUntil__ExpAssignNP0((java.lang.Boolean)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iWhileUntil__ExpAssignNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_ExpNew__Right(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iJuxts2_ExpNew<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_ExpNew__Right0((List)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_ExpNew__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_TypeArgs__NewTok(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[hi-1]==iNewTok) {
        final long s1 = slices.get(iOption_TypeArgs<<24|lo<<12|hi-1);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Option_TypeArgs__NewTok0((Option)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_TypeArgs__NewTok<<24|lo<<12|hi,(long)prev<<32|count); }
    }
  }
}
