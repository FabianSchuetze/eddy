// Autogenerated by ambiguity: DO NOT EDIT!
package tarski;
import tarski.Tokens.*;
import tarski.AST.*;
import tarski.Types.*;
import tarski.Operators.*;

// Internal imports
import scala.collection.immutable.*;
import gnu.trove.TIntLongHashMap;
import java.util.ArrayList;
import scala.Tuple2;
import scala.Tuple3;
import scala.Option;
import static tarski.ParseEddyActions.*;

class ParseEddy {
  // Parse a token stream
  public static List<List<AStmt>> parse(List<Token> input) {
    return new Parser(input).toplevel();
  }
  
  private static final class Parser {
    private final int n;
    private final Token[] input;
    private final byte[] type;
    private final ArrayList<Object> values = new ArrayList<Object>();
    private final TIntLongHashMap slices = new TIntLongHashMap(); // (non,lo,hi) => (start,size)
    private final static long vMask = (1L<<32)-1;
    
    // Convert input and allocate working memory
    Parser(List<Token> _input) {
      n = _input.size();
      assert n+1<(1<<12);
      input = new Token[n];
      for (int i=0;i<n;i++) {
        input[i] = _input.head();
        _input = (List<Token>)_input.tail();
      }
      type = new byte[n];
    }
    
    // The entire parse
    List<List<AStmt>> toplevel() {
      // Parse
      types();
      nulls();
      nonnulls();
      
      // All done!
      final long s = slices.get(iStmts<<24|n);
      List<List<AStmt>> xs = (List)Nil$.MODULE$;
      for (int k=0;k<(s&vMask);k++)
        xs = $colon$colon$.MODULE$.<List<AStmt>>apply((List)values.get((int)(s>>32)+k),xs);
      return xs;
    }
    
    // Symbol ids
    private static final int iPlusEqTok = 0;
    private static final int iOrTok = 1;
    private static final int iSynchronizedTok = 2;
    private static final int iUntilTok = 3;
    private static final int iModTok = 4;
    private static final int iCommaTok = 5;
    private static final int iInTok = 6;
    private static final int iSuperTok = 7;
    private static final int iCompTok = 8;
    private static final int iAbstractTok = 9;
    private static final int iProtectedTok = 10;
    private static final int iStringLitTok = 11;
    private static final int iDotTok = 12;
    private static final int iNotTok = 13;
    private static final int iColonTok = 14;
    private static final int iInstanceofTok = 15;
    private static final int iReturnTok = 16;
    private static final int iFinalTok = 17;
    private static final int iFloatLitTok = 18;
    private static final int iUnsignedRShiftTok = 19;
    private static final int iLeTok = 20;
    private static final int iIdentTok = 21;
    private static final int iTransientTok = 22;
    private static final int iUnsignedRShiftEqTok = 23;
    private static final int iLtTok = 24;
    private static final int iIntLitTok = 25;
    private static final int iColonColonTok = 26;
    private static final int iAndAndTok = 27;
    private static final int iRShiftEqTok = 28;
    private static final int iContinueTok = 29;
    private static final int iVolatileTok = 30;
    private static final int iRCurlyTok = 31;
    private static final int iNewTok = 32;
    private static final int iLCurlyTok = 33;
    private static final int iXorEqTok = 34;
    private static final int iEqTok = 35;
    private static final int iPrivateTok = 36;
    private static final int iBreakTok = 37;
    private static final int iLParenTok = 38;
    private static final int iWhileTok = 39;
    private static final int iMulTok = 40;
    private static final int iDoTok = 41;
    private static final int iDivTok = 42;
    private static final int iDoubleLitTok = 43;
    private static final int iPlusPlusTok = 44;
    private static final int iSemiTok = 45;
    private static final int iStaticTok = 46;
    private static final int iLBrackTok = 47;
    private static final int iXorTok = 48;
    private static final int iMinusMinusTok = 49;
    private static final int iRBrackTok = 50;
    private static final int iNeTok = 51;
    private static final int iRParenTok = 52;
    private static final int iIfTok = 53;
    private static final int iAndEqTok = 54;
    private static final int iCharLitTok = 55;
    private static final int iMinusEqTok = 56;
    private static final int iForTok = 57;
    private static final int iGtTok = 58;
    private static final int iStrictfpTok = 59;
    private static final int iEqEqTok = 60;
    private static final int iExtendsTok = 61;
    private static final int iGeTok = 62;
    private static final int iThrowTok = 63;
    private static final int iElseTok = 64;
    private static final int iThenTok = 65;
    private static final int iQuestionTok = 66;
    private static final int iAssertTok = 67;
    private static final int iAndTok = 68;
    private static final int iRShiftTok = 69;
    private static final int iOrEqTok = 70;
    private static final int iLShiftEqTok = 71;
    private static final int iLShiftTok = 72;
    private static final int iModEqTok = 73;
    private static final int iPlusTok = 74;
    private static final int iOrOrTok = 75;
    private static final int iLongLitTok = 76;
    private static final int iAtTok = 77;
    private static final int iMulEqTok = 78;
    private static final int iPublicTok = 79;
    private static final int iMinusTok = 80;
    private static final int iDivEqTok = 81;
    private static final int iCommas2_ExpAssignNC = 0;
    private static final int iIfTok__ExpAssignNP = 1;
    private static final int iMaybeThen__MaybeStmt__ElseTok = 2;
    private static final int iRight__ExpUnary_ExpJuxt = 3;
    private static final int iExpCond_ExpNew__Right = 4;
    private static final int iExpHigh__Left = 5;
    private static final int iType__List1_VarDecl = 6;
    private static final int iIdentDims__ForeachSep__ExpAssign = 7;
    private static final int iJuxts2_ExpAssignNC = 8;
    private static final int iDotTok__Option_TypeArgs__Ident = 9;
    private static final int iAssignOp = 10;
    private static final int iForInfo__Right = 11;
    private static final int iForeachSep__ExpAssign = 12;
    private static final int iMaybeStmt__ElseTok__Stmt = 13;
    private static final int iForTok__Left__ForInfo = 14;
    private static final int iWildcardBounds = 15;
    private static final int iPreOp = 16;
    private static final int iCommas2_ExpCond_ExpJuxt__Right = 17;
    private static final int iThenTok__MaybeStmt__ElseTok__Stmt = 18;
    private static final int iParenExp = 19;
    private static final int iJuxts2_ExpNew = 20;
    private static final int iIfTok__ParenExp = 21;
    private static final int iPostOp = 22;
    private static final int iCommas2_Type = 23;
    private static final int iColonColonTok__Option_TypeArgs__Ident = 24;
    private static final int iJuxts2_ExpNewNA = 25;
    private static final int iExpParens = 26;
    private static final int iTypeArgs = 27;
    private static final int iOption_TypeArgs = 28;
    private static final int iJuxts2_VarDecl = 29;
    private static final int iMaybeThen = 30;
    private static final int iLeftNP = 31;
    private static final int iQuestionTok__ExpAssign__ColonTok__ExpCond_ExpJuxt = 32;
    private static final int iForTok__Left = 33;
    private static final int iExpAssign__Right = 34;
    private static final int iLeft = 35;
    private static final int iWhileUntil = 36;
    private static final int iMod = 37;
    private static final int iJuxts1_Mod = 38;
    private static final int iJuxts0_Mod = 39;
    private static final int iExpAssignNP__DoTok__Stmt = 40;
    private static final int iDoTok__MaybeStmt = 41;
    private static final int iRight__Stmt = 42;
    private static final int iCommas2_ExpCond_ExpJuxt = 43;
    private static final int iJuxts2_Type = 44;
    private static final int iLParenTok__Type = 45;
    private static final int iAssignOp__ExpAssign = 46;
    private static final int iIfTok__ParenExp__MaybeThen = 47;
    private static final int iLit = 48;
    private static final int iMaybeDo = 49;
    private static final int iWhileUntil__ParenExp = 50;
    private static final int iBlock = 51;
    private static final int iRight = 52;
    private static final int iList_ExpAssignNC__Right = 53;
    private static final int iIdent = 54;
    private static final int iExpHighNA = 55;
    private static final int iExpHighNP = 56;
    private static final int iExpHigh = 57;
    private static final int iExpNew = 58;
    private static final int iJuxts1_ExpNew = 59;
    private static final int iExpUnary_ExpNew = 60;
    private static final int iExpMul_ExpNew = 61;
    private static final int iExpAdd_ExpNew = 62;
    private static final int iExpShift_ExpNew = 63;
    private static final int iExpRel_ExpNew = 64;
    private static final int iExpEq_ExpNew = 65;
    private static final int iExpAnd_ExpNew = 66;
    private static final int iExpXor_ExpNew = 67;
    private static final int iExpOr_ExpNew = 68;
    private static final int iExpAndAnd_ExpNew = 69;
    private static final int iExpOrOr_ExpNew = 70;
    private static final int iExpCond_ExpNew = 71;
    private static final int iExpJuxt = 72;
    private static final int iExpUnary_ExpJuxt = 73;
    private static final int iExpMul_ExpJuxt = 74;
    private static final int iExpAdd_ExpJuxt = 75;
    private static final int iExpShift_ExpJuxt = 76;
    private static final int iExpRel_ExpJuxt = 77;
    private static final int iExpEq_ExpJuxt = 78;
    private static final int iExpAnd_ExpJuxt = 79;
    private static final int iExpXor_ExpJuxt = 80;
    private static final int iExpOr_ExpJuxt = 81;
    private static final int iExpAndAnd_ExpJuxt = 82;
    private static final int iExpOrOr_ExpJuxt = 83;
    private static final int iExpCond_ExpJuxt = 84;
    private static final int iExpAssignNC = 85;
    private static final int iList1_ExpAssignNC = 86;
    private static final int iList_ExpAssignNC = 87;
    private static final int iCommas1_ExpAssignNC = 88;
    private static final int iCommas0_ExpAssignNC = 89;
    private static final int iJuxts1_ExpAssignNC = 90;
    private static final int iExpCommas = 91;
    private static final int iExpAssign = 92;
    private static final int iStmtHelperBS = 93;
    private static final int iCommas1_StmtHelperBS = 94;
    private static final int iCommas0_StmtHelperBS = 95;
    private static final int iStmtHelper = 96;
    private static final int iStmt = 97;
    private static final int iMaybeDo__Stmt = 98;
    private static final int iMaybeThen__Stmt = 99;
    private static final int iMaybeStmt = 100;
    private static final int iStmts = 101;
    private static final int iOption_ExpAssign = 102;
    private static final int iCommas1_ExpCond_ExpJuxt = 103;
    private static final int iOption_ExpJuxt = 104;
    private static final int iType = 105;
    private static final int iCommas1_Type = 106;
    private static final int iOption_Type = 107;
    private static final int iJuxts0_Mod__Option_Type = 108;
    private static final int iList1_Type = 109;
    private static final int iList_Type = 110;
    private static final int iJuxts1_Type = 111;
    private static final int iExpNewNP = 112;
    private static final int iExpJuxtNP = 113;
    private static final int iExpUnary_ExpJuxtNP = 114;
    private static final int iExpMul_ExpJuxtNP = 115;
    private static final int iExpAdd_ExpJuxtNP = 116;
    private static final int iExpShift_ExpJuxtNP = 117;
    private static final int iExpRel_ExpJuxtNP = 118;
    private static final int iExpEq_ExpJuxtNP = 119;
    private static final int iExpAnd_ExpJuxtNP = 120;
    private static final int iExpXor_ExpJuxtNP = 121;
    private static final int iExpOr_ExpJuxtNP = 122;
    private static final int iExpAndAnd_ExpJuxtNP = 123;
    private static final int iExpOrOr_ExpJuxtNP = 124;
    private static final int iExpCond_ExpJuxtNP = 125;
    private static final int iExpAssignNP = 126;
    private static final int iMaybeParenExp = 127;
    private static final int iMaybeParenExp__MaybeDo = 128;
    private static final int iExpNewNA = 129;
    private static final int iJuxts1_ExpNewNA = 130;
    private static final int iSingleJuxt1_ExpNewNA = 131;
    private static final int iOption_Ident = 132;
    private static final int iIdentDims = 133;
    private static final int iVarDecl = 134;
    private static final int iJuxts1_VarDecl = 135;
    private static final int iCommas1_VarDecl = 136;
    private static final int iForeachSep = 137;
    private static final int iSemiTok__Option_ExpAssign__SemiTok__Commas0_ExpAssignNC = 138;
    private static final int iForInfo = 139;
    private static final int iCommas2_VarDecl = 140;
    private static final int iList1_VarDecl = 141;
    private static final int iWhileUntil__MaybeParenExp = 142;
    private static final int iJuxts2_ExpNew__Right = 143;
    
    // Determine token types
    private void types() {
      for (int i=0;i<n;i++) {
        final Token t = input[i];
        type[i] = (byte)(
            t instanceof PlusEqTok$ ? iPlusEqTok
          : t instanceof OrTok$ ? iOrTok
          : t instanceof SynchronizedTok$ ? iSynchronizedTok
          : t instanceof UntilTok$ ? iUntilTok
          : t instanceof ModTok$ ? iModTok
          : t instanceof CommaTok$ ? iCommaTok
          : t instanceof InTok$ ? iInTok
          : t instanceof SuperTok$ ? iSuperTok
          : t instanceof CompTok$ ? iCompTok
          : t instanceof AbstractTok$ ? iAbstractTok
          : t instanceof ProtectedTok$ ? iProtectedTok
          : t instanceof StringLitTok ? iStringLitTok
          : t instanceof DotTok$ ? iDotTok
          : t instanceof NotTok$ ? iNotTok
          : t instanceof ColonTok$ ? iColonTok
          : t instanceof InstanceofTok$ ? iInstanceofTok
          : t instanceof ReturnTok$ ? iReturnTok
          : t instanceof FinalTok$ ? iFinalTok
          : t instanceof FloatLitTok ? iFloatLitTok
          : t instanceof UnsignedRShiftTok$ ? iUnsignedRShiftTok
          : t instanceof LeTok$ ? iLeTok
          : t instanceof IdentTok ? iIdentTok
          : t instanceof TransientTok$ ? iTransientTok
          : t instanceof UnsignedRShiftEqTok$ ? iUnsignedRShiftEqTok
          : t instanceof LtTok$ ? iLtTok
          : t instanceof IntLitTok ? iIntLitTok
          : t instanceof ColonColonTok$ ? iColonColonTok
          : t instanceof AndAndTok$ ? iAndAndTok
          : t instanceof RShiftEqTok$ ? iRShiftEqTok
          : t instanceof ContinueTok$ ? iContinueTok
          : t instanceof VolatileTok$ ? iVolatileTok
          : t instanceof RCurlyTok$ ? iRCurlyTok
          : t instanceof NewTok$ ? iNewTok
          : t instanceof LCurlyTok$ ? iLCurlyTok
          : t instanceof XorEqTok$ ? iXorEqTok
          : t instanceof EqTok$ ? iEqTok
          : t instanceof PrivateTok$ ? iPrivateTok
          : t instanceof BreakTok$ ? iBreakTok
          : t instanceof LParenTok$ ? iLParenTok
          : t instanceof WhileTok$ ? iWhileTok
          : t instanceof MulTok$ ? iMulTok
          : t instanceof DoTok$ ? iDoTok
          : t instanceof DivTok$ ? iDivTok
          : t instanceof DoubleLitTok ? iDoubleLitTok
          : t instanceof PlusPlusTok$ ? iPlusPlusTok
          : t instanceof SemiTok$ ? iSemiTok
          : t instanceof StaticTok$ ? iStaticTok
          : t instanceof LBrackTok$ ? iLBrackTok
          : t instanceof XorTok$ ? iXorTok
          : t instanceof MinusMinusTok$ ? iMinusMinusTok
          : t instanceof RBrackTok$ ? iRBrackTok
          : t instanceof NeTok$ ? iNeTok
          : t instanceof RParenTok$ ? iRParenTok
          : t instanceof IfTok$ ? iIfTok
          : t instanceof AndEqTok$ ? iAndEqTok
          : t instanceof CharLitTok ? iCharLitTok
          : t instanceof MinusEqTok$ ? iMinusEqTok
          : t instanceof ForTok$ ? iForTok
          : t instanceof GtTok$ ? iGtTok
          : t instanceof StrictfpTok$ ? iStrictfpTok
          : t instanceof EqEqTok$ ? iEqEqTok
          : t instanceof ExtendsTok$ ? iExtendsTok
          : t instanceof GeTok$ ? iGeTok
          : t instanceof ThrowTok$ ? iThrowTok
          : t instanceof ElseTok$ ? iElseTok
          : t instanceof ThenTok$ ? iThenTok
          : t instanceof QuestionTok$ ? iQuestionTok
          : t instanceof AssertTok$ ? iAssertTok
          : t instanceof AndTok$ ? iAndTok
          : t instanceof RShiftTok$ ? iRShiftTok
          : t instanceof OrEqTok$ ? iOrEqTok
          : t instanceof LShiftEqTok$ ? iLShiftEqTok
          : t instanceof LShiftTok$ ? iLShiftTok
          : t instanceof ModEqTok$ ? iModEqTok
          : t instanceof PlusTok$ ? iPlusTok
          : t instanceof OrOrTok$ ? iOrOrTok
          : t instanceof LongLitTok ? iLongLitTok
          : t instanceof AtTok$ ? iAtTok
          : t instanceof MulEqTok$ ? iMulEqTok
          : t instanceof PublicTok$ ? iPublicTok
          : t instanceof MinusTok$ ? iMinusTok
          : t instanceof DivEqTok$ ? iDivEqTok
          : 255);
      }
    }
    
    // Parse null productions
    private void nulls() {
      long slice;
      int next = values.size();
      values.add(WildcardBounds3()); // WildcardBounds -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iWildcardBounds<<24|i<<12|i,slice);
      values.add(Option_TypeArgs1()); // Option_TypeArgs -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iOption_TypeArgs<<24|i<<12|i,slice);
      // MaybeThen is simple
      for (int i=0;i<=n;i++) slices.put(iMaybeThen<<24|i<<12|i,1);
      values.add(Juxts0_Mod1()); // Juxts0_Mod -> "" : Nil
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iJuxts0_Mod<<24|i<<12|i,slice);
      // MaybeDo is simple
      for (int i=0;i<=n;i++) slices.put(iMaybeDo<<24|i<<12|i,1);
      values.add(List_ExpAssignNC1()); // List_ExpAssignNC -> "" : EmptyList
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iList_ExpAssignNC<<24|i<<12|i,slice);
      values.add(Commas0_ExpAssignNC1()); // Commas0_ExpAssignNC -> "" : Nil
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iCommas0_ExpAssignNC<<24|i<<12|i,slice);
      values.add(Commas0_StmtHelperBS1()); // Commas0_StmtHelperBS -> "" : Nil
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iCommas0_StmtHelperBS<<24|i<<12|i,slice);
      values.add(MaybeStmt1()); // MaybeStmt -> "" : HoleAStmt
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iMaybeStmt<<24|i<<12|i,slice);
      values.add(Stmts3()); // Stmts -> "" : Nil
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iStmts<<24|i<<12|i,slice);
      values.add(Option_ExpAssign1()); // Option_ExpAssign -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iOption_ExpAssign<<24|i<<12|i,slice);
      values.add(Option_ExpJuxt1()); // Option_ExpJuxt -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iOption_ExpJuxt<<24|i<<12|i,slice);
      values.add(Option_Type1()); // Option_Type -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iOption_Type<<24|i<<12|i,slice);
      values.add(Juxts0_Mod__Option_Type0((List)values.get((int)(slices.get(iJuxts0_Mod<<24)>>32)),(Option)values.get((int)(slices.get(iOption_Type<<24)>>32)))); // Juxts0_Mod__Option_Type -> Juxts0_Mod Option_Type : ($1,$2)
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iJuxts0_Mod__Option_Type<<24|i<<12|i,slice);
      values.add(List_Type1()); // List_Type -> "" : EmptyList
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iList_Type<<24|i<<12|i,slice);
      values.add(Option_Ident1()); // Option_Ident -> "" : None
      slice = (long)next<<32|1; next += 1;
      for (int i=0;i<=n;i++) slices.put(iOption_Ident<<24|i<<12|i,slice);
    }
    
    // Parse nonnull productions
    private void nonnulls() {
      for (int lo=n;lo>=0;lo--) for (int hi=lo+1;hi<=n;hi++) {
        Commas2_ExpAssignNC(lo,hi);
        IfTok__ExpAssignNP(lo,hi);
        MaybeThen__MaybeStmt__ElseTok(lo,hi);
        Right__ExpUnary_ExpJuxt(lo,hi);
        ExpCond_ExpNew__Right(lo,hi);
        ExpHigh__Left(lo,hi);
        Type__List1_VarDecl(lo,hi);
        IdentDims__ForeachSep__ExpAssign(lo,hi);
        Juxts2_ExpAssignNC(lo,hi);
        DotTok__Option_TypeArgs__Ident(lo,hi);
        AssignOp(lo,hi);
        ForInfo__Right(lo,hi);
        ForeachSep__ExpAssign(lo,hi);
        MaybeStmt__ElseTok__Stmt(lo,hi);
        ForTok__Left__ForInfo(lo,hi);
        WildcardBounds(lo,hi);
        PreOp(lo,hi);
        Commas2_ExpCond_ExpJuxt__Right(lo,hi);
        ThenTok__MaybeStmt__ElseTok__Stmt(lo,hi);
        ParenExp(lo,hi);
        Juxts2_ExpNew(lo,hi);
        IfTok__ParenExp(lo,hi);
        PostOp(lo,hi);
        Commas2_Type(lo,hi);
        ColonColonTok__Option_TypeArgs__Ident(lo,hi);
        Juxts2_ExpNewNA(lo,hi);
        ExpParens(lo,hi);
        TypeArgs(lo,hi);
        Option_TypeArgs(lo,hi);
        Juxts2_VarDecl(lo,hi);
        MaybeThen(lo,hi);
        LeftNP(lo,hi);
        QuestionTok__ExpAssign__ColonTok__ExpCond_ExpJuxt(lo,hi);
        ForTok__Left(lo,hi);
        ExpAssign__Right(lo,hi);
        Left(lo,hi);
        WhileUntil(lo,hi);
        Mod(lo,hi);
        Juxts1_Mod(lo,hi);
        Juxts0_Mod(lo,hi);
        ExpAssignNP__DoTok__Stmt(lo,hi);
        DoTok__MaybeStmt(lo,hi);
        Right__Stmt(lo,hi);
        Commas2_ExpCond_ExpJuxt(lo,hi);
        Juxts2_Type(lo,hi);
        LParenTok__Type(lo,hi);
        AssignOp__ExpAssign(lo,hi);
        IfTok__ParenExp__MaybeThen(lo,hi);
        Lit(lo,hi);
        MaybeDo(lo,hi);
        WhileUntil__ParenExp(lo,hi);
        Block(lo,hi);
        Right(lo,hi);
        List_ExpAssignNC__Right(lo,hi);
        Ident(lo,hi);
        ExpHighNA(lo,hi);
        ExpHighNP(lo,hi);
        ExpHigh(lo,hi);
        ExpNew(lo,hi);
        Juxts1_ExpNew(lo,hi);
        ExpUnary_ExpNew(lo,hi);
        ExpMul_ExpNew(lo,hi);
        ExpAdd_ExpNew(lo,hi);
        ExpShift_ExpNew(lo,hi);
        ExpRel_ExpNew(lo,hi);
        ExpEq_ExpNew(lo,hi);
        ExpAnd_ExpNew(lo,hi);
        ExpXor_ExpNew(lo,hi);
        ExpOr_ExpNew(lo,hi);
        ExpAndAnd_ExpNew(lo,hi);
        ExpOrOr_ExpNew(lo,hi);
        ExpCond_ExpNew(lo,hi);
        ExpJuxt(lo,hi);
        ExpUnary_ExpJuxt(lo,hi);
        ExpMul_ExpJuxt(lo,hi);
        ExpAdd_ExpJuxt(lo,hi);
        ExpShift_ExpJuxt(lo,hi);
        ExpRel_ExpJuxt(lo,hi);
        ExpEq_ExpJuxt(lo,hi);
        ExpAnd_ExpJuxt(lo,hi);
        ExpXor_ExpJuxt(lo,hi);
        ExpOr_ExpJuxt(lo,hi);
        ExpAndAnd_ExpJuxt(lo,hi);
        ExpOrOr_ExpJuxt(lo,hi);
        ExpCond_ExpJuxt(lo,hi);
        ExpAssignNC(lo,hi);
        List1_ExpAssignNC(lo,hi);
        List_ExpAssignNC(lo,hi);
        Commas1_ExpAssignNC(lo,hi);
        Commas0_ExpAssignNC(lo,hi);
        Juxts1_ExpAssignNC(lo,hi);
        ExpCommas(lo,hi);
        ExpAssign(lo,hi);
        StmtHelperBS(lo,hi);
        Commas1_StmtHelperBS(lo,hi);
        Commas0_StmtHelperBS(lo,hi);
        StmtHelper(lo,hi);
        Stmt(lo,hi);
        MaybeDo__Stmt(lo,hi);
        MaybeThen__Stmt(lo,hi);
        MaybeStmt(lo,hi);
        Stmts(lo,hi);
        Option_ExpAssign(lo,hi);
        Commas1_ExpCond_ExpJuxt(lo,hi);
        Option_ExpJuxt(lo,hi);
        Type(lo,hi);
        Commas1_Type(lo,hi);
        Option_Type(lo,hi);
        Juxts0_Mod__Option_Type(lo,hi);
        List1_Type(lo,hi);
        List_Type(lo,hi);
        Juxts1_Type(lo,hi);
        ExpNewNP(lo,hi);
        ExpJuxtNP(lo,hi);
        ExpUnary_ExpJuxtNP(lo,hi);
        ExpMul_ExpJuxtNP(lo,hi);
        ExpAdd_ExpJuxtNP(lo,hi);
        ExpShift_ExpJuxtNP(lo,hi);
        ExpRel_ExpJuxtNP(lo,hi);
        ExpEq_ExpJuxtNP(lo,hi);
        ExpAnd_ExpJuxtNP(lo,hi);
        ExpXor_ExpJuxtNP(lo,hi);
        ExpOr_ExpJuxtNP(lo,hi);
        ExpAndAnd_ExpJuxtNP(lo,hi);
        ExpOrOr_ExpJuxtNP(lo,hi);
        ExpCond_ExpJuxtNP(lo,hi);
        ExpAssignNP(lo,hi);
        MaybeParenExp(lo,hi);
        MaybeParenExp__MaybeDo(lo,hi);
        ExpNewNA(lo,hi);
        Juxts1_ExpNewNA(lo,hi);
        SingleJuxt1_ExpNewNA(lo,hi);
        Option_Ident(lo,hi);
        IdentDims(lo,hi);
        VarDecl(lo,hi);
        Juxts1_VarDecl(lo,hi);
        Commas1_VarDecl(lo,hi);
        ForeachSep(lo,hi);
        SemiTok__Option_ExpAssign__SemiTok__Commas0_ExpAssignNC(lo,hi);
        ForInfo(lo,hi);
        Commas2_VarDecl(lo,hi);
        List1_VarDecl(lo,hi);
        WhileUntil__MaybeParenExp(lo,hi);
        Juxts2_ExpNew__Right(lo,hi);
      }
    }
    
    private void Commas2_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iExpAssignNC<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_ExpAssignNC<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas2_ExpAssignNC0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas2_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void IfTok__ExpAssignNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2 && type[lo]==iIfTok) {
        final long s1 = slices.get(iExpAssignNP<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(IfTok__ExpAssignNP0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iIfTok__ExpAssignNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeThen__MaybeStmt__ElseTok(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[hi-1]==iElseTok) {
        for (int j=lo;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iMaybeThen<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeStmt<<24|j<<12|hi-1); if (s3 == 0) continue;
            for (int k3=0;k3<(s3&vMask);k3++)
              values.add(MaybeThen__MaybeStmt__ElseTok0((AStmt)values.get((int)(s3>>32)+k3)));
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeThen__MaybeStmt__ElseTok<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Right__ExpUnary_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iRight<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Right__ExpUnary_ExpJuxt0((Group)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iRight__ExpUnary_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpCond_ExpNew__Right(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpCond_ExpNew<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpCond_ExpNew__Right0((AExp)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpCond_ExpNew__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpHigh__Left(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpHigh<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iLeft<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHigh__Left0((AExp)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpHigh__Left<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Type__List1_VarDecl(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iType<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iList1_VarDecl<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Type__List1_VarDecl0((AExp)values.get((int)(s1>>32)+k1),(KList)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iType__List1_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void IdentDims__ForeachSep__ExpAssign(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iIdentDims<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iForeachSep__ExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(IdentDims__ForeachSep__ExpAssign0((Tuple2)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iIdentDims__ForeachSep__ExpAssign<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpAssignNC<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpAssignNC<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_ExpAssignNC0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void DotTok__Option_TypeArgs__Ident(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2 && type[lo]==iDotTok) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iOption_TypeArgs<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iIdent<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(DotTok__Option_TypeArgs__Ident0((Option)values.get((int)(s1>>32)+k1),(String)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iDotTok__Option_TypeArgs__Ident<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void AssignOp(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iDivEqTok)
        values.add(AssignOp0());
      if (hi-lo==1 && type[lo]==iPlusEqTok)
        values.add(AssignOp1());
      if (hi-lo==1 && type[lo]==iUnsignedRShiftEqTok)
        values.add(AssignOp2());
      if (hi-lo==1 && type[lo]==iLShiftEqTok)
        values.add(AssignOp3());
      if (hi-lo==1 && type[lo]==iOrEqTok)
        values.add(AssignOp4());
      if (hi-lo==1 && type[lo]==iAndEqTok)
        values.add(AssignOp5());
      if (hi-lo==1 && type[lo]==iMulEqTok)
        values.add(AssignOp6());
      if (hi-lo==1 && type[lo]==iXorEqTok)
        values.add(AssignOp7());
      if (hi-lo==1 && type[lo]==iEqTok)
        values.add(AssignOp8());
      if (hi-lo==1 && type[lo]==iMinusEqTok)
        values.add(AssignOp9());
      if (hi-lo==1 && type[lo]==iRShiftEqTok)
        values.add(AssignOp10());
      if (hi-lo==1 && type[lo]==iModEqTok)
        values.add(AssignOp11());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iAssignOp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForInfo__Right(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+2;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iForInfo<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ForInfo__Right0((ForInfo)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iForInfo__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForeachSep__ExpAssign(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iForeachSep<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k3=0;k3<(s3&vMask);k3++)
              values.add(ForeachSep__ExpAssign0((AExp)values.get((int)(s3>>32)+k3)));
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iForeachSep__ExpAssign<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeStmt__ElseTok__Stmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo;j<=hi-2;j++) {
          if (type[j]==iElseTok) {
            final long s1 = slices.get(iMaybeStmt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(MaybeStmt__ElseTok__Stmt0((AStmt)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeStmt__ElseTok__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForTok__Left__ForInfo(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=4 && type[lo]==iForTok) {
        for (int j=lo+2;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iLeft<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iForInfo<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ForTok__Left__ForInfo0((Group)values.get((int)(s1>>32)+k1),(ForInfo)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iForTok__Left__ForInfo<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void WildcardBounds(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2 && type[lo]==iSuperTok) {
        final long s1 = slices.get(iType<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(WildcardBounds0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=2 && type[lo]==iColonTok) {
        final long s1 = slices.get(iType<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(WildcardBounds1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=2 && type[lo]==iExtendsTok) {
        final long s1 = slices.get(iType<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(WildcardBounds2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iWildcardBounds<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void PreOp(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iPlusPlusTok)
        values.add(PreOp0());
      if (hi-lo==1 && type[lo]==iCompTok)
        values.add(PreOp1());
      if (hi-lo==1 && type[lo]==iPlusTok)
        values.add(PreOp2());
      if (hi-lo==1 && type[lo]==iNotTok)
        values.add(PreOp3());
      if (hi-lo==1 && type[lo]==iMinusMinusTok)
        values.add(PreOp4());
      if (hi-lo==1 && type[lo]==iMinusTok)
        values.add(PreOp5());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iPreOp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas2_ExpCond_ExpJuxt__Right(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=4) {
        for (int j=lo+3;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iCommas2_ExpCond_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas2_ExpCond_ExpJuxt__Right0((List)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas2_ExpCond_ExpJuxt__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ThenTok__MaybeStmt__ElseTok__Stmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3 && type[lo]==iThenTok) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iElseTok) {
            final long s1 = slices.get(iMaybeStmt<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ThenTok__MaybeStmt__ElseTok__Stmt0((AStmt)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iThenTok__MaybeStmt__ElseTok__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ParenExp(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iLeft<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssign__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ParenExp0((Group)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iParenExp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpNew<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpNew<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void IfTok__ParenExp(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=4 && type[lo]==iIfTok) {
        final long s1 = slices.get(iParenExp<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(IfTok__ParenExp0((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iIfTok__ParenExp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void PostOp(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iMinusMinusTok)
        values.add(PostOp0());
      if (hi-lo==1 && type[lo]==iPlusPlusTok)
        values.add(PostOp1());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iPostOp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas2_Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iType<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_Type<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas2_Type0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas2_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ColonColonTok__Option_TypeArgs__Ident(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2 && type[lo]==iColonColonTok) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iOption_TypeArgs<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iIdent<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ColonColonTok__Option_TypeArgs__Ident0((Option)values.get((int)(s1>>32)+k1),(String)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iColonColonTok__Option_TypeArgs__Ident<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_ExpNewNA(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpNewNA<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpNewNA<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_ExpNewNA0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_ExpNewNA<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpParens(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=4 && type[lo]==iLParenTok) {
        for (int j=lo+3;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iJuxts2_ExpNew<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpParens0((List)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=5 && type[lo]==iLParenTok) {
        for (int j=lo+4;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iCommas2_ExpCond_ExpJuxt<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpParens1((List)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2 && type[lo]==iLParenTok) {
        final long s1 = slices.get(iRight<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpParens2((Group)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=3 && type[lo]==iLParenTok) {
        for (int j=lo+2;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpAssignNC<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpParens3((AExp)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpParens<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void TypeArgs(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2 && type[lo]==iLtTok && type[hi-1]==iGtTok) {
        final long s1 = slices.get(iList_Type<<24|lo+1<<12|hi-1);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(TypeArgs0((KList)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iTypeArgs<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_TypeArgs(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        final long s1 = slices.get(iTypeArgs<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Option_TypeArgs0((KList)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_TypeArgs<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_VarDecl(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iVarDecl<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_VarDecl<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_VarDecl0((Tuple3)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeThen(final int lo, final int hi) {
      boolean found = false;
      if (hi-lo==1 && type[lo]==iThenTok)
        found = true;
      if (found) { slices.put(iMaybeThen<<24|lo<<12|hi,1); }
    }
    
    private void LeftNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iLCurlyTok)
        values.add(LeftNP0());
      if (hi-lo==1 && type[lo]==iLBrackTok)
        values.add(LeftNP1());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iLeftNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void QuestionTok__ExpAssign__ColonTok__ExpCond_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=4 && type[lo]==iQuestionTok) {
        for (int j=lo+2;j<=hi-2;j++) {
          if (type[j]==iColonTok) {
            final long s1 = slices.get(iExpAssign<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpCond_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(QuestionTok__ExpAssign__ColonTok__ExpCond_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iQuestionTok__ExpAssign__ColonTok__ExpCond_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForTok__Left(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2 && type[lo]==iForTok) {
        final long s1 = slices.get(iLeft<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ForTok__Left0((Group)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iForTok__Left<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAssign__Right(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpAssign<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAssign__Right0((AExp)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAssign__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Left(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iLCurlyTok)
        values.add(Left0());
      if (hi-lo==1 && type[lo]==iLBrackTok)
        values.add(Left1());
      if (hi-lo==1 && type[lo]==iLParenTok)
        values.add(Left2());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iLeft<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void WhileUntil(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iUntilTok)
        values.add(WhileUntil0());
      if (hi-lo==1 && type[lo]==iWhileTok)
        values.add(WhileUntil1());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iWhileUntil<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Mod(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2 && type[lo]==iAtTok) {
        final long s1 = slices.get(iIdent<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Mod0((String)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo==1 && type[lo]==iAbstractTok)
        values.add(Mod1());
      if (hi-lo==1 && type[lo]==iStrictfpTok)
        values.add(Mod2());
      if (hi-lo==1 && type[lo]==iPrivateTok)
        values.add(Mod3());
      if (hi-lo==1 && type[lo]==iTransientTok)
        values.add(Mod4());
      if (hi-lo==1 && type[lo]==iPublicTok)
        values.add(Mod5());
      if (hi-lo==1 && type[lo]==iStaticTok)
        values.add(Mod6());
      if (hi-lo==1 && type[lo]==iVolatileTok)
        values.add(Mod7());
      if (hi-lo==1 && type[lo]==iSynchronizedTok)
        values.add(Mod8());
      if (hi-lo==1 && type[lo]==iProtectedTok)
        values.add(Mod9());
      if (hi-lo==1 && type[lo]==iFinalTok)
        values.add(Mod10());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMod<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_Mod(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iMod<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_Mod<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_Mod0((Mod)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iMod<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_Mod1((Mod)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_Mod<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts0_Mod(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iJuxts1_Mod<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts0_Mod0((List)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts0_Mod<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAssignNP__DoTok__Stmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iDoTok) {
            final long s1 = slices.get(iExpAssignNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAssignNP__DoTok__Stmt0((AExp)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAssignNP__DoTok__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void DoTok__MaybeStmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iDoTok) {
        final long s1 = slices.get(iMaybeStmt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(DoTok__MaybeStmt0((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iDoTok__MaybeStmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Right__Stmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iRight<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Right__Stmt0((Group)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iRight__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas2_ExpCond_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iExpCond_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_ExpCond_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas2_ExpCond_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas2_ExpCond_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iType<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_Type<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_Type0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void LParenTok__Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2 && type[lo]==iLParenTok) {
        final long s1 = slices.get(iType<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(LParenTok__Type0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iLParenTok__Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void AssignOp__ExpAssign(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iAssignOp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(AssignOp__ExpAssign0((Option)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iAssignOp__ExpAssign<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void IfTok__ParenExp__MaybeThen(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=4 && type[lo]==iIfTok) {
        for (int j=lo+4;j<=hi;j++) {
          {
            final long s1 = slices.get(iParenExp<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeThen<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++)
              values.add(IfTok__ParenExp__MaybeThen0((Tuple2)values.get((int)(s1>>32)+k1)));
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iIfTok__ParenExp__MaybeThen<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Lit(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iFloatLitTok)
        values.add(Lit0((FloatLitTok)input[lo]));
      if (hi-lo==1 && type[lo]==iDoubleLitTok)
        values.add(Lit1((DoubleLitTok)input[lo]));
      if (hi-lo==1 && type[lo]==iStringLitTok)
        values.add(Lit2((StringLitTok)input[lo]));
      if (hi-lo==1 && type[lo]==iIntLitTok)
        values.add(Lit3((IntLitTok)input[lo]));
      if (hi-lo==1 && type[lo]==iLongLitTok)
        values.add(Lit4((LongLitTok)input[lo]));
      if (hi-lo==1 && type[lo]==iCharLitTok)
        values.add(Lit5((CharLitTok)input[lo]));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iLit<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeDo(final int lo, final int hi) {
      boolean found = false;
      if (hi-lo==1 && type[lo]==iDoTok)
        found = true;
      if (found) { slices.put(iMaybeDo<<24|lo<<12|hi,1); }
    }
    
    private void WhileUntil__ParenExp(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=4) {
        for (int j=lo+1;j<=hi-3;j++) {
          {
            final long s1 = slices.get(iWhileUntil<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iParenExp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(WhileUntil__ParenExp0((java.lang.Boolean)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iWhileUntil__ParenExp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Block(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2 && type[lo]==iLCurlyTok) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iStmts<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Block0((List)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iBlock<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Right(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iRCurlyTok)
        values.add(Right0());
      if (hi-lo==1 && type[lo]==iRBrackTok)
        values.add(Right1());
      if (hi-lo==1 && type[lo]==iRParenTok)
        values.add(Right2());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iRight<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List_ExpAssignNC__Right(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1) {
        for (int j=lo;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iList_ExpAssignNC<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(List_ExpAssignNC__Right0((KList)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList_ExpAssignNC__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Ident(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo==1 && type[lo]==iInTok)
        values.add(Ident0());
      if (hi-lo==1 && type[lo]==iUntilTok)
        values.add(Ident1());
      if (hi-lo==1 && type[lo]==iThenTok)
        values.add(Ident2());
      if (hi-lo==1 && type[lo]==iIdentTok)
        values.add(Ident3((IdentTok)input[lo]));
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iIdent<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpHighNA(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iExpHigh<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iDotTok__Option_TypeArgs__Ident<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNA0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iIdent<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpHighNA1((String)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+2;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpHigh__Left<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iList_ExpAssignNC__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNA2((Tuple2)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iLit<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpHighNA3((ALit)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iExpHigh<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iColonColonTok__Option_TypeArgs__Ident<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNA4((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3 && type[hi-1]==iNewTok) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iColonColonTok) {
            final long s1 = slices.get(iExpHigh<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iOption_TypeArgs<<24|j+1<<12|hi-1); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNA5((AExp)values.get((int)(s1>>32)+k1),(Option)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iExpHigh<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iTypeArgs<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNA6((AExp)values.get((int)(s1>>32)+k1),(KList)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpHighNA<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpHighNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=4) {
        for (int j=lo+1;j<=hi-3;j++) {
          {
            final long s1 = slices.get(iLeftNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts2_ExpNew__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNP0((Group)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iLeftNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpCond_ExpNew__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNP1((Group)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iLeftNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNP2((Group)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=5) {
        for (int j=lo+1;j<=hi-4;j++) {
          {
            final long s1 = slices.get(iLeftNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas2_ExpCond_ExpJuxt__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpHighNP3((Group)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpHighNA<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpHighNP4((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpHighNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpHigh(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpHighNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpHigh0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=2) {
        final long s1 = slices.get(iExpParens<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpHigh1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpHigh<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iQuestionTok) {
        final long s1 = slices.get(iWildcardBounds<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpNew0((Option)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=2 && type[lo]==iNewTok) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iOption_TypeArgs<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpNew1((Option)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpHigh<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpNew2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpNew<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpNew<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_ExpNew1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpUnary_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=4) {
        for (int j=lo+2;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iLParenTok__Type<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight__ExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iPreOp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpNew1((UnaryOp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpUnary_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iPostOp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpNew2((AExp)values.get((int)(s1>>32)+k1),(UnaryOp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpUnary_ExpNew3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpUnary_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpMul_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iModTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpNew<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iDivTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpNew<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpNew1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iMulTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpNew<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpNew2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpUnary_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpMul_ExpNew3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpMul_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAdd_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iMinusTok) {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpMul_ExpNew<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iPlusTok) {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpMul_ExpNew<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpNew1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpMul_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAdd_ExpNew2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAdd_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpShift_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iUnsignedRShiftTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iRShiftTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpNew1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLShiftTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpNew2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAdd_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpShift_ExpNew3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpShift_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpRel_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLtTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iGtTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpNew1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iInstanceofTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iType<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpNew2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLeTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpNew3((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iGeTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpNew4((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpShift_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpRel_ExpNew5((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpRel_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpEq_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iNeTok) {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpRel_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iEqEqTok) {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpRel_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpNew1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpRel_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpEq_ExpNew2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpEq_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAnd_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iAndTok) {
            final long s1 = slices.get(iExpAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpEq_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAnd_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpEq_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAnd_ExpNew1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAnd_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpXor_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iXorTok) {
            final long s1 = slices.get(iExpXor_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAnd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpXor_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAnd_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpXor_ExpNew1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpXor_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOr_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iOrTok) {
            final long s1 = slices.get(iExpOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpXor_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOr_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpXor_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOr_ExpNew1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOr_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAndAnd_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iAndAndTok) {
            final long s1 = slices.get(iExpAndAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpOr_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAndAnd_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpOr_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAndAnd_ExpNew1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAndAnd_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOrOr_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iOrOrTok) {
            final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAndAnd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOrOr_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAndAnd_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOrOr_ExpNew1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOrOr_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpCond_ExpNew(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=5) {
        for (int j=lo+1;j<=hi-4;j++) {
          {
            final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iQuestionTok__ExpAssign__ColonTok__ExpCond_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpCond_ExpNew0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpOrOr_ExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpCond_ExpNew1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpCond_ExpNew<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpNew<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iSingleJuxt1_ExpNewNA<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(KList)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpNew<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpUnary_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=4) {
        for (int j=lo+2;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iLParenTok__Type<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight__ExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iPreOp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxt1((UnaryOp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpUnary_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iPostOp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxt2((AExp)values.get((int)(s1>>32)+k1),(UnaryOp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpUnary_ExpJuxt3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpUnary_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpMul_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iModTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iDivTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxt1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iMulTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxt2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpUnary_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpMul_ExpJuxt3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpMul_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAdd_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iMinusTok) {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpMul_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iPlusTok) {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpMul_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpJuxt1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAdd_ExpJuxt2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAdd_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpShift_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iUnsignedRShiftTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iRShiftTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxt1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLShiftTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxt2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpShift_ExpJuxt3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpShift_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpRel_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLtTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iGtTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxt1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iInstanceofTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iType<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxt2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLeTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxt3((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iGeTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxt4((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpRel_ExpJuxt5((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpRel_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpEq_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iNeTok) {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpRel_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iEqEqTok) {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpRel_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpJuxt1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpEq_ExpJuxt2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpEq_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAnd_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iAndTok) {
            final long s1 = slices.get(iExpAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpEq_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAnd_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAnd_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAnd_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpXor_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iXorTok) {
            final long s1 = slices.get(iExpXor_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAnd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpXor_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAnd_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpXor_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpXor_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOr_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iOrTok) {
            final long s1 = slices.get(iExpOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpXor_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOr_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpXor_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOr_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOr_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAndAnd_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iAndAndTok) {
            final long s1 = slices.get(iExpAndAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpOr_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAndAnd_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpOr_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAndAnd_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAndAnd_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOrOr_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iOrOrTok) {
            final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAndAnd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOrOr_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAndAnd_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOrOr_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOrOr_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpCond_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=5) {
        for (int j=lo+1;j<=hi-4;j++) {
          {
            final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iQuestionTok__ExpAssign__ColonTok__ExpCond_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpCond_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpCond_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpCond_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iAssignOp__ExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAssignNC0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpCond_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAssignNC1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List1_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        final long s1 = slices.get(iJuxts2_ExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_ExpAssignNC0((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=3) {
        final long s1 = slices.get(iCommas2_ExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_ExpAssignNC1((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_ExpAssignNC2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList1_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iList1_ExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List_ExpAssignNC0((KList)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas1_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iExpAssignNC<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_ExpAssignNC<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas1_ExpAssignNC0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas1_ExpAssignNC1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas1_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas0_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iCommas1_ExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas0_ExpAssignNC0((List)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas0_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpAssignNC<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpAssignNC<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_ExpAssignNC0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAssignNC<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_ExpAssignNC1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpCommas(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        final long s1 = slices.get(iCommas2_ExpCond_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpCommas0((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpCond_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpCommas1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpCommas<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAssign(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iAssignOp__ExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAssign0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpCommas<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAssign1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAssign<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void StmtHelperBS(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iReturnTok) {
        final long s1 = slices.get(iOption_ExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS0((Option)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=5 && type[lo]==iForTok) {
        for (int j=lo+3;j<=hi-2;j++) {
          if (type[j]==iDoTok) {
            final long s1 = slices.get(iForInfo<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS1((ForInfo)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iJuxts0_Mod<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iType__List1_VarDecl<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS2((List)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iWhileUntil<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssignNP<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS3((java.lang.Boolean)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=4 && type[lo]==iAssertTok) {
        for (int j=lo+2;j<=hi-2;j++) {
          if (type[j]==iColonTok) {
            final long s1 = slices.get(iExpJuxt<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS4((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2 && type[lo]==iIfTok) {
        final long s1 = slices.get(iExpAssignNP<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS5((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=6) {
        for (int j=lo+4;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iIfTok__ParenExp__MaybeThen<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeStmt__ElseTok__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS6((Tuple2)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=4 && type[lo]==iIfTok) {
        for (int j=lo+2;j<=hi-2;j++) {
          if (type[j]==iThenTok) {
            final long s1 = slices.get(iExpAssignNP<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS7((AExp)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iDoTok__MaybeStmt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iWhileUntil__MaybeParenExp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS8((AStmt)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2 && type[lo]==iAssertTok) {
        final long s1 = slices.get(iExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS9((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=5) {
        for (int j=lo+4;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iWhileUntil__ParenExp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeDo__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS10((Tuple2)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=4) {
        for (int j=lo+1;j<=hi-3;j++) {
          {
            final long s1 = slices.get(iWhileUntil<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAssignNP__DoTok__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS11((java.lang.Boolean)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAssign<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS12((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=4 && type[lo]==iSynchronizedTok) {
        for (int j=lo+2;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iMaybeParenExp<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iBlock<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS13((Tuple2)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=5) {
        for (int j=lo+2;j<=hi-3;j++) {
          {
            final long s1 = slices.get(iIfTok__ExpAssignNP<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iThenTok__MaybeStmt__ElseTok__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS14((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        final long s1 = slices.get(iBlock<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS15((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=5) {
        for (int j=lo+4;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iIfTok__ParenExp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeThen__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS16((Tuple2)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2 && type[lo]==iIfTok) {
        final long s1 = slices.get(iExpAssignNP<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS17((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=2 && type[lo]==iThrowTok) {
        final long s1 = slices.get(iExpJuxt<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS18((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1 && type[lo]==iBreakTok) {
        final long s1 = slices.get(iOption_Ident<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS19((Option)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1 && type[lo]==iContinueTok) {
        final long s1 = slices.get(iOption_Ident<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelperBS20((Option)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=6) {
        for (int j=lo+4;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iForTok__Left__ForInfo<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight__Stmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelperBS21((Tuple2)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iStmtHelperBS<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas1_StmtHelperBS(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iStmtHelperBS<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_StmtHelperBS<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas1_StmtHelperBS0((AStmt)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iStmtHelperBS<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas1_StmtHelperBS1((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas1_StmtHelperBS<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas0_StmtHelperBS(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iCommas1_StmtHelperBS<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas0_StmtHelperBS0((List)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas0_StmtHelperBS<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void StmtHelper(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=4 && type[lo]==iIfTok && type[hi-1]==iElseTok) {
        for (int j=lo+2;j<=hi-2;j++) {
          if (type[j]==iThenTok) {
            final long s1 = slices.get(iExpAssignNP<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeStmt<<24|j+1<<12|hi-1); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelper0((AExp)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iStmtHelperBS<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelper1((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iWhileUntil<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeParenExp__MaybeDo<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelper2((java.lang.Boolean)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2 && type[lo]==iSynchronizedTok) {
        final long s1 = slices.get(iMaybeParenExp<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelper3((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=2 && type[lo]==iIfTok) {
        for (int j=lo+2;j<=hi;j++) {
          {
            final long s1 = slices.get(iMaybeParenExp<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeThen<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++)
              values.add(StmtHelper4((Tuple2)values.get((int)(s1>>32)+k1)));
          }
        }
      }
      if (hi-lo>=5) {
        for (int j=lo+4;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iIfTok__ParenExp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeThen__MaybeStmt__ElseTok<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelper5((Tuple2)values.get((int)(s1>>32)+k1),(AStmt)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=5) {
        for (int j=lo+2;j<=hi-3;j++) {
          {
            final long s1 = slices.get(iForTok__Left<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iForInfo__Right<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(StmtHelper6((Group)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3 && type[lo]==iForTok) {
        final long s1 = slices.get(iForInfo<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(StmtHelper7((ForInfo)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iStmtHelper<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Stmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2 && type[hi-1]==iSemiTok) {
        final long s1 = slices.get(iStmtHelperBS<<24|lo<<12|hi-1);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Stmt0((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iStmtHelper<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Stmt1((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo==1 && type[lo]==iSemiTok)
        values.add(Stmt2());
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iStmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeDo__Stmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1) {
        for (int j=lo;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iMaybeDo<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k3=0;k3<(s3&vMask);k3++)
              values.add(MaybeDo__Stmt0((AStmt)values.get((int)(s3>>32)+k3)));
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeDo__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeThen__Stmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1) {
        for (int j=lo;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iMaybeThen<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k3=0;k3<(s3&vMask);k3++)
              values.add(MaybeThen__Stmt0((AStmt)values.get((int)(s3>>32)+k3)));
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeThen__Stmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeStmt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iStmt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(MaybeStmt0((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeStmt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Stmts(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          if (type[j]==iSemiTok) {
            final long s1 = slices.get(iStmtHelperBS<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iStmts<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Stmts0((AStmt)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iStmtHelper<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Stmts1((AStmt)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1 && type[lo]==iSemiTok) {
        final long s1 = slices.get(iStmts<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Stmts2((List)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iStmts<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_ExpAssign(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAssign<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Option_ExpAssign0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_ExpAssign<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas1_ExpCond_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iExpCond_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_ExpCond_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas1_ExpCond_ExpJuxt0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpCond_ExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas1_ExpCond_ExpJuxt1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas1_ExpCond_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_ExpJuxt(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpJuxt<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Option_ExpJuxt0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_ExpJuxt<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iQuestionTok) {
        final long s1 = slices.get(iWildcardBounds<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Type0((Option)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpHigh<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Type1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iType<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas1_Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iType<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_Type<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas1_Type0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iType<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas1_Type1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas1_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iType<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Option_Type0((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts0_Mod__Option_Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=0) {
        for (int j=lo;j<=hi;j++) {
          {
            final long s1 = slices.get(iJuxts0_Mod<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iOption_Type<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts0_Mod__Option_Type0((List)values.get((int)(s1>>32)+k1),(Option)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts0_Mod__Option_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List1_Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        final long s1 = slices.get(iJuxts2_Type<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_Type0((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=3) {
        final long s1 = slices.get(iCommas2_Type<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_Type1((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iType<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_Type2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList1_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List_Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iList1_Type<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List_Type0((KList)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_Type(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iType<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_Type<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_Type0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iType<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_Type1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_Type<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpNewNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iQuestionTok) {
        final long s1 = slices.get(iWildcardBounds<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpNewNP0((Option)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=2 && type[lo]==iNewTok) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iOption_TypeArgs<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpNewNP1((Option)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpHighNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpNewNP2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpNewNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpNew<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iSingleJuxt1_ExpNewNA<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(KList)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpNewNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpUnary_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=4) {
        for (int j=lo+2;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iLParenTok__Type<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight__ExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iPreOp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxtNP1((UnaryOp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpUnary_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iPostOp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpUnary_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k1),(UnaryOp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpUnary_ExpJuxtNP3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpUnary_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpMul_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iModTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxtNP<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iDivTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxtNP<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iMulTok) {
            final long s1 = slices.get(iExpMul_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpUnary_ExpJuxtNP<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpMul_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpUnary_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpMul_ExpJuxtNP3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpMul_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAdd_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iMinusTok) {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpMul_ExpJuxtNP<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iPlusTok) {
            final long s1 = slices.get(iExpAdd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpMul_ExpJuxtNP<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAdd_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpMul_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAdd_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAdd_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpShift_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iUnsignedRShiftTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iRShiftTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLShiftTok) {
            final long s1 = slices.get(iExpShift_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAdd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpShift_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAdd_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpShift_ExpJuxtNP3((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpShift_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpRel_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLtTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iGtTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iInstanceofTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iType<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLeTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxtNP3((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iGeTok) {
            final long s1 = slices.get(iExpRel_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpShift_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpRel_ExpJuxtNP4((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpShift_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpRel_ExpJuxtNP5((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpRel_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpEq_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iNeTok) {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpRel_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iEqEqTok) {
            final long s1 = slices.get(iExpEq_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpRel_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpEq_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpRel_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpEq_ExpJuxtNP2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpEq_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAnd_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iAndTok) {
            final long s1 = slices.get(iExpAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpEq_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAnd_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpEq_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAnd_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAnd_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpXor_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iXorTok) {
            final long s1 = slices.get(iExpXor_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAnd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpXor_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAnd_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpXor_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpXor_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOr_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iOrTok) {
            final long s1 = slices.get(iExpOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpXor_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOr_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpXor_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOr_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOr_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAndAnd_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iAndAndTok) {
            final long s1 = slices.get(iExpAndAnd_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpOr_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAndAnd_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpOr_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAndAnd_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAndAnd_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpOrOr_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iOrOrTok) {
            final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpAndAnd_ExpJuxt<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpOrOr_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAndAnd_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpOrOr_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpOrOr_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpCond_ExpJuxtNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=5) {
        for (int j=lo+1;j<=hi-4;j++) {
          {
            final long s1 = slices.get(iExpOrOr_ExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iQuestionTok__ExpAssign__ColonTok__ExpCond_ExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpCond_ExpJuxtNP0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpOrOr_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpCond_ExpJuxtNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpCond_ExpJuxtNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpAssignNP(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iExpJuxt<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iAssignOp__ExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpAssignNP0((AExp)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpCond_ExpJuxtNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpAssignNP1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpAssignNP<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeParenExp(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        final long s1 = slices.get(iParenExp<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(MaybeParenExp0((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpAssignNP<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(MaybeParenExp1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeParenExp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void MaybeParenExp__MaybeDo(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1) {
        for (int j=lo+1;j<=hi;j++) {
          {
            final long s1 = slices.get(iMaybeParenExp<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeDo<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++)
              values.add(MaybeParenExp__MaybeDo0((Tuple2)values.get((int)(s1>>32)+k1)));
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iMaybeParenExp__MaybeDo<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ExpNewNA(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1 && type[lo]==iQuestionTok) {
        final long s1 = slices.get(iWildcardBounds<<24|lo+1<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpNewNA0((Option)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=2 && type[lo]==iNewTok) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iOption_TypeArgs<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpJuxt<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ExpNewNA1((Option)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpHighNA<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(ExpNewNA2((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iExpNewNA<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_ExpNewNA(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iExpNewNA<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_ExpNewNA<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_ExpNewNA0((AExp)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpNewNA<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_ExpNewNA1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_ExpNewNA<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void SingleJuxt1_ExpNewNA(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        final long s1 = slices.get(iJuxts2_ExpNewNA<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(SingleJuxt1_ExpNewNA0((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iExpNewNA<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(SingleJuxt1_ExpNewNA1((AExp)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iSingleJuxt1_ExpNewNA<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Option_Ident(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=1) {
        final long s1 = slices.get(iIdent<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Option_Ident0((String)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iOption_Ident<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void IdentDims(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iLBrackTok) {
            final long s1 = slices.get(iIdentDims<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(IdentDims0((Tuple2)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iIdent<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(IdentDims1((String)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iIdentDims<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void VarDecl(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iEqTok) {
            final long s1 = slices.get(iIdentDims<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iExpCommas<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(VarDecl0((Tuple2)values.get((int)(s1>>32)+k1),(AExp)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iIdentDims<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(VarDecl1((Tuple2)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iVarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts1_VarDecl(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iVarDecl<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iJuxts1_VarDecl<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts1_VarDecl0((Tuple3)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iVarDecl<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Juxts1_VarDecl1((Tuple3)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts1_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas1_VarDecl(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iVarDecl<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_VarDecl<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas1_VarDecl0((Tuple3)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iVarDecl<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(Commas1_VarDecl1((Tuple3)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas1_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForeachSep(final int lo, final int hi) {
      boolean found = false;
      if (hi-lo==1 && type[lo]==iInTok)
        found = true;
      if (hi-lo==1 && type[lo]==iColonTok)
        found = true;
      if (found) { slices.put(iForeachSep<<24|lo<<12|hi,1); }
    }
    
    private void SemiTok__Option_ExpAssign__SemiTok__Commas0_ExpAssignNC(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2 && type[lo]==iSemiTok) {
        for (int j=lo+1;j<=hi-1;j++) {
          if (type[j]==iSemiTok) {
            final long s1 = slices.get(iOption_ExpAssign<<24|lo+1<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas0_ExpAssignNC<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(SemiTok__Option_ExpAssign__SemiTok__Commas0_ExpAssignNC0((Option)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iSemiTok__Option_ExpAssign__SemiTok__Commas0_ExpAssignNC<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void ForInfo(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo;j<=hi-3;j++) {
          {
            final long s1 = slices.get(iJuxts0_Mod__Option_Type<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iIdentDims__ForeachSep__ExpAssign<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ForInfo0((Tuple2)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      if (hi-lo>=2) {
        for (int j=lo;j<=hi-2;j++) {
          {
            final long s1 = slices.get(iCommas0_StmtHelperBS<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iSemiTok__Option_ExpAssign__SemiTok__Commas0_ExpAssignNC<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(ForInfo1((List)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iForInfo<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Commas2_VarDecl(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+1;j<=hi-2;j++) {
          if (type[j]==iCommaTok) {
            final long s1 = slices.get(iVarDecl<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iCommas1_VarDecl<<24|j+1<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Commas2_VarDecl0((Tuple3)values.get((int)(s1>>32)+k1),(List)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iCommas2_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void List1_VarDecl(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        final long s1 = slices.get(iJuxts2_VarDecl<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_VarDecl0((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=3) {
        final long s1 = slices.get(iCommas2_VarDecl<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_VarDecl1((List)values.get((int)(s1>>32)+k)));
        }
      }
      if (hi-lo>=1) {
        final long s1 = slices.get(iVarDecl<<24|lo<<12|hi);
        if (s1 != 0) {
          for (int k=0;k<(s1&vMask);k++)
            values.add(List1_VarDecl2((Tuple3)values.get((int)(s1>>32)+k)));
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iList1_VarDecl<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void WhileUntil__MaybeParenExp(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=2) {
        for (int j=lo+1;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iWhileUntil<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iMaybeParenExp<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(WhileUntil__MaybeParenExp0((java.lang.Boolean)values.get((int)(s1>>32)+k1),(Tuple2)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iWhileUntil__MaybeParenExp<<24|lo<<12|hi,(long)prev<<32|count); }
    }
    
    private void Juxts2_ExpNew__Right(final int lo, final int hi) {
      final int prev = values.size();
      if (hi-lo>=3) {
        for (int j=lo+2;j<=hi-1;j++) {
          {
            final long s1 = slices.get(iJuxts2_ExpNew<<24|lo<<12|j); if (s1 == 0) continue;
            final long s3 = slices.get(iRight<<24|j<<12|hi); if (s3 == 0) continue;
            for (int k1=0;k1<(s1&vMask);k1++) {
              for (int k3=0;k3<(s3&vMask);k3++)
                values.add(Juxts2_ExpNew__Right0((List)values.get((int)(s1>>32)+k1),(Group)values.get((int)(s3>>32)+k3)));
            }
          }
        }
      }
      final int count = values.size()-prev;
      if (count != 0) { slices.put(iJuxts2_ExpNew__Right<<24|lo<<12|hi,(long)prev<<32|count); }
    }
  }
}
