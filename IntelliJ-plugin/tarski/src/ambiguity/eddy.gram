name ParseEddy
start Stmts
token Token

preamble package tarski
preamble import tarski.Tokens._
preamble import tarski.AST._
preamble import tarski.Types._

// Identifiers, including fake keywords
Ident Name
  IdentTok { $1.name }
  ThenTok  { "then" }
  UntilTok { "until" }
  InTok    { "in" }

// Modifiers
Mod Mod
  AtTok Ident                    { Annotation($2) }
  PublicTok                      { Public() }
  ProtectedTok                   { Protected() }
  PrivateTok                     { Private() }
  AbstractTok                    { Abstract() }
  StaticTok                      { Static() }
  FinalTok                       { Final() }
  StrictfpTok                    { Strictfp() }
  TransientTok                   { Transient() }
  VolatileTok                    { Volatile() }
  SynchronizedTok                { Synchronized() }

// Option
Option[a] Option[a]
  ""                             { None }
  a                              { Some($1) }

// Lists
Commas1[a] List[a]
  a                              { List($1) }
  a CommaTok Commas1[a]          { $1 :: $3 }
Commas2[a] List[a]
  a CommaTok Commas1[a]          { $1 :: $3 }
Juxts1[a] List[a]
  a                              { List($1) }
  a Juxts1[a]                    { $1 :: $2 }
Juxts2[a] List[a]
  a Juxts1[a]                    { $1 :: $2 }
Ands[a] List[a]
  a                              { List($1) }
  a AndTok Ands[a]               { $1 :: $3 }
List[a] KList[a]
  ""                             { EmptyList }
  List1[a]                       { $1 }
List1[a] KList[a]
  a                              { SingleList($1) }
  Commas2[a]                     { CommaList($1) }
  Juxts2[a]                      { JuxtList($1) }
List2[a] KList[a]
  a CommaTok Commas1[a]          { CommaList($1::$3) }
  a Juxts1[a]                    { JuxtList($1::$2) }
Juxts0[a] List[a]
  ""                             { Nil }
  Juxts1[a]                      { $1 }
Commas0[a] List[a]
  ""                             { Nil }
  Commas1[a]                     { $1 }

// Dims
IdentDims (Name,Int)
  Ident                          { ($1,0) }
  IdentDims LBrackTok RBrackTok  { ($1._1,$1._2+1) }

// Types
Type AType
  Ident                          { NameAType($1) }
  VoidTok                        { VoidAType() }
  PrimType                       { PrimAType($1) }
  Mod Type                       { ModAType($1,$2) }
  Type LBrackTok RBrackTok       { ArrayAType($1) }
  Type TypeArgs                  { ApplyAType($1,$2) }
  Type DotTok Ident              { FieldAType($1,$3) }
  QuestionTok WildcardBounds     { WildAType($2) }
TypeArgs KList[AType]
  LtTok List[Type] GtTok         { $2 }
WildcardBounds Option[(Bound,AType)]
  ""                             { None }
  ExtendsTok Type                { Some((Extends(),$2)) }
  ColonTok Type                  { Some((Extends(),$2)) }
  SuperTok Type                  { Some((Super(),$2)) }
PrimType PrimType
  ByteTok                        { ByteType }
  ShortTok                       { ShortType }
  IntTok                         { IntType }
  LongTok                        { LongType }
  FloatTok                       { FloatType }
  DoubleTok                      { DoubleType }
  CharTok                        { CharType }

// Type parameters
//TypeParam
//  Mod Ident Option[TypeBounds]
//TypeBounds
//  ExtendsTok TypeBoundArgs
//  ColonTok TypeBoundArgs
//TypeBoundArgs
//  List1[Type]
//  Ands[Type]

// Classes
// TODO: ClassDecl

// Blocks
Block List[AStmt]
  LCurlyTok Stmts RCurlyTok      { $2 }
Stmts List[AStmt]
  ""                             { Nil }
  SemiTok Stmts                  { EmptyAStmt() :: $2 }
  StmtHelper                     { List($1) }
  StmtHelperBS SemiTok Stmts     { $1 :: $3 }

// Statement
// Suffix BS means before semicolon
Stmt AStmt
  SemiTok                                                    { EmptyAStmt() }
  StmtHelper                                                 { $1 }
  StmtHelperBS SemiTok                                       { $1 }
MaybeStmt AStmt
  ""                                                         { HoleAStmt() }
  Stmt                                                       { $1 }
StmtHelper AStmt
  StmtHelperBS                                               { $1 }
  IfTok MaybeParenExp Option[ThenTok]                        { IfAStmt($2,HoleAStmt()) }
  IfTok ParenExp Option[ThenTok] MaybeStmt ElseTok           { IfElseAStmt($2,$4,HoleAStmt()) }
  IfTok ExpAssignNP ThenTok MaybeStmt ElseTok                { IfElseAStmt($2,$4,HoleAStmt()) }
  WhileUntil MaybeParenExp Option[DoTok]                     { WhileAStmt($2,HoleAStmt(),$1) }
  ForTok LParenTok ForInfo RParenTok                         { $3(HoleAStmt()) }
  ForTok ForInfo                                             { $2(HoleAStmt()) }
  SynchronizedTok MaybeParenExp                              { SyncAStmt($2,HoleAStmt()) }
StmtHelperBS AStmt
  Juxts0[Mod] Type List1[VarDecl]                            { VarAStmt($1,$2,$3) }
  Block                                                      { BlockAStmt($1) }
  ExpAssign                                                  { ExpAStmt($1) }
  AssertTok ExpJuxt                                          { AssertAStmt($2,None) }
  AssertTok ExpJuxt ColonTok ExpJuxt                         { AssertAStmt($2,Some($4)) }
  BreakTok Option[Ident]                                     { BreakAStmt($2) }
  ContinueTok Option[Ident]                                  { ContinueAStmt($2) }
  ReturnTok Option[ExpJuxt]                                  { ReturnAStmt($2) }
  ThrowTok ExpJuxt                                           { ThrowAStmt($2) }
  // LabelStmt
  IfTok ParenExp Option[ThenTok] Stmt                        { IfAStmt($2,$4) }
  IfTok ExpAssignNP ThenTok Stmt                             { IfAStmt($2,$4) }
  IfTok ExpAssignNP                                          { IfAStmt($2,EmptyAStmt()) }
  IfTok ExpAssignNP                                          { IfElseAStmt($2,EmptyAStmt(),HoleAStmt()) }
  IfTok ParenExp Option[ThenTok] MaybeStmt ElseTok Stmt      { IfElseAStmt($2,$4,$6) }
  IfTok ExpAssignNP ThenTok MaybeStmt ElseTok Stmt           { IfElseAStmt($2,$4,$6) }
  WhileUntil ParenExp Option[DoTok] Stmt                     { WhileAStmt($2,$4,$1) }
  WhileUntil ExpAssignNP DoTok Stmt                          { WhileAStmt($2,$4,$1) }
  WhileUntil ExpAssignNP                                     { WhileAStmt($2,EmptyAStmt(),$1) }
  DoTok MaybeStmt WhileUntil MaybeParenExp                   { DoAStmt($2,$4,$3) }
  ForTok LParenTok ForInfo RParenTok Stmt                    { $3($5) }
  ForTok ForInfo DoTok Stmt                                  { $2($4) }
  SynchronizedTok MaybeParenExp Block                        { SyncAStmt($2,BlockAStmt($3)) }
  // Try
  // Switch
VarDecl (Name,Int,Option[AExp])
  IdentDims                      { ($1._1,$1._2,None) }
  IdentDims EqTok ExpCommas      { ($1._1,$1._2,Some($3)) }
WhileUntil Boolean
  WhileTok                                                   { false }
  UntilTok                                                   { true }
ForInfo AStmt=>AStmt
  Commas0[StmtHelperBS] SemiTok Option[ExpAssign] SemiTok Commas0[ExpAssignNC]  { (s: AStmt) => ForAStmt($1,$3,$5,s) }
  Option[Type] IdentDims ForeachSep ExpAssign                                   { (s: AStmt) => ForeachAStmt($1,$2._1,$2._2,$4,s) }
ForeachSep Unit
  ColonTok                                                   { () }
  InTok                                                      { () }
ParenExp AExp
  LParenTok ExpAssign RParenTok                              { $2 }
MaybeParenExp AExp
  ExpAssignNP                                                { $1 }
  ParenExp                                                   { $1 }

// Expressions, lowest to highest precedence
// Suffixes: NJ is no juxtaposition, NC is no commas, NA is no args, NP is no parens (or commas)
// TODO LambdaExp
// TODO new Exp ClassBody
ExpAssign AExp
  ExpCommas                                                 { $1 }
  ExpJuxt AssignOp ExpAssign                                { AssignAExp($2,$1,$3) }
ExpAssignNC AExp
  ExpBinary                                                 { $1 }
  ExpJuxt AssignOp ExpAssign                                { AssignAExp($2,$1,$3) }
ExpAssignNP AExp
  ExpBinaryNP                                               { $1 }
  ExpJuxt AssignOp ExpAssign                                { AssignAExp($2,$1,$3) }

ExpCommas AExp
  ExpBinary                                                 { $1 }
  Commas2[ExpBinary]                                        { ArrayAExp(CommaList($1),NoAround) }

ExpBinary AExp
  ExpUnary                                                  { $1 }
  ExpBinary BinaryOp ExpBinary                              { BinaryAExp($2,$1,$3) }
  ExpBinary QuestionTok ExpAssign ColonTok ExpBinary        { CondAExp($1,$3,$5) }
ExpBinaryNJ AExp
  ExpUnaryNJ                                                { $1 }
  ExpBinary BinaryOp ExpBinary                              { BinaryAExp($2,$1,$3) }
  ExpBinary QuestionTok ExpAssign ColonTok ExpBinary        { CondAExp($1,$3,$5) }
ExpBinaryNP AExp
  ExpUnaryNP                                                { $1 }
  ExpBinary BinaryOp ExpBinary                              { BinaryAExp($2,$1,$3) }
  ExpBinary QuestionTok ExpAssign ColonTok ExpBinary        { CondAExp($1,$3,$5) }

ExpUnary AExp
  ExpJuxt                                                   { $1 }
  ExpUnary PostOp                                           { UnaryAExp($2,$1) }
  PreOp ExpUnary                                            { UnaryAExp($1,$2) }
  LParenTok Type RParenTok ExpUnary                         { CastAExp($2,$4) }
ExpUnaryNJ AExp
  ExpNew                                                    { $1 }
  ExpUnary PostOp                                           { UnaryAExp($2,$1) }
  PreOp ExpUnary                                            { UnaryAExp($1,$2) }
  LParenTok Type RParenTok ExpUnary                         { CastAExp($2,$4) }
ExpUnaryNP AExp
  ExpJuxtNP                                                 { $1 }
  ExpUnary PostOp                                           { UnaryAExp($2,$1) }
  PreOp ExpUnary                                            { UnaryAExp($1,$2) }
  LParenTok Type RParenTok ExpUnary                         { CastAExp($2,$4) }

ExpJuxt AExp
  ExpNew                                                    { $1 }
  ExpNew Juxts1[ExpNewNA]                                   { ApplyAExp($1,JuxtList($2),NoAround) }
ExpJuxtNP AExp
  ExpNewNP                                                  { $1 }
  ExpNew Juxts1[ExpNewNA]                                   { ApplyAExp($1,JuxtList($2),NoAround) }

ExpNew AExp
  ExpHigh                                                   { $1 }
  NewTok Option[TypeArgs] ExpJuxt                           { NewAExp($2,$3) }
  QuestionTok WildcardBounds                                { WildAExp($2) }
ExpNewNA AExp
  ExpHighNA                                                 { $1 }
  NewTok Option[TypeArgs] ExpJuxt                           { NewAExp($2,$3) }
  QuestionTok WildcardBounds                                { WildAExp($2) }
ExpNewNP AExp
  ExpHighNP                                                 { $1 }
  NewTok Option[TypeArgs] ExpJuxt                           { NewAExp($2,$3) }
  QuestionTok WildcardBounds                                { WildAExp($2) }

ExpHigh AExp
  ExpParens                                                 { $1 }
  ExpHighNP                                                 { $1 }
ExpHighNP AExp
  ExpHighNA                                                 { $1 }
  LBrackTok RBrackTok                                       { ArrayAExp(EmptyList,     BrackAround) }
  LBrackTok ExpBinary RBrackTok                             { ArrayAExp(SingleList($2),BrackAround) }
  LBrackTok Commas2[ExpBinary] RBrackTok                    { ArrayAExp(CommaList($2), BrackAround) }
  LBrackTok Juxts2[ExpNew] RBrackTok                        { ArrayAExp(JuxtList($2),  BrackAround) }
  LCurlyTok RCurlyTok                                       { ArrayAExp(EmptyList,     CurlyAround) }
  LCurlyTok ExpBinary RCurlyTok                             { ArrayAExp(SingleList($2),CurlyAround) }
  LCurlyTok Commas2[ExpBinary] RCurlyTok                    { ArrayAExp(CommaList($2), CurlyAround) }
  LCurlyTok Juxts2[ExpNew] RCurlyTok                        { ArrayAExp(JuxtList($2),  CurlyAround) }
ExpParens AExp
  LParenTok ExpAssignNC RParenTok                           { ParenAExp($2) }
  LParenTok RParenTok                                       { ArrayAExp(EmptyList,     ParenAround) }
  LParenTok Commas2[ExpBinary] RParenTok                    { ArrayAExp(CommaList($2), ParenAround) }
  LParenTok Juxts2[ExpNew] RParenTok                        { ArrayAExp(JuxtList($2),  ParenAround) }
ExpHighNA AExp
  Ident                                                     { NameAExp($1) }
  Lit                                                       { $1 }
  ExpHigh DotTok Option[TypeArgs] Ident                     { FieldAExp($1,$3,$4) }
  ExpHigh LParenTok List[ExpAssignNC] RParenTok             { ApplyAExp($1,$3,ParenAround) }
  ExpHigh LBrackTok List[ExpAssignNC] RBrackTok             { ApplyAExp($1,$3,BrackAround) }
  ExpHigh LCurlyTok List[ExpAssignNC] RCurlyTok             { ApplyAExp($1,$3,CurlyAround) }
  ExpHigh ColonColonTok Option[TypeArgs] Ident              { MethodRefAExp($1,$3,$4) }
  ExpHigh ColonColonTok Option[TypeArgs] NewTok             { NewRefAExp($1,$3) }
  ExpHigh TypeArgs                                          { TypeApplyAExp($1,$2) }

Lit ALit
  IntLitTok     { IntALit($1.v) }
  LongLitTok    { LongALit($1.v) }
  FloatLitTok   { FloatALit($1.v) }
  DoubleLitTok  { DoubleALit($1.v) }
  BoolLitTok    { BoolALit($1.v) }
  CharLitTok    { CharALit($1.v) }
  StringLitTok  { StringALit($1.v) }
  NullLitTok    { NullALit() }

PostOp UnaryOp
  PlusPlusTok    { PostIncOp() }
  MinusMinusTok  { PostDecOp() }

PreOp UnaryOp
  PlusPlusTok    { PreIncOp() }
  MinusMinusTok  { PreDecOp() }
  PlusTok        { PosOp() }
  MinusTok       { NegOp() }
  CompTok        { CompOp() }
  NotTok         { NotOp() }

BinaryOp BinaryOp
  MulTok              { MulOp() }
  DivTok              { DivOp() }
  ModTok              { ModOp() }
  PlusTok             { AddOp() }
  MinusTok            { SubOp() }
  LShiftTok           { LShiftOp() }
  RShiftTok           { RShiftOp() }
  UnsignedRShiftTok   { UnsignedRShiftOp() }
  LtTok               { LtOp() }
  GtTok               { GtOp() }
  LeTok               { LeOp() }
  GeTok               { GeOp() }
  InstanceofTok       { InstanceofOp() }
  EqEqTok             { EqOp() }
  NeTok               { NeOp() }
  AndTok              { AndOp() }
  XorTok              { XorOp() }
  OrTok               { OrOp() }
  AndAndTok           { AndAndOp() }
  OrOrTok             { OrOrOp() }

AssignOp Option[AssignOp]
  EqTok                { None }
  MulEqTok             { Some(MulOp()) }
  DivEqTok             { Some(DivOp()) }
  ModEqTok             { Some(ModOp()) }
  PlusEqTok            { Some(AddOp()) }
  MinusEqTok           { Some(SubOp()) }
  LShiftEqTok          { Some(LShiftOp()) }
  RShiftEqTok          { Some(RShiftOp()) }
  UnsignedRShiftEqTok  { Some(UnsignedRShiftOp()) }
  AndEqTok             { Some(AndOp()) }
  XorEqTok             { Some(XorOp()) }
  OrEqTok              { Some(OrOp()) }