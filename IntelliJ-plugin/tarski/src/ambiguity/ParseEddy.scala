// Autogenerated by ambiguity.  DO NOT EDIT!
package ambiguity
import tarski.Tokens._
import tarski.AST._

object ParseEddy {
  def parse(input: Seq[Token]): List[Stmt] = {
    type R = (Int,Int)
    import scala.collection.mutable
    
    // Functions for matching tokens
    val array = input.toArray
    def tok(r: R) = if (r._2-r._1==1) Some(array(r._1)) else None
    def P_PlusEqTok(r: R) = tok(r) match { case Some(t: PlusEqTok) => List(t); case _ => Nil }
    def P_OrTok(r: R) = tok(r) match { case Some(t: OrTok) => List(t); case _ => Nil }
    def P_SynchronizedTok(r: R) = tok(r) match { case Some(t: SynchronizedTok) => List(t); case _ => Nil }
    def P_ModTok(r: R) = tok(r) match { case Some(t: ModTok) => List(t); case _ => Nil }
    def P_CommaTok(r: R) = tok(r) match { case Some(t: CommaTok) => List(t); case _ => Nil }
    def P_SuperTok(r: R) = tok(r) match { case Some(t: SuperTok) => List(t); case _ => Nil }
    def P_CompTok(r: R) = tok(r) match { case Some(t: CompTok) => List(t); case _ => Nil }
    def P_AbstractTok(r: R) = tok(r) match { case Some(t: AbstractTok) => List(t); case _ => Nil }
    def P_ProtectedTok(r: R) = tok(r) match { case Some(t: ProtectedTok) => List(t); case _ => Nil }
    def P_StringLitTok(r: R) = tok(r) match { case Some(t: StringLitTok) => List(t); case _ => Nil }
    def P_DotTok(r: R) = tok(r) match { case Some(t: DotTok) => List(t); case _ => Nil }
    def P_NotTok(r: R) = tok(r) match { case Some(t: NotTok) => List(t); case _ => Nil }
    def P_ColonTok(r: R) = tok(r) match { case Some(t: ColonTok) => List(t); case _ => Nil }
    def P_InstanceofTok(r: R) = tok(r) match { case Some(t: InstanceofTok) => List(t); case _ => Nil }
    def P_ReturnTok(r: R) = tok(r) match { case Some(t: ReturnTok) => List(t); case _ => Nil }
    def P_FinalTok(r: R) = tok(r) match { case Some(t: FinalTok) => List(t); case _ => Nil }
    def P_FloatLitTok(r: R) = tok(r) match { case Some(t: FloatLitTok) => List(t); case _ => Nil }
    def P_UnsignedRShiftTok(r: R) = tok(r) match { case Some(t: UnsignedRShiftTok) => List(t); case _ => Nil }
    def P_LeTok(r: R) = tok(r) match { case Some(t: LeTok) => List(t); case _ => Nil }
    def P_IdentTok(r: R) = tok(r) match { case Some(t: IdentTok) => List(t); case _ => Nil }
    def P_TransientTok(r: R) = tok(r) match { case Some(t: TransientTok) => List(t); case _ => Nil }
    def P_UnsignedRShiftEqTok(r: R) = tok(r) match { case Some(t: UnsignedRShiftEqTok) => List(t); case _ => Nil }
    def P_LtTok(r: R) = tok(r) match { case Some(t: LtTok) => List(t); case _ => Nil }
    def P_IntLitTok(r: R) = tok(r) match { case Some(t: IntLitTok) => List(t); case _ => Nil }
    def P_ColonColonTok(r: R) = tok(r) match { case Some(t: ColonColonTok) => List(t); case _ => Nil }
    def P_AndAndTok(r: R) = tok(r) match { case Some(t: AndAndTok) => List(t); case _ => Nil }
    def P_RShiftEqTok(r: R) = tok(r) match { case Some(t: RShiftEqTok) => List(t); case _ => Nil }
    def P_ContinueTok(r: R) = tok(r) match { case Some(t: ContinueTok) => List(t); case _ => Nil }
    def P_VolatileTok(r: R) = tok(r) match { case Some(t: VolatileTok) => List(t); case _ => Nil }
    def P_RCurlyTok(r: R) = tok(r) match { case Some(t: RCurlyTok) => List(t); case _ => Nil }
    def P_NewTok(r: R) = tok(r) match { case Some(t: NewTok) => List(t); case _ => Nil }
    def P_LCurlyTok(r: R) = tok(r) match { case Some(t: LCurlyTok) => List(t); case _ => Nil }
    def P_XorEqTok(r: R) = tok(r) match { case Some(t: XorEqTok) => List(t); case _ => Nil }
    def P_EqTok(r: R) = tok(r) match { case Some(t: EqTok) => List(t); case _ => Nil }
    def P_PrivateTok(r: R) = tok(r) match { case Some(t: PrivateTok) => List(t); case _ => Nil }
    def P_BreakTok(r: R) = tok(r) match { case Some(t: BreakTok) => List(t); case _ => Nil }
    def P_LParenTok(r: R) = tok(r) match { case Some(t: LParenTok) => List(t); case _ => Nil }
    def P_MulTok(r: R) = tok(r) match { case Some(t: MulTok) => List(t); case _ => Nil }
    def P_DivTok(r: R) = tok(r) match { case Some(t: DivTok) => List(t); case _ => Nil }
    def P_DoubleLitTok(r: R) = tok(r) match { case Some(t: DoubleLitTok) => List(t); case _ => Nil }
    def P_PlusPlusTok(r: R) = tok(r) match { case Some(t: PlusPlusTok) => List(t); case _ => Nil }
    def P_SemiTok(r: R) = tok(r) match { case Some(t: SemiTok) => List(t); case _ => Nil }
    def P_StaticTok(r: R) = tok(r) match { case Some(t: StaticTok) => List(t); case _ => Nil }
    def P_LBrackTok(r: R) = tok(r) match { case Some(t: LBrackTok) => List(t); case _ => Nil }
    def P_XorTok(r: R) = tok(r) match { case Some(t: XorTok) => List(t); case _ => Nil }
    def P_MinusMinusTok(r: R) = tok(r) match { case Some(t: MinusMinusTok) => List(t); case _ => Nil }
    def P_RBrackTok(r: R) = tok(r) match { case Some(t: RBrackTok) => List(t); case _ => Nil }
    def P_NeTok(r: R) = tok(r) match { case Some(t: NeTok) => List(t); case _ => Nil }
    def P_RParenTok(r: R) = tok(r) match { case Some(t: RParenTok) => List(t); case _ => Nil }
    def P_AndEqTok(r: R) = tok(r) match { case Some(t: AndEqTok) => List(t); case _ => Nil }
    def P_CharLitTok(r: R) = tok(r) match { case Some(t: CharLitTok) => List(t); case _ => Nil }
    def P_MinusEqTok(r: R) = tok(r) match { case Some(t: MinusEqTok) => List(t); case _ => Nil }
    def P_GtTok(r: R) = tok(r) match { case Some(t: GtTok) => List(t); case _ => Nil }
    def P_BoolLitTok(r: R) = tok(r) match { case Some(t: BoolLitTok) => List(t); case _ => Nil }
    def P_StrictfpTok(r: R) = tok(r) match { case Some(t: StrictfpTok) => List(t); case _ => Nil }
    def P_EqEqTok(r: R) = tok(r) match { case Some(t: EqEqTok) => List(t); case _ => Nil }
    def P_ExtendsTok(r: R) = tok(r) match { case Some(t: ExtendsTok) => List(t); case _ => Nil }
    def P_GeTok(r: R) = tok(r) match { case Some(t: GeTok) => List(t); case _ => Nil }
    def P_ThrowTok(r: R) = tok(r) match { case Some(t: ThrowTok) => List(t); case _ => Nil }
    def P_NullLitTok(r: R) = tok(r) match { case Some(t: NullLitTok) => List(t); case _ => Nil }
    def P_QuestionTok(r: R) = tok(r) match { case Some(t: QuestionTok) => List(t); case _ => Nil }
    def P_AssertTok(r: R) = tok(r) match { case Some(t: AssertTok) => List(t); case _ => Nil }
    def P_AndTok(r: R) = tok(r) match { case Some(t: AndTok) => List(t); case _ => Nil }
    def P_RShiftTok(r: R) = tok(r) match { case Some(t: RShiftTok) => List(t); case _ => Nil }
    def P_OrEqTok(r: R) = tok(r) match { case Some(t: OrEqTok) => List(t); case _ => Nil }
    def P_LShiftEqTok(r: R) = tok(r) match { case Some(t: LShiftEqTok) => List(t); case _ => Nil }
    def P_LShiftTok(r: R) = tok(r) match { case Some(t: LShiftTok) => List(t); case _ => Nil }
    def P_ModEqTok(r: R) = tok(r) match { case Some(t: ModEqTok) => List(t); case _ => Nil }
    def P_PlusTok(r: R) = tok(r) match { case Some(t: PlusTok) => List(t); case _ => Nil }
    def P_OrOrTok(r: R) = tok(r) match { case Some(t: OrOrTok) => List(t); case _ => Nil }
    def P_LongLitTok(r: R) = tok(r) match { case Some(t: LongLitTok) => List(t); case _ => Nil }
    def P_AtTok(r: R) = tok(r) match { case Some(t: AtTok) => List(t); case _ => Nil }
    def P_MulEqTok(r: R) = tok(r) match { case Some(t: MulEqTok) => List(t); case _ => Nil }
    def P_PublicTok(r: R) = tok(r) match { case Some(t: PublicTok) => List(t); case _ => Nil }
    def P_MinusTok(r: R) = tok(r) match { case Some(t: MinusTok) => List(t); case _ => Nil }
    def P_DivEqTok(r: R) = tok(r) match { case Some(t: DivEqTok) => List(t); case _ => Nil }
    
    // Allocate one sparse array per nonterminal
    val P_Option_TypeArgs__NewTok = mutable.Map[R,List[(Option[KList[Type]],NewTok)]]()
    val P_List_Type = mutable.Map[R,List[KList[Type]]]()
    val P_List1_Type = mutable.Map[R,List[KList[Type]]]()
    val P_Juxts_Type = mutable.Map[R,List[List[Type]]]()
    val P_Commas_Type = mutable.Map[R,List[List[Type]]]()
    val P_Type = mutable.Map[R,List[Type]]()
    val P_RParenTok__Exp = mutable.Map[R,List[(RParenTok,Exp)]]()
    val P_SynchronizedTok__LParenTok = mutable.Map[R,List[(SynchronizedTok,LParenTok)]]()
    val P_ColonTok__Exp = mutable.Map[R,List[(ColonTok,Exp)]]()
    val P_List_Exp__RParenTok = mutable.Map[R,List[(KList[Exp],RParenTok)]]()
    val P_Exp__LBrackTok = mutable.Map[R,List[(Exp,LBrackTok)]]()
    val P_DotTok__IdentTok = mutable.Map[R,List[(DotTok,IdentTok)]]()
    val P_Exp__ColonColonTok = mutable.Map[R,List[(Exp,ColonColonTok)]]()
    val P_EqTok__Exp = mutable.Map[R,List[(EqTok,Exp)]]()
    val P_Stmts = mutable.Map[R,List[List[Stmt]]]()
    val P_Stmt = mutable.Map[R,List[Stmt]]()
    val P_StmtHelper = mutable.Map[R,List[Stmt]]()
    val P_Block = mutable.Map[R,List[List[Stmt]]]()
    val P_Exp__RParenTok = mutable.Map[R,List[(Exp,RParenTok)]]()
    val P_List_Exp = mutable.Map[R,List[KList[Exp]]]()
    val P_List1_Exp = mutable.Map[R,List[KList[Exp]]]()
    val P_Commas_Exp = mutable.Map[R,List[List[Exp]]]()
    val P_Option_Exp = mutable.Map[R,List[Option[Exp]]]()
    val P_Juxts_Exp = mutable.Map[R,List[List[Exp]]]()
    val P_Option_TypeArgs__Exp = mutable.Map[R,List[(Option[KList[Type]],Exp)]]()
    val P_Exp = mutable.Map[R,List[Exp]]()
    val P_Lit = mutable.Map[R,List[Lit]]()
    val P_CommaTok__Commas_Exp = mutable.Map[R,List[(CommaTok,List[Exp])]]()
    val P_Exp__DotTok = mutable.Map[R,List[(Exp,DotTok)]]()
    val P_LParenTok__Type = mutable.Map[R,List[(LParenTok,Type)]]()
    val P_List_Exp__RBrackTok = mutable.Map[R,List[(KList[Exp],RBrackTok)]]()
    val P_List1_VarDecl = mutable.Map[R,List[KList[(NameDims,Option[Exp])]]]()
    val P_Commas_VarDecl = mutable.Map[R,List[List[(NameDims,Option[Exp])]]]()
    val P_Juxts_VarDecl = mutable.Map[R,List[List[(NameDims,Option[Exp])]]]()
    val P_VarDecl = mutable.Map[R,List[(NameDims,Option[Exp])]]()
    val P_IdentDims = mutable.Map[R,List[NameDims]]()
    val P_LBrackTok__RBrackTok = mutable.Map[R,List[(LBrackTok,RBrackTok)]]()
    val P_AssignOp__Exp = mutable.Map[R,List[(Option[AssignOp],Exp)]]()
    val P_Exp__QuestionTok = mutable.Map[R,List[(Exp,QuestionTok)]]()
    val P_Mod = mutable.Map[R,List[Mod]]()
    val P_CommaTok__Commas_VarDecl = mutable.Map[R,List[(CommaTok,List[(NameDims,Option[Exp])])]]()
    val P_AssertTok__Exp = mutable.Map[R,List[(AssertTok,Exp)]]()
    val P_BinaryOp__Exp = mutable.Map[R,List[(BinaryOp,Exp)]]()
    val P_Option_SemiTok = mutable.Map[R,List[Option[SemiTok]]]()
    val P_Option_TypeArgs = mutable.Map[R,List[Option[KList[Type]]]]()
    val P_TypeArgs = mutable.Map[R,List[KList[Type]]]()
    val P_BinaryOp = mutable.Map[R,List[BinaryOp]]()
    val P_PostOp = mutable.Map[R,List[UnaryOp]]()
    val P_Option_TypeArgs__IdentTok = mutable.Map[R,List[(Option[KList[Type]],IdentTok)]]()
    val P_Option_IdentTok = mutable.Map[R,List[Option[IdentTok]]]()
    val P_Exp__Block = mutable.Map[R,List[(Exp,List[Stmt])]]()
    val P_RParenTok__Block = mutable.Map[R,List[(RParenTok,List[Stmt])]]()
    val P_PreOp = mutable.Map[R,List[UnaryOp]]()
    val P_WildcardBounds = mutable.Map[R,List[Option[(Bound,Type)]]]()
    val P_AssignOp = mutable.Map[R,List[Option[AssignOp]]]()
    val P_Exp__RParenTok__Block = mutable.Map[R,List[(Exp,RParenTok,List[Stmt])]]()
    val P_List_Type__GtTok = mutable.Map[R,List[(KList[Type],GtTok)]]()
    val P_Exp__ColonTok__Exp = mutable.Map[R,List[(Exp,ColonTok,Exp)]]()
    val P_Type__List1_VarDecl = mutable.Map[R,List[(Type,KList[(NameDims,Option[Exp])])]]()
    val P_Stmts__RCurlyTok = mutable.Map[R,List[(List[Stmt],RCurlyTok)]]()
    val P_Exp__LParenTok = mutable.Map[R,List[(Exp,LParenTok)]]()
    val P_CommaTok__Commas_Type = mutable.Map[R,List[(CommaTok,List[Type])]]()
    
    // Parse bottom up for each nonterminal
    val n = input.length
    // Parse null productions
    for (lo <- 0 to n) {
      P_Option_TypeArgs__NewTok((lo,lo)) = List()
      P_List_Type((lo,lo)) = List(EmptyList())
      P_List1_Type((lo,lo)) = List()
      P_Juxts_Type((lo,lo)) = List()
      P_Commas_Type((lo,lo)) = List()
      P_Type((lo,lo)) = List()
      P_RParenTok__Exp((lo,lo)) = List()
      P_SynchronizedTok__LParenTok((lo,lo)) = List()
      P_ColonTok__Exp((lo,lo)) = List()
      P_List_Exp__RParenTok((lo,lo)) = List()
      P_Exp__LBrackTok((lo,lo)) = List()
      P_DotTok__IdentTok((lo,lo)) = List()
      P_Exp__ColonColonTok((lo,lo)) = List()
      P_EqTok__Exp((lo,lo)) = List()
      P_Stmts((lo,lo)) = List(Nil)
      P_Stmt((lo,lo)) = List()
      P_StmtHelper((lo,lo)) = List()
      P_Block((lo,lo)) = List()
      P_Exp__RParenTok((lo,lo)) = List()
      P_List_Exp((lo,lo)) = List(EmptyList())
      P_List1_Exp((lo,lo)) = List()
      P_Commas_Exp((lo,lo)) = List()
      P_Option_Exp((lo,lo)) = List(None)
      P_Juxts_Exp((lo,lo)) = List()
      P_Option_TypeArgs__Exp((lo,lo)) = List()
      P_Exp((lo,lo)) = List()
      P_Lit((lo,lo)) = List()
      P_CommaTok__Commas_Exp((lo,lo)) = List()
      P_Exp__DotTok((lo,lo)) = List()
      P_LParenTok__Type((lo,lo)) = List()
      P_List_Exp__RBrackTok((lo,lo)) = List()
      P_List1_VarDecl((lo,lo)) = List()
      P_Commas_VarDecl((lo,lo)) = List()
      P_Juxts_VarDecl((lo,lo)) = List()
      P_VarDecl((lo,lo)) = List()
      P_IdentDims((lo,lo)) = List()
      P_LBrackTok__RBrackTok((lo,lo)) = List()
      P_AssignOp__Exp((lo,lo)) = List()
      P_Exp__QuestionTok((lo,lo)) = List()
      P_Mod((lo,lo)) = List()
      P_CommaTok__Commas_VarDecl((lo,lo)) = List()
      P_AssertTok__Exp((lo,lo)) = List()
      P_BinaryOp__Exp((lo,lo)) = List()
      P_Option_SemiTok((lo,lo)) = List(None)
      P_Option_TypeArgs((lo,lo)) = List(None)
      P_TypeArgs((lo,lo)) = List()
      P_BinaryOp((lo,lo)) = List()
      P_PostOp((lo,lo)) = List()
      P_Option_TypeArgs__IdentTok((lo,lo)) = List()
      P_Option_IdentTok((lo,lo)) = List(None)
      P_Exp__Block((lo,lo)) = List()
      P_RParenTok__Block((lo,lo)) = List()
      P_PreOp((lo,lo)) = List()
      P_WildcardBounds((lo,lo)) = List(None)
      P_AssignOp((lo,lo)) = List()
      P_Exp__RParenTok__Block((lo,lo)) = List()
      P_List_Type__GtTok((lo,lo)) = List()
      P_Exp__ColonTok__Exp((lo,lo)) = List()
      P_Type__List1_VarDecl((lo,lo)) = List()
      P_Stmts__RCurlyTok((lo,lo)) = List()
      P_Exp__LParenTok((lo,lo)) = List()
      P_CommaTok__Commas_Type((lo,lo)) = List()
    }
    // Parse nonnull productions
    for (lo <- n to 0 by -1; hi <- lo to n) {
      def two[A,B,C](pa: R => List[A], pb: R => List[B])(f: (A,B) => C): List[C] =
        (for (m <- lo to hi; a <- pa((lo,m)); b <- pb((m,hi))) yield f(a,b)).toList
      P_Option_TypeArgs__NewTok((lo,hi)) = two(P_Option_TypeArgs,P_NewTok)((x,y) => (x,y))
      P_List_Type((lo,hi)) = P_List1_Type(lo,hi).map(x => x)
      P_List1_Type((lo,hi)) = P_Commas_Type(lo,hi).map(x => CommaList(x)) ::: P_Juxts_Type(lo,hi).map(x => JuxtList(x))
      P_Juxts_Type((lo,hi)) = P_Type(lo,hi).map(x => List(x)) ::: two(P_Type,P_Juxts_Type)((x,y) => x :: y)
      P_Commas_Type((lo,hi)) = P_Type(lo,hi).map(x => List(x)) ::: two(P_Type,P_CommaTok__Commas_Type)((x,y) => x :: y._2)
      P_Type((lo,hi)) = P_IdentTok(lo,hi).map(x => NameType(x.name)) ::: two(P_Mod,P_Type)((x,y) => ModType(x,y)) ::: two(P_Type,P_LBrackTok__RBrackTok)((x,y) => ArrayType(x)) ::: two(P_Type,P_TypeArgs)((x,y) => ApplyType(x,y)) ::: two(P_Type,P_DotTok__IdentTok)((x,y) => FieldType(x,y._2.name)) ::: two(P_QuestionTok,P_WildcardBounds)((x,y) => WildType(y))
      P_RParenTok__Exp((lo,hi)) = two(P_RParenTok,P_Exp)((x,y) => (x,y))
      P_SynchronizedTok__LParenTok((lo,hi)) = two(P_SynchronizedTok,P_LParenTok)((x,y) => (x,y))
      P_ColonTok__Exp((lo,hi)) = two(P_ColonTok,P_Exp)((x,y) => (x,y)) ::: two(P_ColonTok,P_Exp)((x,y) => (x,y))
      P_List_Exp__RParenTok((lo,hi)) = two(P_List_Exp,P_RParenTok)((x,y) => (x,y))
      P_Exp__LBrackTok((lo,hi)) = two(P_Exp,P_LBrackTok)((x,y) => (x,y))
      P_DotTok__IdentTok((lo,hi)) = two(P_DotTok,P_IdentTok)((x,y) => (x,y))
      P_Exp__ColonColonTok((lo,hi)) = two(P_Exp,P_ColonColonTok)((x,y) => (x,y)) ::: two(P_Exp,P_ColonColonTok)((x,y) => (x,y))
      P_EqTok__Exp((lo,hi)) = two(P_EqTok,P_Exp)((x,y) => (x,y))
      P_Stmts((lo,hi)) = two(P_Stmt,P_Stmts)((x,y) => x :: y)
      P_Stmt((lo,hi)) = P_SemiTok(lo,hi).map(x => EmptyStmt()) ::: two(P_StmtHelper,P_Option_SemiTok)((x,y) => x)
      P_StmtHelper((lo,hi)) = two(P_Mod,P_Type__List1_VarDecl)((x,y) => VarStmt(x,y._1,y._2)) ::: P_Block(lo,hi).map(x => BlockStmt(x)) ::: P_Exp(lo,hi).map(x => ExpStmt(x)) ::: two(P_AssertTok,P_Exp)((x,y) => AssertStmt(y,None)) ::: two(P_AssertTok__Exp,P_ColonTok__Exp)((x,y) => AssertStmt(x._2,Some(y._2))) ::: two(P_BreakTok,P_Option_IdentTok)((x,y) => BreakStmt(y.map(_.name))) ::: two(P_ContinueTok,P_Option_IdentTok)((x,y) => ContinueStmt(y.map(_.name))) ::: two(P_ReturnTok,P_Option_Exp)((x,y) => ReturnStmt(y)) ::: two(P_ThrowTok,P_Exp)((x,y) => ThrowStmt(y)) ::: two(P_SynchronizedTok,P_Exp__Block)((x,y) => SyncStmt(y._1,y._2)) ::: two(P_SynchronizedTok__LParenTok,P_Exp__RParenTok__Block)((x,y) => SyncStmt(y._1,y._3))
      P_Block((lo,hi)) = two(P_LCurlyTok,P_Stmts__RCurlyTok)((x,y) => y._1)
      P_Exp__RParenTok((lo,hi)) = two(P_Exp,P_RParenTok)((x,y) => (x,y))
      P_List_Exp((lo,hi)) = P_List1_Exp(lo,hi).map(x => x)
      P_List1_Exp((lo,hi)) = P_Commas_Exp(lo,hi).map(x => CommaList(x)) ::: P_Juxts_Exp(lo,hi).map(x => JuxtList(x))
      P_Commas_Exp((lo,hi)) = P_Exp(lo,hi).map(x => List(x)) ::: two(P_Exp,P_CommaTok__Commas_Exp)((x,y) => x :: y._2)
      P_Option_Exp((lo,hi)) = P_Exp(lo,hi).map(x => Some(x))
      P_Juxts_Exp((lo,hi)) = P_Exp(lo,hi).map(x => List(x)) ::: two(P_Exp,P_Juxts_Exp)((x,y) => x :: y)
      P_Option_TypeArgs__Exp((lo,hi)) = two(P_Option_TypeArgs,P_Exp)((x,y) => (x,y))
      P_Exp((lo,hi)) = P_IdentTok(lo,hi).map(x => NameExp(x.name)) ::: P_Lit(lo,hi).map(x => LitExp(x)) ::: two(P_LParenTok,P_Exp__RParenTok)((x,y) => ParenExp(y._1)) ::: two(P_Exp__DotTok,P_Option_TypeArgs__IdentTok)((x,y) => FieldExp(x._1,y._1,y._2.name)) ::: two(P_Exp__LBrackTok,P_List_Exp__RBrackTok)((x,y) => IndexExp(x._1,y._1)) ::: two(P_Exp__ColonColonTok,P_Option_TypeArgs__IdentTok)((x,y) => MethodRefExp(x._1,y._1,y._2.name)) ::: two(P_Exp__ColonColonTok,P_Option_TypeArgs__NewTok)((x,y) => NewRefExp(x._1,y._1)) ::: two(P_Exp,P_TypeArgs)((x,y) => TypeApplyExp(x,y)) ::: two(P_Exp__LParenTok,P_List_Exp__RParenTok)((x,y) => ApplyExp(x._1,y._1)) ::: two(P_Exp,P_Juxts_Exp)((x,y) => ApplyExp(x,JuxtList(y))) ::: two(P_NewTok,P_Option_TypeArgs__Exp)((x,y) => NewExp(y._1,y._2)) ::: two(P_QuestionTok,P_WildcardBounds)((x,y) => WildExp(y)) ::: two(P_Exp,P_PostOp)((x,y) => UnaryExp(y,x)) ::: two(P_PreOp,P_Exp)((x,y) => UnaryExp(x,y)) ::: two(P_LParenTok__Type,P_RParenTok__Exp)((x,y) => CastExp(x._2,y._2)) ::: two(P_Exp,P_BinaryOp__Exp)((x,y) => BinaryExp(x,y._1,y._2)) ::: two(P_Exp__QuestionTok,P_Exp__ColonTok__Exp)((x,y) => CondExp(x._1,y._1,y._3)) ::: two(P_Exp,P_AssignOp__Exp)((x,y) => AssignExp(x,y._1,y._2))
      P_Lit((lo,hi)) = P_IntLitTok(lo,hi).map(x => IntLit(x.v)) ::: P_LongLitTok(lo,hi).map(x => LongLit(x.v)) ::: P_FloatLitTok(lo,hi).map(x => FloatLit(x.v)) ::: P_DoubleLitTok(lo,hi).map(x => DoubleLit(x.v)) ::: P_BoolLitTok(lo,hi).map(x => BoolLit(x.v)) ::: P_CharLitTok(lo,hi).map(x => CharLit(x.v)) ::: P_StringLitTok(lo,hi).map(x => StringLit(x.v)) ::: P_NullLitTok(lo,hi).map(x => NullLit())
      P_CommaTok__Commas_Exp((lo,hi)) = two(P_CommaTok,P_Commas_Exp)((x,y) => (x,y))
      P_Exp__DotTok((lo,hi)) = two(P_Exp,P_DotTok)((x,y) => (x,y))
      P_LParenTok__Type((lo,hi)) = two(P_LParenTok,P_Type)((x,y) => (x,y))
      P_List_Exp__RBrackTok((lo,hi)) = two(P_List_Exp,P_RBrackTok)((x,y) => (x,y))
      P_List1_VarDecl((lo,hi)) = P_Commas_VarDecl(lo,hi).map(x => CommaList(x)) ::: P_Juxts_VarDecl(lo,hi).map(x => JuxtList(x))
      P_Commas_VarDecl((lo,hi)) = P_VarDecl(lo,hi).map(x => List(x)) ::: two(P_VarDecl,P_CommaTok__Commas_VarDecl)((x,y) => x :: y._2)
      P_Juxts_VarDecl((lo,hi)) = P_VarDecl(lo,hi).map(x => List(x)) ::: two(P_VarDecl,P_Juxts_VarDecl)((x,y) => x :: y)
      P_VarDecl((lo,hi)) = P_IdentDims(lo,hi).map(x => (x,None)) ::: two(P_IdentDims,P_EqTok__Exp)((x,y) => (x,Some(y._2)))
      P_IdentDims((lo,hi)) = P_IdentTok(lo,hi).map(x => (x.name,0)) ::: two(P_IdentDims,P_LBrackTok__RBrackTok)((x,y) => (x._1,x._2+1))
      P_LBrackTok__RBrackTok((lo,hi)) = two(P_LBrackTok,P_RBrackTok)((x,y) => (x,y)) ::: two(P_LBrackTok,P_RBrackTok)((x,y) => (x,y))
      P_AssignOp__Exp((lo,hi)) = two(P_AssignOp,P_Exp)((x,y) => (x,y))
      P_Exp__QuestionTok((lo,hi)) = two(P_Exp,P_QuestionTok)((x,y) => (x,y))
      P_Mod((lo,hi)) = two(P_AtTok,P_IdentTok)((x,y) => Annotation(y.name)) ::: P_PublicTok(lo,hi).map(x => Public()) ::: P_ProtectedTok(lo,hi).map(x => Protected()) ::: P_PrivateTok(lo,hi).map(x => Private()) ::: P_AbstractTok(lo,hi).map(x => Abstract()) ::: P_StaticTok(lo,hi).map(x => Static()) ::: P_FinalTok(lo,hi).map(x => Final()) ::: P_StrictfpTok(lo,hi).map(x => Strictfp()) ::: P_TransientTok(lo,hi).map(x => Transient()) ::: P_VolatileTok(lo,hi).map(x => Volatile()) ::: P_SynchronizedTok(lo,hi).map(x => Synchronized())
      P_CommaTok__Commas_VarDecl((lo,hi)) = two(P_CommaTok,P_Commas_VarDecl)((x,y) => (x,y))
      P_AssertTok__Exp((lo,hi)) = two(P_AssertTok,P_Exp)((x,y) => (x,y))
      P_BinaryOp__Exp((lo,hi)) = two(P_BinaryOp,P_Exp)((x,y) => (x,y))
      P_Option_SemiTok((lo,hi)) = P_SemiTok(lo,hi).map(x => Some(x))
      P_Option_TypeArgs((lo,hi)) = P_TypeArgs(lo,hi).map(x => Some(x))
      P_TypeArgs((lo,hi)) = two(P_LtTok,P_List_Type__GtTok)((x,y) => y._1)
      P_BinaryOp((lo,hi)) = P_MulTok(lo,hi).map(x => MulOp()) ::: P_DivTok(lo,hi).map(x => DivOp()) ::: P_ModTok(lo,hi).map(x => ModOp()) ::: P_PlusTok(lo,hi).map(x => AddOp()) ::: P_MinusTok(lo,hi).map(x => SubOp()) ::: P_LShiftTok(lo,hi).map(x => LShiftOp()) ::: P_RShiftTok(lo,hi).map(x => RShiftOp()) ::: P_UnsignedRShiftTok(lo,hi).map(x => UnsignedRShiftOp()) ::: P_LtTok(lo,hi).map(x => LtOp()) ::: P_GtTok(lo,hi).map(x => GtOp()) ::: P_LeTok(lo,hi).map(x => LeOp()) ::: P_GeTok(lo,hi).map(x => GeOp()) ::: P_InstanceofTok(lo,hi).map(x => InstanceofOp()) ::: P_EqEqTok(lo,hi).map(x => EqOp()) ::: P_NeTok(lo,hi).map(x => NeOp()) ::: P_AndTok(lo,hi).map(x => AndOp()) ::: P_XorTok(lo,hi).map(x => XorOp()) ::: P_OrTok(lo,hi).map(x => OrOp()) ::: P_AndAndTok(lo,hi).map(x => AndAndOp()) ::: P_OrOrTok(lo,hi).map(x => OrOrOp())
      P_PostOp((lo,hi)) = P_PlusPlusTok(lo,hi).map(x => PostIncOp()) ::: P_MinusMinusTok(lo,hi).map(x => PostDecOp())
      P_Option_TypeArgs__IdentTok((lo,hi)) = two(P_Option_TypeArgs,P_IdentTok)((x,y) => (x,y)) ::: two(P_Option_TypeArgs,P_IdentTok)((x,y) => (x,y))
      P_Option_IdentTok((lo,hi)) = P_IdentTok(lo,hi).map(x => Some(x))
      P_Exp__Block((lo,hi)) = two(P_Exp,P_Block)((x,y) => (x,y))
      P_RParenTok__Block((lo,hi)) = two(P_RParenTok,P_Block)((x,y) => (x,y))
      P_PreOp((lo,hi)) = P_PlusPlusTok(lo,hi).map(x => PreIncOp()) ::: P_MinusMinusTok(lo,hi).map(x => PreDecOp()) ::: P_PlusTok(lo,hi).map(x => PosOp()) ::: P_MinusTok(lo,hi).map(x => NegOp()) ::: P_CompTok(lo,hi).map(x => CompOp()) ::: P_NotTok(lo,hi).map(x => NotOp())
      P_WildcardBounds((lo,hi)) = two(P_ExtendsTok,P_Type)((x,y) => Some((Extends(),y))) ::: two(P_ColonTok,P_Type)((x,y) => Some((Extends(),y))) ::: two(P_SuperTok,P_Type)((x,y) => Some((Super(),y)))
      P_AssignOp((lo,hi)) = P_EqTok(lo,hi).map(x => None) ::: P_MulEqTok(lo,hi).map(x => Some(MulOp())) ::: P_DivEqTok(lo,hi).map(x => Some(DivOp())) ::: P_ModEqTok(lo,hi).map(x => Some(ModOp())) ::: P_PlusEqTok(lo,hi).map(x => Some(AddOp())) ::: P_MinusEqTok(lo,hi).map(x => Some(SubOp())) ::: P_LShiftEqTok(lo,hi).map(x => Some(LShiftOp())) ::: P_RShiftEqTok(lo,hi).map(x => Some(RShiftOp())) ::: P_UnsignedRShiftEqTok(lo,hi).map(x => Some(UnsignedRShiftOp())) ::: P_AndEqTok(lo,hi).map(x => Some(AndOp())) ::: P_XorEqTok(lo,hi).map(x => Some(XorOp())) ::: P_OrEqTok(lo,hi).map(x => Some(OrOp()))
      P_Exp__RParenTok__Block((lo,hi)) = two(P_Exp,P_RParenTok__Block)((x,y) => (x,y._1,y._2))
      P_List_Type__GtTok((lo,hi)) = two(P_List_Type,P_GtTok)((x,y) => (x,y))
      P_Exp__ColonTok__Exp((lo,hi)) = two(P_Exp,P_ColonTok__Exp)((x,y) => (x,y._1,y._2))
      P_Type__List1_VarDecl((lo,hi)) = two(P_Type,P_List1_VarDecl)((x,y) => (x,y))
      P_Stmts__RCurlyTok((lo,hi)) = two(P_Stmts,P_RCurlyTok)((x,y) => (x,y))
      P_Exp__LParenTok((lo,hi)) = two(P_Exp,P_LParenTok)((x,y) => (x,y))
      P_CommaTok__Commas_Type((lo,hi)) = two(P_CommaTok,P_Commas_Type)((x,y) => (x,y))
    }
    
    // All done!
    P_Stmt((0,n))
  }
}
